---
layout: post
title: 《On Java8》第十章——接口
date: 2020-02-14 23:47:11
tags:
- 读书笔记
categories: 
- 《On Java8》

---

## 第十章 接口

接口和抽象类提供了一种将接口与实现分离的更加**结构化**的方法。

<!-- more -->	

这种机制在编程语言中不常见，例如 C++ 只对这种概念有间接的支持。而在 Java 中存在这些关键字，说明这些思想很重要， Java 为它们提供了直接支持。

首先，我们将学习抽象类，一种**介于普通类和接口之间的折中手段**。尽管你的第一想法是创建接口，但是构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具，**你不可能总是使用纯粹的接口。**



#### 抽象类和方法

在上一章乐器的例子中，基类 Instrument 中的方法往往是 "哑"方法，如果调用了这些方法，就会出现一些错误。这是因为**接口的目的是为它的派生类创建一个通用接口。**

在那些例子中，创建这个通用接口的唯一理由是，**不同的子类可以用不同的方式表示此接口**。【不同子类有不同的实现。】通用接口建立了一个基本形式，以此表达所有派生类的共同部分。另一种说法把 Instrument 称为抽象基类，或简称为抽象类。

对于像 Instrument 那样的抽象类来说，它的实例对象几乎总是没有意义的。【因为抽象类就是规定了部分行为，而具体的动作需要其子类根据需要个性化的定制，所以实例化抽象类的对象没有意义】 **创建一个抽象类是为了通过通用接口操作那个一系列类。因此 Instrument 只是表示接口** 【接口的作用：定义一系列类的统一操作方式】因此 Instrument只是表示接口，不是具体实现。 所以创建一个该类的对象毫无意义，我们可能希望阻止用户这么做，通过让 Instrument 所有的方法产生错误，就可以达到这个目的。但是这么做会延迟到运行时才得知该错误，并且需要客户进行可靠详细的测试。最好在编译时就能捕捉到问题。

Java 提供了一个语法叫**抽象方法的机制。这个方法是不完整的：它只有声明没有方法体。**

```java
abstract void f();
```

包含抽象方法的类叫做抽象类，如果类包含抽象方法则其必须也用 abstract 关键词修饰。

```java
abstract class Basic{
	abstract void unimplementedMethod();
}
```

如果一个抽象类是不完整的，当视同创建这个类的对象时，编译器会抛出错误信息。这样保证了抽象类的纯粹性，我们不用担心误用它。

```java
public class AttemptToUseBasic {
	Basic b = new Basic(); // 抛出异常, error: Basic is abstract; cannot be instantiated
}
```

如果创建一个继承抽象类的新类并为之创建对象，那么就必须实现基类所有的抽象方法，如果不这么做（可以选择不做）新类仍然为一个抽象类，编译器会强制我们为类加上 abstract 关键字。	

```java
asbsctract class Basic2 extends Basic	{
	int f() {
		return 111;
	}
	
	abstract void g() {
	
	} // 重新定义了一个抽象方法
}

```

可以将一个不包含任何抽象方法的类指明为abstract ，在类中的抽象方法没啥意义但想组织创建类的对象时这么做就很有用。



为了创建可创实话的类，就要继承抽象类，并提供所有抽象方法的定义

```java

abstract class Uninstantiable {
    abstract void f();

    abstract int g();
}

public class Instantiable extends Uninstantiable {
    @Override
    void f() {
        System.out.println("f()");
    }

    @Override
    int g() {
        return 22;
    }

    public static void main(String[] args) {
        Instantiable instantiable = new Instantiable();
    }
}

```

这里 抽象类的方法也是自动被指明为 public 的。

创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器的使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法

【说人话就是把最通用的方法放在顶层接口中，让子类分别做出不同的实现】



#### 接口创建

使用 interface 关键字创建接口。

描述 Java8 之前的接口更加容易，因为它们只允许抽象方法：

```java
public interface PureInterface {
    int m1();

    void m2();

    double m3();
}
```

我们甚至不用为方法增加 abstract 关键字，因为方法在接口中。 Java 知道这些方法不能有方法体。

在 Java8 之前我们可以这么描述： interface 关键字产生一个完全抽象的类，没有提供任何实现。**我们只能描述类应该像什么，做什么，但不能描述怎么做**。即只能决定方法名，参数列表和返回类型，但是无法确定方法体**。接口只提供形式，通常来说没有实现**，尽管在某些受限制的情况下可以有实现。

**一个接口表示：所有实现了该接口的类看起来都像这样。**因此，任何使用某特定接口的代码知道可以调用该接口的哪些方法，而且仅需要知道这些。**所以，接口被用来建立类之间的协议。**（一些面向对象编程语言中，使用 protocol 关键字完成相同的功能）

Java8 中为接口添加了新的功能，接口允许包含默认方法和静态方法——基于某些重要的原因。**接口的基本概念依然没变**，介于**类型之上、实现之下**。接口与抽象类最明显的**区别**可能就是**使用上的惯用方**式。**接口的典型使用代表一个类的类型或一个形容词**，如 Runnable 或 Serializable，而**抽象类通常是类层次结构的一部分或一件事物的类型** 如 String 或 ActionHero。

使用关键字 interface 而不是 class 来创建接口。 和类一样，需要在 interface 前加上public 关键字，否则接口只有包访问权限，只能在与接口相同包下才能使用它。

接口同样可以包含属性，这些属性被隐式之名为 static 和 final。

使用 implements 关键字使一个类遵循某个特定接口（或一组接口）它表示：接**口只是外形，现在我要说明它是如何工作的。**除此之外，它看起来像继承。



#### 默认方法

Java 8 为关键字 default 增加了一个新的用途（之前只用于 switch 语句和 注解中）

当在接口中使用它的时候，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常实用，将在“**流式编程**”中看到。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211140830.png)

default 方法相当于接口中自带的一个可以直接拿来使用的默认方法。 尽管 ImplementingInterface 类没有实现 idea3 ，但是可以直接拿来使用了。

增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时候也被称为：**守卫方法** 或 **虚拟扩展方法**

【表示这俩方法都没听过，还是叫接口默认方法来的好】



#### 多继承

多继承意味着一个类可能从多个父类型中继承特征和特性。

Java 设计之初，C++ 的多继承机制饱受诟病。 Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。**在 Java8 之前接口没有包袱——它只是方法外貌的描述。**

多年后的现在，Java 通过默认方法具有了某种多继承的特性。集合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不存在属性（只有静态属性，不适用），所以**属性仍然只会来自但个基类或抽象类**，也就是说，不**会存在状态的多继承。**

##### 代码如下：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211143117.png)

现在我们就在做些 Java8 之前不可能完成的事：结合多个源的实现。**只要基类方法中的方法名和参数列表不同，就能工作的很好**，否则编译器会报错。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211143240.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211143257.png)

当我们重新定义first的方法签名后，代码正常运行。因为编译器用方法签名来区分两个方法，为了解决这个问题我们只能覆写冲突的方法。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211143413.png)



### 接口中的静态方法

Java8 允许在接口中添加静态方法。这么做能恰当地把工具功能放置在接口中，从而操作接口或者成为通用工具。

【这样就不需要类似Collections】的工具类了。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211145046.png)

这是模板方法设计模式的一个版本。 **runOps()**  是一个模板方法，其使用可变参数列表，因而我们可以传入任意多的 Operation 参数并按顺序运行它们。



### Instrument 作为接口

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211145851.png)

类 Woodwind 和 Brass 说明一旦实现了某个接口，那么其实现类就变成了一个普通类，可以按常规方式扩展它。

接口的工作方式让我们不需要显示声明其中方法为 public ，它们自动为 public

**play() 和 adjust() 使用 default 关键字定义实现。 在 Java8之前，这些定义要在每个实现中重复实现，显得多余且令人烦恼。**

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211150444.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211150518.png)



这里因为使用了默认方法，其接口的实现类就不需要重复的实现接口中的方法了。

注意到，无论是将其向上转型为称作 Instrument 的普通类，或称作 Instrument 的抽象类，还是叫做 Instrument 的接口，其行为都是相同的。 事实上，从 tune() 方法上看不出来 Instrument 到底是一个普通类，抽象类，还是一个接口。



### 抽象类和接口

尤其是在 Java8 引入 default 方法之后，选择用抽象类还是接口变得更加令人困惑。下表做了明确的区分：

| 特性               | 接口                                                       | 抽象类                                   |
| ------------------ | ---------------------------------------------------------- | ---------------------------------------- |
| 组合               | 新类可以组合多个接口                                       | 只能继承单一抽象类                       |
| 状态               | 不能包含属性（除了静态属性，不支持对象状态）               | 可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法和抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 | 必须在子类中实现抽象方法。               |
| 构造器             | 没有构造器                                                 | 可以有构造器                             |
| 可见性             | 隐式 public                                                | 可以是 protected 或 友元                 |

> **抽象类仍然是一个类，在创建新类时只能继承它一个**。而创建类的过程可以实现多个接口。

> 有一条实际经验：**尽可能地抽象**。因此，更倾向于使用接口而不是抽象类。
>

**【一般抽象类用来实现某种类的大部分一般行为，然后具体子类再去实现更具体的行为】**



### 完全解耦

当方法操作的是一个类而非接口时，它就只能作用于那个类或其子类。如果想把方法应用于那个继承层级之外的类，就无法实现。

【因为类的单继承结构】

接口在很大程度上放宽了整个限制，因而使用接口可以编写复用性更好的代码。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211154022.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211154036.png)

**Applicator** 中的 apply() 方法可以接收任何类型的 Processor 只要实现了该接口，并将其应用到一个 Object 对象上输出结果。

像这个例子，创建一个能根据传入参数的类型从而具备不同行为的方法称为 **策略模式**。

方法包含算法中不变的部分，策略包含变化的部分。根据传入的策略对象不同，包含不同要执行的代码。

这里 Processor 对象是策略， main() 方法展示了三种不同的应用于 String s 上的策略。

```java
// interfaces/filters/Waveform.java
package interfaces.filters;

public class Waveform {
    private static long counter;
    private final long id = counter++;

    @Override
    public String toString() {
        return "Waveform " + id;
    }
}

// interfaces/filters/Filter.java
package interfaces.filters;

public class Filter {
    public String name() {
        return getClass().getSimpleName();
    }

    public Waveform process(Waveform input) {
        return input;
    }
}

// interfaces/filters/LowPass.java
package interfaces.filters;

public class LowPass extends Filter {
    double cutoff;

    public LowPass(double cutoff) {
        this.cutoff = cutoff;
    }

    @Override
    public Waveform process(Waveform input) {
        return input; // Dummy processing 哑处理
    }
}

// interfaces/filters/HighPass.java
package interfaces.filters;

public class HighPass extends Filter {
    double cutoff;

    public HighPass(double cutoff) {
        this.cutoff = cutoff;
    }

    @Override
    public Waveform process(Waveform input) {
        return input;
    }
}

// interfaces/filters/BandPass.java
package interfaces.filters;

public class BandPass extends Filter {
    double lowCutoff, highCutoff;

    public BandPass(double lowCut, double highCut) {
        lowCutoff = lowCut;
        highCutoff = highCut;
    }

    @Override
    public Waveform process(Waveform input) {
        return input;
    }
}
```

Filter 类与 Processor 类具有相同的接口元素，但是因为它不是继承自 Processor，因为 Filter 类的创建者根本不知道你想将它当做 Processor 使用。因此你不能将 Applicator 的 apply() 方法应用在 Filter类上，即时这样做也能正常运行。主要是因为 Applicator 的 apply() 方法和 Processor 过于耦合，这组织了 Applicator 的 apply() 方法被复用。 另外要注意的一点是 Filter 类中 process() 方法的输入输出都是 **Waveform**

但如果 Processor 是一个接口，那么限制就会变得松动到足以复用 Applicator 的 apply() 方法，。用来接受那个接口参数，下面是修改后的版本：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211160935.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211160913.png)



这种方式运作的很好，然而你经常遇到的情况是无法修改类。例如在 Waveform例子中，类库是第三方，而不是你自己创建的。

**在这种情况下，可以使用适配器设计模式。**

适配器允许代码接受已有的接口产生需要的接口【也就是做一个转换】：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211162016.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211162030.png)



在这种适配器的方式中， FilterAdapter的构造器接受已有接口 Filter，继而产生需要的 processor接口对象。同时 FilterAdapater 中使用了委托。

协变允许我们从 process() 方法中产生一个 Waveform 而非 Object对象。

将接口与实现解耦 使得接口可以应用于多种不同的实现，因而代码更具可复用性。



### 多接口结合

接口没有任何实现——也就是说，没有任何与接口相关的存储，因此无法阻止结合的多接口。因为有时候你需要表示 一个x 是一个a 和一个b 以及一个c

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211163824.png)

派生类并不要求必须继承抽象或具体的基类。如果继承一个非接口的类，那么只能继承一个类。其余元素必须都是接口。需要将所有接口名置于 implements 关键字之后用逗号分隔，**可以有任意多个接口，并可以向上转型为每个接口。因为每个接口都是独立的类型。**



### 使用继承扩展接口

使用继承，可以很容易在接口中增加方法声明。还可以在新接口中结合多个接口。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211171657.png)

这里可以看到 Vampire 继承了2个接口，通常来说 extends 只能用于单一类，但是在构建接口时可以引用多个基类接口，用逗号分隔。

【这里一个类可以是多个类型感觉还是挺有用的。大大增强通用性。】



### 结合接口时的命名冲突

当实现多个接口时可能会存在一个小陷阱【我就喜欢看这种可能有坑的点，知道哪里可能会出问题才是最重要的】，在前面的例子中，**CanFight** 和 **ActionChracter** 具有完全相同的 **fight()** 方法。完全相同的方法没有问题，但是如果它们的签名和返回类型不同会怎样呢？看例子

这是之前的

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211205936.png)



这是现在出问题的：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211211746.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211211728.png)

这里当一个类继承C并实现I1接口时，由于方法的签名完全一致而返回值不同，导致报错。

覆写、实现和重载令人不快地搅合在了一起带来了困难。同时，重载方法仅根据返回类型事务无法区分的。

【这里我有个问题】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211211850.png)

**【这里的 f 不是单纯的实现接口定义的方法么，怎么就重载了？】**



当打算组合接口时，在不同接口中使用相同的方法名通常会造成代码可读性混乱，要尽量避免这种情况。



### 接口适配

**接口最吸引的原因之一就是相同的接口可以有多个实现。**在简单情况下体现在一个方法接受接口作为参数，具体的实现则由不同子类来分别自己定义。

##### 因此，接口的一种常见用法是前面提到的 **策略模式**，编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说，只要对象遵循这个接口，就可以调用方法。这使得方法更加灵活，通用，并更具可复用性。



例如类 Scanner 的构造器接受一个 Readable 接口。你会发现 Readable 没有用作Java标准库中其他任何方法的参数——它是单独为 Scanner 创建的。因此 Scanner没有将其参数限制为某个特定类。通过这种方式，Scanner 可以与更多的类型协作，如果你创建了一个新类并想让 Scanner 作用于它，就让你的类实现 Readble接口，如下：

#### SCanner 构造函数

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211213747.png)



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211214744.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211214732.png)



Readable 接口只需要实现 **read()** 方法，在 read() 方法里，将输入内容添加到 **CharBuffer**参数中，（有多种方法可以实现，查看 CharBuffer 文档） 或在没有输入时返回 -1



假如你的类没有实现 Readble接口，怎样才能让 Scanner 作用于它呢？又要用到适配器模式了下面一个随机产生浮点数的例子

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211220722.png)

##### 使用代理来输出随机数

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211221533.png)

你可以用这种方式在已有类中增加新接口。这就意味着一个接受接口类型的方法提供了一种让任何类都可以与该方法进行适配的方式。这就是使用接口而不是类的强大之处。

【这个例子我需要好好消化一下，画个类图看看】



### 接口字段

**接口中的字段默认 public static final ，被存储在接口的静态存储区域中，这些字段不是接口的一部分。**



### 接口嵌套

接口可以嵌套在类或其他接口中，下面揭示一些有趣的特性：

```java
package com.aibook.onjava.ten;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description
 * @date 2020/2/11 10:47 下午
 */

class A {
    // 内嵌接口
    interface B {
        void f();
    }

    // 内部类
    public class BImp implements B {

        @Override
        public void f() {

        }
    }

    // 内部类2
    public class BImp2 implements B {
        @Override
        public void f() {

        }
    }

    // 内部接口2
    public interface C {
        void f();
    }

    // 内部接口实现类
    class CImp implements C {
        @Override
        public void f() {

        }
    }

    // 内部接口私有实现类2
    private class CImp2 implements C {
        @Override
        public void f() {

        }
    }

    // 私有内部接口D
    private interface D {
        void f();
    }

    // 私有内部接口的私有内部实现类
    private class DImp implements D {
        @Override
        public void f() {

        }
    }


    // 私有内部接口的 public 实现类
    public class DImp2 implements D {
        @Override
        public void f() {

        }
    }

    public D getD() {
        return new DImp2();
    }

    private D dRef;

    // 将传入的D 赋值给 ref 引用并调用f方法，目测是切换 DIMP2 和 DIMP1的对象实例
    public void receiveD(D d) {
        dRef = d;
        dRef.f();
    }
}

interface E {
    interface G {
        void f();
    }

    // Redundant "public"
    public interface H {
        void f();
    }

    void g();
    // Cannot be private within an interface
    //- private interface I {}
}


public class NestingInterfaces {
    // 继承A的嵌套接口
    public class BImp implements A.B {

        @Override
        public void f() {

        }
    }

    class CImp implements A.C {
        @Override
        public void f() {

        }
    }

    // Cannot implements a private interface except 私有接口无法嵌套 比如 A.D
    // within that interface's defining class:
    //- class DImp implements A.D {
    //- public void f() {}
    //- }

    class EImp implements E {
        @Override
        public void g() {
        }
    }


    class EGImp implements E.G {
        @Override
        public void f() {
        }
    }

    class EImp2 implements E {
        @Override
        public void g() {
        }

        // 嵌套类实现嵌套接口
        class EG implements E.G {
            @Override
            public void f() {
            }
        }

    }

    public static void main(String[] args) {
        A a = new A();
        // Can't access to A.D: 因为 D是私有类 所以 无法获取 A.D 对象
        //- A.D ad = a.getD();
        // Doesn't return anything but A.D:
        //- A.DImp2 di2 = a.getD();

        A a2 = new A();
        a2.receiveD(a.getD());
    }


}

```



这个有点复杂，嵌套的有点多。

在类中嵌套接口的语法很常见。就像非嵌套接口一样，它们具有 public 或包访问权限的可见性。
作为一种新添加的方式，**接口也是可以 private 的**，例如 A.D（同样的语法同时适用于接口和嵌套类）**那么 private 的嵌套接口有什么好处呢**？ 你可能猜测它只被用来实现一个 private 内部类，就像 DImp。 然而 A.DImp2 展示了它可以被实现为 public 类，但是 A.DImp2 只能被自己使用，你无法说它实现了 private 接口D 。
**所以实现 private 接口可以是一种可以强制该接口中的方法不会添加任何类型信息（即不可向上转型）的方式。**

【说实话，这段话我需要品一下。】

【说实话，我真没遇见过真实这么嵌套的，纯属给自己找不痛快，但是这个特性还是得知道】





### 接口和工厂方法模式

接口是多实现的途径，而生成符合某个接口的对象的典型方式是 **工厂方法** 设计模式。

不同于直接调用构造器，只需调用工厂对象的创建方法就能生成对象的实现——**理论上，通过这种方式可以将接口与实现的代码完全分离。**使得可以透明地将某个实现替换为另一个实现，增加灵活度。

##### 首先定义两个服务接口

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211235434.png)

##### 然后定义两个对应服务的工厂对象生产对应的服务对象

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200211235502.png)

##### 使用时根据工厂就可以生成对应的服务对象并调用具体的服务方法

![image-20200211235551806](/Users/xuyanxin/Desktop/typora-pics/image-20200211235551806.png)



如果没有工厂方法，代码就必须在某处指定要创建的 Service 的确切类型，从而调用具体的构造器。

为什么要添加额外的工厂间接层呢？

一个常见的原因是创建框架。需要灵活性与完全的解耦

在下一章，你狐疑看到更加优雅的使用匿名内部类的工厂实现方式。

### 本章小结

认为接口是好的选择，从而使用接口而不是用具体类，这具有诱惑性。**几乎任何时候，创建类都可以替代为创建一个接口和工厂。**

很多人掉进了整个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性，这变成了一种**过早的设计优化**，。

任何抽象性都应该是由真正的需求驱动的，当有必要时才使用接口进行重构，而不是到处添加额外间接层，带来额外的复杂性。

这种复杂性非常显著。

恰当的原则是优先使用类而不是接口吗，**从类开始，如果使用接口的必要性变得很明确，那么就重构。**

**接口shi一个伟大的工具，但是它们容易被滥用。**

