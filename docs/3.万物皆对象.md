---
layout: post
title: 《On Java8》第三章——万物皆对象
date: 2020-02-10 23:48:11
tags:
- 读书笔记
categories: 
- 《On Java8》

---

### 第三章 万物皆对象

> 如果我们说另外一种不同的语言，我们会发觉一个不同的世界！ 

<!-- more -->	

#### 数据存储

程序在运行时是如何存储的呢？尤其是内存如何分配。有5个不同的地方可以存储数据：

1. **寄存器（register)** 。最快的存储区域，位于cpu内部。然而寄存器的数据量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（C/C++ 允许开发者向编译器建议寄存器的分配）

2. **栈内存(Stack)** 。**位于常规内存 RAM**（随机访问存储 Random Access Memeory)区域中，**可通过栈指针获得处理器的直接支持**。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。**创建程序时，Java 系统必须准确地知道栈内保存的所有项目的生命周期。**这种约束限制了程序的灵活性。因此，虽然在**栈内存上存在**一些 Java 数据，特别是**对象引用**，但是 Java 对象保存在 堆内存中。

3. **堆内存（Heap）**。**这是一种通用的内存池（也在 RAM区域）**，**所有 Java 对象都存在于其中**。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具有灵活性。创建一个对象时，只需要用 new 命令实例化对象极客。当执行代码时，会自动在堆内存中进行内存分配。

   这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 堆内存分配机制现在已经非常快，因此这不是一个需要值得关心的问题了。

4. **常量存储（Constant Storage）。**常量值通常直接放在程序代码中，因为它们永远不会改变。如果需要严格保护，可考虑将它们存储于 只读存储器（ROM)中。

5. **非 RAM 存储。**数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。 两个主要的例子：

   1）序列化对象：对象被转化为字节流，通常被发往另一台机器；

   - 序列化：Java 提供了对象序列化的机制。一个对象可以被表示为一个字节序列，该字节序列包括了对象的数据，有关对象的类型信息和存储在对象中数据的类型。
   - 反序列化：读取被写入文件中的对象，对它进行反序列化，对象的类型，信息、对象的数据，还有对象的数据类型可以用在内存中新建对象。

   [java序列化，看这篇就够了](https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf)

   2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。

   **这些存储方式都是将对象转存于另一种介质中，并在需要时恢复成常规的，基于 RAM 的对象。**而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。