---
layout: post
title: 《On Java8》第十三章——函数式编程(1)
date: 2020-02-18 01:26:52
tags:
- 读书笔记
categories: 
- 《On Java8》
---

## 第十三章 函数式编程

> 函数式编程语言操纵代码片段就像操作数据一样容易。虽然 Java 不是函数式语言，但是 Java8 Lambda 表达式和 方法引用(Method Reference) 允许你以函数式编程

<!-- more -->	



##### 【Java8 的最主要特性之一，如果本书写的不够详细的话可以看《实战Java8》那本书，讲的非常细，例子也多】

##### 【关于函数式编程，我的理解是将行为传入方法中，让方法展示动态性】

> ##### OO（object oriented 面向对象）是抽象数据
>
> ##### FP（functional programming，函数式编程） 是抽象行为
>
> **纯粹的函数式语言在安全性上更强**，它们增加了强制的额外**约束**—**所有数据必须是不可变的**，**设置一次，永不改变**。将值传递给函数，该函数生成新的值，但是不修改自身外部的任何数据（包括其参数或该函数范围之外的元素）。
>
> 当强制执行此操作时，你就能知道错误在函数体内，因为**该函数仅创建并返回结果**，而不是其他任何错误。【**因为该函数不能修改外部变量**】
>
> **不可变对象**和**无副作用范式**解决了并发编程中最基本和最棘手的问题之一（**当程序的某些部分同时在多个处理器上运行时**）。
>
> 这是**可变共享状态**的问题。这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存（**谁赢了？没人知道**）。
>
> **纯函数语言：函数永远不会修改现有值，只生成新值，不会对内存产生争用。**
>
> ##### 因此，经常提出纯函数语言作为并行编程的解决方案。（同时还有其他可行的解决方案）
>
> 函数式语言的背后有很多动机，包括：
>
> - **为并行编程**【提高效率】
> - **增强代码可靠性**【增加健壮性】
> - **代码创建和库的复用** 【增加复用性】
>

> 关于**函数式编程能高效创建更健壮**的代码 **这一观点仍然存在争议。**虽然已有一些好的范例，但是还不足以证明纯函数语言就是解决编程问题的最佳方法。
>
> **FP 思想值得融入非 FP语言，比如 Python，以及Java 8中的特性。**

##### 【作者在前言中主要介绍了FP思想的简单定义，以及其优点和解决的痛点，同时作为 Java8 的主要特性，下面将会详细描述 函数式编程】

### 新旧对比

> 通常，方法根据入参不同，返回的结果不同。如果我们希望方法在调用时**行为**不同，该怎么做呢？
>
> 结论是：**只要能够将代码传递给方法，我们就可以控制方法的行为。**此前我们通过在方法中创建包含所需行为的对象，然后将该对象传递给我们想要控制的方法来完成此操作。
>
> 下面将分别展示 传统形式 和 Java 8的方法引用，Lambda 表达式来完成这个操作

```java
// functional/Strategy.java
interface Strategy {
    String approach(String msg);
}

class Soft implements Strategy {
    @Override
    public String approach(String msg) {
        return msg.toLowerCase() + "?";
    }
}

// 该类的方法签名与返回值与接口相同的方法，但是并没有实现接口，方法名称也不同
class Unrelated {
    static String twice(String msg) {
        return msg + " " + msg;
    }
}

public class Strategize {
    // 持有接口引用 用来指向其实现类
    Strategy strategy;
    String msg;

    // 初始化默认策略
    public Strategize(String msg) {
        strategy = new Soft(); // 默认策略是 Soft 对 Strategy 接口的是实现
        this.msg = msg;
    }

    // 打印 approach() 函数的输出
    void communicate() {
        System.out.println(strategy.approach(msg));
    }

    // 给策略引用重新赋值对象，实现策略的切换
    void changeStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public static void main(String[] args) {
        // 初始化一个元素是策略对象的数组，第一个元素是一个实现 Strategy 接口的匿名内部类
        // 第二个元素是 使用 Lambda 语法实现的匿名内部类
        // 第三个是 使用方法引用，将 Unrelated 类的 twice 方法引用赋值给 接口 因为 twice 方法的方法签名与返回值与 接口定义的 approach 方法相同
        Strategy[] strategies = {
                new Strategy() {
                    @Override
                    public String approach(String msg) {
                        return msg.toUpperCase();
                    }

                    @Override
                    public String toString() {
                        return "匿名对象策略";
                    }
                }, // 第一个元素: 实现了 Strategy 接口的匿名内部类
                msg -> msg.substring(0, 5), // 第二种 Lambda表达式,入参是 msg ，对入参的处理是截取 [0,5] 的一个子串
                // 第三种 方法引用，将 Unrelated 的方法引用 赋值给 Strategy 接口，只要方法的返回值与方法签名与接口中的抽象方法一直，就可以进行方法引用的赋值，实现行为的绑定
                Unrelated::twice,

        };

        Strategize s = new Strategize("Hello there");
        // 输出默认Strategy -> Soft 中的实现
        s.communicate();
        // 遍历策略数组，分别打印不同策略实现的 approach 方法
        for (Strategy newStrategy : strategies) {
            System.out.println("开始更改策略对象，当前策略对象" + newStrategy);
            s.changeStrategy(newStrategy);
            s.communicate();
        }
    }
}
```



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200217134604.png)



> Strategy 接口提供了单一行为 approach() 方法来承载函数式功能。**通过创建不同的 Strategy 对象我们可以创建不同的行为。**
>
> 最传统的实现方法：我们创建一个单独的类来实现接口的功能比如 **Soft类**。
>
> [1] 在 Strategize 中，Soft 作为默认策略，在构造函数中进行赋值。
>
> [2]一种略显简单且更自发的方法是 **匿名内部类** ，但是代码还是显得比较冗长
>
> [3] Java 8 的 Lambda 表达式 由 **箭头 “->”  分隔参数和函数体**，箭头**左边参数，右边是从 Lambda 返回的表达式**，即函数体。 这实**现了与定义类、匿名内部类相同的效果**，但代码少的多。
>
> [4] Java 8 的方法引用， 由 “::” 区分，在 **::  左边的是类或对象的名称**，**右边的是方法返回**，但是**没有参数列表。**
>
> [5] 在使用默认 Soft Strategy 之后，我们逐步遍历数组中的所有 `Strategy`，并使用 `cahngeStrategy()` 方法将 每个 Strategy 赋值给 s
>
> [6] 现在，每次调用 `communicate()` 都会产生不同的行为，具体取决于此刻正在使用的策略对象，**我们传递的是行为，并非仅是数据。**

### 个人小结：

- Lambda 和 方法引用是 对匿名内部类的**语法层面的优化**，打印对象的话你会发现本质在 **JVM 层生成的还是类**，**但是语言层面你可以认为这两种语法生成的都是方法，代表着一种动作**。
- 虽然这2个新特性可以写出更简化的代码，但是有利必有弊，如果你需要覆盖 Object 的类的方法（比如 toString() ）那么就无法使用这两种语法
- 这种语法的优化可以在 idea 中直接由编译器推荐优化，所以如果你习惯写 匿名内部类那也没啥，我觉得匿名内部类虽然看着冗长，但是可读性还是要比 lambda 和 方法引用要强，可能是因为自己没看习惯。

<img src="https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200219161508.png" style="zoom:50%;" />

<img src="https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200219161601.png" style="zoom:50%;" />

### Lambda表达式

> Lambda 表达式是使用 **最小可能** 语法编写的函数定义：
>
> 1. Lambda 表达式产生 **函数**，而不是类。**在 JVM 上，一切都是一个类**，因此在幕后执行各种操作使 Lambda 看起来像函数——但**作为程序员，你可以高兴地假装它们只是函数**。 【也就是将 Lambda 看作行为，一种动词】
> 2. Lambda 的语法尽可能的少，为了易于编写和使用，不用写冗长的内部类了。

##### [1]【这句话的意思是，Lambda的本质还是类，刚才截图也可以看到，其本质是个类。但是我们可以屏蔽掉其 JVM 层的实现，在语法层认为 Lambda 只是一个函数/方法，只代表行为。】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200217153217.png)

> 我们在 Strategy.java 中看到了一个 Lambda 表达式，但是还有其他**语法变体**：

```java
// LambdaExpressions.java
// 定义了3个接口，其中分别有 无参函数，一个参数的函数，两个参数的函数
// 分别对应不同的 Lambda 示例
interface Description {
    String brief();
}

interface Body {
    String detailed(String head);
}

interface Multi {
    String twoArg(String head, Double d);
}

public class LambdaExpressions {

    // 两个单参数的 Lambda 表达式，对应接口Body。 单个参数的表达式 入参可以括起来也可以不括
    static Body bod = h -> h + " No Parens!";
    static Body bod2 = (h) -> h + "More Details";

    // 无参 Lambda 表达式 对应接口 Description
    static Description desc = () -> "Short info";
    // 无参 Lambda 表达式，多行方法体的时候需要用花括号括起来
    static Description moreLines = () -> {
        System.out.println("More Lines");
        return "from MoreLines";
    };

    // 双参数接口 Lambda 表达式 对应接口 Multi
    static Multi multi = (h, n) -> h + n;


    public static void main(String[] args) {
        System.out.println(bod.detailed("Oh!"));
        System.out.println(bod2.detailed("Hi!"));
        System.out.println(desc.brief());
        System.out.println(multi.twoArg("Pi!", 3.1415926));
        System.out.println(moreLines.brief());
    }
}
```



> 从三个接口开始分析代码，**每个接口都一个单独的方法**（很快就会理解重要性），每个方法都有不同数量的参数，用来演示 Lambda 语法。
>
> 任何 **Lambda** 表达式的**基本语法**是：
>
> 1. 左边是入参
> 2. 接着 -> 可以看做是 产出
> 3. -> 之后的都是方法体
>    1. **当只用一个参数时，可以不需要括号 `()`** 。
>    2. 正常情况使用 括号() 包裹参数，**为了一致性，也可以包裹单个参数**，虽然这种情况并不常见
>    3. **如果没有参数，则必须使用括号 () 代表空参数列表**
>    4. **对于多个参数，将参数列表放在括号 () 中**

> 目前为止，所有 Lambda 表达式方法体都是单行。该**表达式的结果自动成为 Lambda 表达式的返回值**，**在此处使用 return 关键字是非法的**。这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。
>
> 如果需要多行，则需要使用 {将方法体括起来，同时使用 return 关键字。}
>
> Lambda 表达式通常比匿名内部类更容易阅读，下面的代码示例将尽可能使用这种形式

### 小结：

**本章介绍了Lambda 的基本语法，给了两个简单示例，可以看到 Lambda 的语法总体来说还是挺简单的。**



### 递归

> **递归函数是一个自我调用的函数**。可以编写**递归的 Lambda** 表达式，但是要注意，**递归方法必须是 `实例变量` 或 `静态变量`**。 否则会出现**编译时错误**。
>
> 下面的两个例子都需要接受一个 int 型入参并生成 int 的接口



```java
// functional/IntCall.java
interface IntCall {
  int call(int arg);
}


public class RecursiveFactorial {
    // 声明一个刚才创建的接口的引用
    static IntCall fact;

    public static void main(String[] args) {
        // Lambda 中嵌套了递归
        fact = n -> n == 0 ? 1 : n * fact.call(n - 1);
        
        for (int i = 0; i < 10; i++) {
            System.out.println(fact.call(i));
        }
    }
}
// 输出

1
1
2
6
24
120
720
5040
40320
362880

```



> 这里 fact 是一个静态变量。注意三元操作符，递归函数将一直调用自己，直到i == 0。 
>
> **所有递归函数都必须存在终止条件，否则将成为无限递归。**
>
> 我们可以将 **斐波那契数**列 改为使用 递归 Lambda 表达式来实现，这次使用实例变量演示：

```java
// RecursiveFibonacci.java
public class RecursiveFibonacci {
    // 入参是int,出参也是int的函数式接口。
    IntCall fib;

    // 类的构造函数，使用 Lambda 表达式实现 IntCall 的call()函数
    public RecursiveFibonacci() {
     /*   fib = n -> n == 0 ? 0 :
                n == 1 ? 1 :
                        fib.call(n - 1) + fib.call(n - 2);*/

        // if - else 版 斐波那契数列生成函数
        fib = n -> {
            if (n == 0) {
                return 0;
            } else if (n == 1) {
                return 1;
            } else {
                return fib.call(n - 1) + fib.call(n - 2);
            }
        };

    }

    // 调用生成斐波那契数列的函数 ，这层封装只是为了更强的语义性，直接调用 fib.call 也是一样的效果
    int generatorFibonacci(int n) {
        return fib.call(n);
    }

    public static void main(String[] args) {
        RecursiveFibonacci rf = new RecursiveFibonacci();
        for (int i = 0; i <= 10; i++) {
            System.out.println(rf.generatorFibonacci(i));
            //System.out.println(rf.fib.call(i)); // 效果和 rf.generatorFibonacci(i) 一样
        }
    }
}



/**
输出
0
1
1
2
3
5
8
13
21
34
55
*/
```

> 这里 使用 Lambda 实现的递归函数将一直调用自己，直到 i == 0。
>
> **所以递归函数都有结束条件，否则会形成无限递归的死循环。**

### 小结：

本章使用算是 Lambda 的更具体的使用场景，实现了一个 Lambda 版本的 斐波那契数列算法的函数。

- 递归的基本知识
  - 递归需要有结束条件
  - Lambda 递归必须使用实例变量或者 静态变量



### 方法引用

> Java 8 中的方法引用没有**历史包袱。** 方法引用组成：**类名或对象名，后面跟 [::] 然后跟 方法名称。**

```java
// MethodReferences.java
// 一个方法引用的简单说明例子
interface Callable { // [1] 函数式接口，入参 String，没有返回值
    void call(String s);
}

class Describe {
    void show(String msg) { // [2]
        System.out.println(msg);
    }
}

public class MethodReferences {
    static void hello(String name) { // [3]
        System.out.println("Hello, " + name);
    }

    // 静态内部类/嵌套类 1
    static class Description {
        String about;

        public Description(String about) {
            this.about = about;
        }

        void help(String msg) { //[4]
            System.out.println(about + " " + msg);
        }
    }

    // 静态内部类/嵌套类 2
    static class Helper {
        static void assist(String msg) { // [5]
            System.out.println(msg);
        }
    }

    public static void main(String[] args) {
        Describe d = new Describe();

        //方法引用语法
        // Describe 的 show() 方法与 Callable 接口的 call() 方法的 方法签名与返回值都一致
        // 这里赋值是先构造的 Describe 对象，然后使用实例::方法名 的形式将方法引用赋值给 Callable 接口
        Callable c = d::show; //[6]
        c.call("call"); // [7]  所以这里 Callable 引用 c  调用的 call() 实际调用的是 Describe De show()

        // 同上， MethodReferences 的 hello() 方法与 Call(）方法也一致
        // 这里静态方法的引用赋值就不需要构造方法所在对象的实例，可以直接 类名::方法名 进行赋值
        c = MethodReferences::hello; //[8]
        c.call("Bob");

        // 这里是将静态内部类 Descripetion 的 非静态方法 hel() 的引用 赋值给 Callable 是[6] 赋值的一步完成版本，构造类实例—方法引用赋值
        c = new Description("valueable")::help; // [9]
        c.call("information");

        c = Helper::assist; // [10]  静态方法的引用赋值不需要实例对象
        c.call("Help!");
    }
}
```

**【第一遍真没太弄明白，又看了两编大概懂了，直接看原书的讲解吧】**

> [1] **从单一方法接口开始**【这种接口被称为函数式接口】
>
> [2] `show()` 签名 (**参数类型和返回类型**) 符合 Callable 的 `call()` 签名。

**【方法引用的赋值是根据方法的返回值与方法签名是否与函数式接口中的方法一致，如果一致就可以进行方法赋值】**

> [3] `hello()` 也符合 `call()` 签名。
>
> [4] help() 也符合，它是**静态内部类**中的**非静态方法**
>
> [5] assist() 是**静态内部类**中的 **静态方法。**
>
> [6] 我们将 Describe 对象的方法因复制给 Callable，这个接口它没有 show() 方法，而是 call() 方法，**然而Java 接受了这个奇怪的赋值**，因为**Describe的 show(String msg )方法引用符合 Callable 的 call(String s) 方法的签名。**

**【奇怪的赋值 这个描述挺贴切，这玩意看的我一脸懵逼，按方法引用这个说法，只要是单函数接口且方法签名与返回类型一致，就可以这么玩？】**

> [7] 我们可以通过调用 call() 来调用 show() ，因为 Java 将 call() 映射到 show() 。 

##### 【这个真的很神奇，代码运行出来的时候看到这我就懵了】

> [8] 这是一个 **静态**方法引用。**【可以看到静态方法引用的赋值不需要构造类的实例对象】**
>
> [9] 这是6的另一个版本：对**已经实例化对象的方法的引用**，有时称为：**绑定方法引用。**
>
> [10] 最后，获取静态内部类的方法引用的操作与 [8] 中外部类的方式一致。
>
> 上面例子是简短介绍，很快就能看到方法引用的全部变化。

### 个人小结：

**【方法签名引用的赋值只要目标方法与函数式接口中的方法返回值与签名一致就可以进行赋值，非常的方便。**

**不需要实现接口，也不需要方法名称与接口中的一致，这样就可以更好的对方法进行命名。】**

### Runnable接口

>  Runnable 接口自 1.0 版本一直在 Java中，因此不需要导入。
>
>   它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。
>
>  因此，**我们可以使用 Lambda 表达式和 方法引用来实现 Runnable：**

**【方法引用和Runnable接口的结合使用】**

```java
// RunnableMethodReference.java
// 一个使用匿名内部了/Lambda/方法引用 三种形式 生成实现 Runnable 实例的例子
class Go {
    static void go() {
        System.out.println("Method Reference 实现接口");
    }
}

public class RunnableMethodReference {
    public static void main(String[] args) {

        // 匿名内部类实现 Runnable 接口
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("匿名内部类");
            }
        }).start();

        // Lambda
        new Thread(
                () -> System.out.println("Lambda 实现 Runnable")
        ).start();

        // Method Reference
        new Thread(Go::go).start();
    }
}
```

**【如果实现了一个以上方法的匿名内部类，比如我重写了 toString() ，那么就无法使用 Lambda 或者方法引用】**

**【本来有点懵逼，现在明白多了，实际上就是三种不同的语法，但是底层JVM生成的类是一致的，简化了书写而已。】**

### 未绑定的方法引用

> 未绑定的方法引用：指**没有关联对象的普通方法**，也就是**非静态方法**。
>
> **使用未绑定引用之前，必须先有对象才能调用。**
>
> **也就是如果想怼非静态方法实现方法引用的绑定必须先构造对应类的实例。**

##### 

```java
// UnboundMethodReference.java
class X {
    String f() {
        return "X::f()";
    }
}

interface MakeString {
    String make();
}

interface TransformX {
    // 这里方法的参数是一个 X 类型的对象，后面就可以看到这个入参的作用。
    String transform(X x);
}

public class UnboundMethodReference {
    public static void main(String[] args) {
       // MakeString ms = X::f; // 编译器报错，该方法不是静态方法，不能直接使用 类名::方法进行绑定
        MakeString ms = new X()::f; // 针对上面代码的修改。非静态方法引用的绑定，先构造对象，然后将方法引用赋值给接口

        // 这里的方法引用赋值如果是第一次的话会很懵逼
        // 方法签名既不一致，而且 f() 也不是静态方法，为什么可以使用 类::方法的形式
        // 这里因为接口的方法的第一个参数是对应类，所以就存在了一个隐式 this 的赋值过程，方法绑定的时候会将对象赋值给第一个指定对象的类型参数，实现与构造对象相同的效果
        TransformX sp = X::f;

        X x = new X();
        // 这三个语句效果一样，都是调用 X 类的 f() 函数
        System.out.println(sp.transform(x));
        System.out.println(x.f()); 
        System.out.println(ms.make()); 
    }
}

```

##### 【**写完这个代码我又迷茫了... 这方法签名不一样咋还用上方法引用了呢，而且看报错信息，这里面说非静态方法不能从静态上下文中被引用，除了 main() 是静态的，其他都不存在静态，那么问题就出在 main() 方法里了。**

**还是先看看书上怎么说把**：】

> 目前我们已经明白了与接口方法签名一致的方法引用的赋值，在[1]中，会尝试将 X 的 f() 方法，赋值给 MakeingString ，虽然这俩方法签名一致，但是编译器仍然告诉你 invalid method reference（无效的方法引用）
>
> 因为这里还有一个隐藏参数 **this**。 **你不能在没有 X 对象的前提下调用 f()** ，因此 X::f  表示未绑定的方法的引用，因为它尚未绑定到对象。
>
> **要解决这个问题，我们需要一个 X 对象**，所以我们的**接口实际上需要一个额外的** **参数的接口**，如上例中的 TransformX。 如果将 X::f 赋值给 TransfromX，这在 Java中是允许的。
>
>  **使用未绑定的引用时，函数方法的签名（接口中的单方法）不再与方法引用的签名完全匹配**。理由是：你需要一个对象来调用方法。
>
> [2] 的结果有点像脑筋急转弯【确实】，我接受未绑定的引用并对其调用 `transform()` ，将其传递给 X，并以某种方式导致对 x.f() 的调用。
>
> **Java 知道它必须采用第一个参数，实际上就是 this，并在其上调用方法。**

**【总结：如果是非静态方法，实现类名::方法名这种绑定形式的话，需要接口中第一个参数为对应类的类型参数方便，作为隐式 this 的赋值，因为非静态方法必须有一个对象来调用】**

```java
// 未绑定方法与多参数接口的结合
// MultiUnbound.java 这里我把接口 和 This类的顺序调换了一下，我感觉更好理解
// 这里接口的第一个入参都是 This 类型，因为未绑定方法的引用赋值需要隐式this来调用

// 这三个接口的第一个参数都是 类 This，用处是 类This将非静态方法绑定到接口的时候不需要构造对象。
interface TwoArgs {
    void call2(This athisRef, int i, double d);
}

interface ThreeArgs {
    void call3(This athis, int i, double d, String s);
}

interface FourArgs {
    void call4(
            This athis, int i, double d, String s, char c);
}

// 分别对应接口的 2，3，4 入参的函数

class This {
    void two(int i, double d) {

    }

    void three(int i, double d, String s) {

    }

    void four(int i, double d, String s, char c) {

    }
}


public class MultiUnbound {
    public static void main(String[] args) {
        // 方法绑定 这里可以看到 非静态方法直接使用 类名::方法名进行了绑定
        TwoArgs twoArgs = This::two;
        ThreeArgs threeArgs = This::three;
        FourArgs fourArgs = This::four;
        // 真正调用之前还是需要构造对应类的实例，将该实例传入接口中，实现对象的赋值，然后调用刚才绑定的方法
        This aThis = new This();
        twoArgs.call2(aThis, 11, 3.14);
        threeArgs.call3(aThis, 11, 3.14, "Three");
        fourArgs.call4(aThis, 11, 3.14, "Four", 'Z');
    }
}

```

### 总结：

这一部分讲的都是Lambda 和 方法引用的基础知识，但是也很重要，如果看着不习惯的话，就多敲几遍例子也就理解了。	