---
layout: post
title: 《On Java8》第二十一章——数组(1)
date: 2020-03-10 00:22:03
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### 数组特性

数组：线性表数据结构。通过下表对元素进行访问，数组的大小不可变。

> 随着 Java CollectionFramework 和 Stream 类中高级功能不断增加，使用数组的需求不断变少，学习数组主要是为了阅读别人写的数组代码。
>
> <!-- more -->	

我的目标：对数组有一个更深刻的认识。

大方向：快速的过一遍，吸收以前没有注意到的知识，不要浪费太多时间。

GO。

> 数组与其他类型集合的主要区别：效率、类型、保存基本数据类型的能力。数组是简单的线性序列，对元素的访问非常快，代价是数组的大小固定，且在数组的生存期内无法更改。

数组想要扩容就需要拷贝，在我的认知中这个操作比较慢以及消耗资源。

你应该总是使用 **ArrayList**，大多数情况下，不需要区分数组和列表的**性能**区别。而列表比数组要灵活太多，列表可以自动扩容，创建新数组并将旧数组中的引用移动到新数组。

数组和集合使用不当都会抛出运行时异常，比如当你访问到一个越界的索引时。但是数组比原生的集合类型要好，因为数组指明了保存的元素类型，编译器会进行检查，而不带泛型的原始集合类型无法做到。并且数组可以保存基础类型，而集合保存的是基础类型的包装类，涉及到自动装箱机制。

> 下面是一个比较数组和泛型集合的例子：



```java
// arrays/CollectionComparison.java
class BerylliumSphere {
    private static long counter;
    private final long id = counter++;


    @Override
    public String toString() {
        return "Sphere " + id;
    }
}

public class CollectionComparison {
    public static void main(String[] args) {
        BerylliumSphere[] spheres = new BerylliumSphere[10];

        for (int i = 0; i < 5; i++) {
            spheres[i] = new BerylliumSphere();
        }
        // Arrays.toString
        show(spheres);
        System.out.println(spheres[4]);
        System.out.println("----- List ----");
        ArrayList<BerylliumSphere> sphersList = Suppliers.create(ArrayList::new, BerylliumSphere::new, 5);
        System.out.println(sphersList);
        System.out.println(sphersList.get(4));

        int[] integers = {0, 1, 2, 3, 4, 5};
        show(integers);
        System.out.println(integers[4]);

        System.out.println("--- Int List ---");
        ArrayList<Integer> intList = new ArrayList<>(Arrays.asList(0, 1, 2, 3, 4, 5));
        intList.add(97);
        System.out.println(intList);
        System.out.println(intList.get(4));
    }
}

```

> Suppliers 是泛型中创建的类。

【还有一个工具类 `ArrayShow` 在下面定义】

> 数组与集合的操作方式非常**相似**，这是**有意为之**，在概念上，两者非常容易切换。
>
> 集合的功能明显多于数组，首选使用集合。除非是涉及到比较底层的优化。



### 用于显示数组的实用程序

```java
// ArrayShow.java
public interface ArrayShow {
  static void show(Object[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(boolean[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(byte[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(char[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(short[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(int[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(long[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(float[] a) {
    System.out.println(Arrays.toString(a));
  }
  static void show(double[] a) {
    System.out.println(Arrays.toString(a));
  }
  // Start with a description:
  static void show(String info, Object[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, boolean[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, byte[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, char[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, short[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, int[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, long[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, float[] a) {
    System.out.print(info + ": ");
    show(a);
  }
  static void show(String info, double[] a) {
    System.out.print(info + ": ");
    show(a);
  }
}


```

> 第一个方法用于对象数组，方法重载为了打印不同的数据类型的数组
>
> 第二个方法可以打印带有信息字符串**前缀**的数组。



### 一等对象

> **数组中的是堆上真正对象的引用。数组中保存的是对象的索引。**
>
> 数组可以隐式的创建，也可以显示地创建。 比如使用一个 new 表达式。
>
> [] 是访问数组对象的唯一方式。
>
> 下面例子总结了数组初始化的多种方式，并且展示了如何给不同数组对象分配数组引用。
>
> 也可以看到**存储对象的数组和存储基础数据的数组完全一样**，唯一不同的是 对象数组存储的是对象的引用，而基本数据类型数组存储的是基本数据类型的值：

```java
// arrays/ArrayOptions.java
public class ArrayOptions {
    public static void main(String[] args) {
        // 对象数组
        BerylliumSphere[] a; // 未被初始化
        BerylliumSphere[] b = new BerylliumSphere[5]; // 开辟了长度为5个对象内存空间的数组
        show("b", b);

        // 隐式创建的数组，元素默认为 null
        BerylliumSphere[] c = new BerylliumSphere[4];
        for (int i = 0; i < c.length; i++) {
            // 将 c 中的元素初始化
            if (c[i] == null) {
                c[i] = new BerylliumSphere();
            }
        }
        // 显示创建的数组
        BerylliumSphere[] d = {
                new BerylliumSphere(),
                new BerylliumSphere(),
                new BerylliumSphere()
        };

        // 动态聚合初始化
        a = new BerylliumSphere[]{new BerylliumSphere(), new BerylliumSphere()};

        System.out.println("a.length = " + a.length);
        System.out.println("b.length = " + b.length);
        System.out.println("c.length = " + c.length);
        System.out.println("d.length = " + d.length);
        a = d;
        System.out.println("a.length= " + a.length);

        // 基本类型的数组
        int[] e; // 空引用，尚未初始化的数组
        int[] f = new int[5];
        show("f",f);

        int[] g = new int[4];

        for (int i = 0; i < g.length; i++) {
            g[i] = i * i;
        }
        int[] h = {11, 47, 93};
        System.out.println("f.length = " + f.length);
        System.out.println("g.length = " + g.length);
        System.out.println("h.length = " + h.length);
        e = h;
        System.out.println("e.length = " + e.length);
        e = new int[]{ 1, 2 };
        System.out.println("e.length = " + e.length);
    }
}
/**
输出
b: [null, null, null, null, null]
a.length = 2
b.length = 5
c.length = 4
d.length = 3
a.length= 3
f: [0, 0, 0, 0, 0]
f.length = 5
g.length = 4
h.length = 3
e.length = 3
e.length = 2

*/
```

**【都是数组比较基本的操作。】**

> 数组 b 被初始化成一系列指向 **BerylliumSphere** 对象的引用，但是并没有真正的元素存储在数组中，但是你仍然可以获取数组的大小。
>
> **数组的 length 只是告诉你数组的存储能力，而不是真正存储在数组中对象的个数。**
>
> 创建数组时，会将其中对象初始化为 null，基本数据类型初始化为 0 , false 以及其他对应的默认值，可以使用检测值来判断 数组中是否有对象。
>
> `c` 展示了 创建数组对象后给数组中各元素分配 **BerylliumSphere** 对象的过程。
>
> `d` 展示了 创建数组对象的聚合初始化语法（隐式地使用 new 在堆中创建对象）并且初始化成 **BeryliumSphere** 。

```java
  a = new BerylliumSphere[]{
      new BerylliumSphere(), new BerylliumSphere(),
    };
```

> 这种初始化的方式可以被看做：**动态聚合初始化**
>
> 比如一个方法的 hide() 的入参是 `BerylliumSphere[]` 
>
> 那么你可以这样调用它 `hide(d)` （d 是之前使用聚合初始化创建的数组），也可以动态地创建用作参数传递的数组：

```java
hide(new BeruylliumSphere[]{
	  new BerlliumSphere(),
    new BerlliumSphere()
});
```



> 相当于在参数中直接初始化了数组【我没见过这么写的】，但是作者认为很多情况下这种语法写代码更加方便。

【算是长见识系列吧，并没有很复杂的东西】

### 返回数组

> 在 C++ 中没法返回数组，只能返回一个 指向数组的指针。会导致对数组生存期的控制变得混乱，可能引起**内存泄漏**。
>
> 在 Java 中可以随意返回数组，垃圾收集器会在使用完之后自动清理干净。

> 下面返回一个字符串数组：

```java
// arrays/IceCreamFlavors.java
public class IceCreamFlavors {
    private static SplittableRandom rand = new SplittableRandom(47);
    static final String[] FLAVORS = {"巧克力", "草莓", "摩卡", "Rum Raisin", "Praline Cream", "Mud Pie"};

    // 返回i个随机挑选的冰淇淋口味
    public static String[] flavorSet(int n) {
        System.out.println("本次挑选 " + n + "种口味的冰淇淋");
        if (n > FLAVORS.length) {
            throw new IllegalArgumentException("索引超出口味数组的限制！");
        }
        // 用来保存挑选的口味
        String[] result = new String[n];
        // 用来查看口味是否被选中
        boolean[] picked = new boolean[FLAVORS.length];

        for (int i = 0; i < n; i++) {
            int t;
            do {
                t = rand.nextInt(FLAVORS.length);
                System.out.println("本次随机挑选的冰淇淋口味的索引是: " + t);
            } while (picked[t]);
            // 给 result 中的元素进行赋值
            result[i] = FLAVORS[t];
            picked[t] = true;
        }
        return result;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 7; i++) {
            ArrayShow.show(flavorSet(3));
        }
    }
}
/**
输出
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 3
本次随机挑选的冰淇淋口味的索引是: 5
本次随机挑选的冰淇淋口味的索引是: 3
本次随机挑选的冰淇淋口味的索引是: 4
[Rum Raisin, Mud Pie, Praline Cream]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 5
本次随机挑选的冰淇淋口味的索引是: 1
本次随机挑选的冰淇淋口味的索引是: 2
[Mud Pie, 草莓, 摩卡]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 2
本次随机挑选的冰淇淋口味的索引是: 2
本次随机挑选的冰淇淋口味的索引是: 1
本次随机挑选的冰淇淋口味的索引是: 4
[摩卡, 草莓, Praline Cream]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 3
本次随机挑选的冰淇淋口味的索引是: 2
本次随机挑选的冰淇淋口味的索引是: 1
[Rum Raisin, 摩卡, 草莓]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 0
本次随机挑选的冰淇淋口味的索引是: 0
本次随机挑选的冰淇淋口味的索引是: 0
本次随机挑选的冰淇淋口味的索引是: 2
本次随机挑选的冰淇淋口味的索引是: 3
[巧克力, 摩卡, Rum Raisin]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 1
本次随机挑选的冰淇淋口味的索引是: 0
本次随机挑选的冰淇淋口味的索引是: 2
[草莓, 巧克力, 摩卡]
本次挑选 3种口味的冰淇淋
本次随机挑选的冰淇淋口味的索引是: 1
本次随机挑选的冰淇淋口味的索引是: 0
本次随机挑选的冰淇淋口味的索引是: 5
[草莓, 巧克力, Mud Pie]
*/
```

> 这里 `flavors()` 返回的数组实际上返回的是**引用**。数组是在 `flavorSet()` 中或者其他什么地方创建的都不重要。
>
>  垃圾收集器会清理你用完的数组，需要的则会被保留。
>
> 如果要返回一系列不同类型的元素，可以使用 [泛型](https://lingcoder.github.io/OnJava8/#/book/20-Generics) 中介绍的**元组**。
>
> 当 `falvorSet()` 随机选择 `FLAVORS` 数组中的元素时，它确保了元素不会重复，这在一个 `do-while` 循环中执行。它将一直做出随机选择直到它发现一个元素不在 `picked` 数组中（一个字符串比较将显示出随机选中的元素是否已经存在 result 中）。如果添加成功，它将添加条目并且寻找下一个 （i 递增）。
>
> 输出结果显示 flavorSet() 每一次都按照**随机顺序**选择fFlavors。
>
> 这里使用了 `Java 8` 中新增的 `SplittableRandom`，这个随机数类可以在并行操作使用，而且提供了高质量的随机数，替代了 `java.util.Random`.

### 