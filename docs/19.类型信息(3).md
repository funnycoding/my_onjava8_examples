---
layout: post
title: 《On Java8》第十九章——RTTI(3)
date: 2020-02-28
tags:
- 读书笔记
categories: 
- 《On Java8》

---




### 注册工厂

> 从 Pet 层次结果生成对象的问题是，每当向层次结构中添加一种新的 Pet 时，必须记住将其添加到 LiteralPetCreator.java 的 ALL_TYPE中。 如果硬编码，并且修改了原有代码。
>
> **【也就是每次要添加新类型，就需要手动修改ALL_TYPE代码中的类型，违反了开闭原则。】**
>
> <!-- more -->	
>
> 在一个定期添加更多类的系统中，这可能会成为问题。
>
> 你可能会考虑向每个子类添加静态初始值设定项，因此初始值设定项会将其添加到某个列表中。不幸的是，静态初始值设定项仅在首次加载类时调用，因此存在 鸡和蛋的问题：生成器的列表中没有类，因此它无法创建该类的对象，因此类不会被加载并放入列表。
>
> 基本上，你必须自己**手工创建列表**（除非你编写了一个工具来搜索和分析源代码，然后创建和编译列表）。
>
> 所以你能做的最好的事情就是把**列表集中放在一个明显的地方**。**类层次结构的基类**可能是最好的地方。
>
> 我们这里所做的类另外一个改动是使用 工厂方法 设计模式 将对象的创建推迟到了类本身。工厂方法可以以多态的方式调用，并为你创建适当类型的对象。
>
> 事实证明，`java.util.function.Supplier` 用 `T get()` 描述了**原型工厂方法**。协变返回类型允许 `get()` 为 `Suplier` 的每个子类实现返回不同的类型。
>
> 在本例中，基类 Part 包含了一个工厂对象的静态列表，列表成员类型为 `Supplier<Part>`。对于应该由 get() 方法生成的 类型的工厂，通过将它们添加到 prototypes 列表向基类"注册"。奇怪的是，这些工厂本身就是对象的实例。
>
> 此列表中的每个对象都是用于创建其他对象的**原型：**



```java
// RegisteredFactories.java
class Part implements Supplier<Part> {

    @Override
    public String toString() {
        return getClass().getSimpleName();
    }
    static List<Supplier<? extends Part>> prototypes =
            Arrays.asList(
                    new FuelFilter(),
                    new AirFilter(),
                    new CabinAirFilter(),
                    new OilFilter(),
                    new FanBelt(),
                    new PowerSteeringBelt(),
                    new GeneratorBelt()
            );

    private static Random rand = new Random(47);
    public Part get() {
        int n = rand.nextInt(prototypes.size());
        return prototypes.get(n).get();
    }
}

class Filter extends Part {}


class FuelFilter extends Filter {
    @Override
    public FuelFilter get() {
        return new FuelFilter();
    }
}


class AirFilter extends Filter {
    @Override
    public AirFilter get() {
        return new AirFilter();
    }
}


class CabinAirFilter extends Filter {
    @Override
    public CabinAirFilter get() {
        return new CabinAirFilter();
    }
}

class OilFilter extends Filter {
    @Override
    public OilFilter get() {
        return new OilFilter();
    }
}

class Belt extends Part {}


class FanBelt extends Belt {
    @Override
    public FanBelt get() {
        return new FanBelt();
    }
}

class GeneratorBelt extends Belt {
    @Override
    public GeneratorBelt get() {
        return new GeneratorBelt();
    }
}

class PowerSteeringBelt extends Belt {
    @Override
    public PowerSteeringBelt get() {
        return new PowerSteeringBelt();
    }
}




public class RegisteredFactories {
    public static void main(String[] args) {
        Stream.generate(new Part())
                .limit(10)
                .forEach(System.out::println);
    }
}

/**
输出
GeneratorBelt
CabinAirFilter
GeneratorBelt
AirFilter
PowerSteeringBelt
CabinAirFilter
FuelFilter
PowerSteeringBelt
PowerSteeringBelt
FuelFilter
*/
```

> 并非层次结构中的所有类都应实例化，这里 `Filter` 和 `Belt` 只是**分类器**，并**不**需要创建这2个类的实例，而是**只创建它们的子类**（如果创建了这2个类，则获得 Part 基类的行为）。
>
> 因为 `Part implements` `Supplier<Part>`，`Part` 通过 `get()` 方法供应其他 `Part`。 如果为基类 `Part` 调用 `get()` （或者如果 `generate()` 调用 `get()`），它将创建随机特定的 `Part` 子类型，每个子类型最终都从 `Part` 继承，并重写 `get()` 方法返回它们自己的类型。

### 类的等价比较

> 当你查询类型信息时，需要注意： 使用 `instanceof`或者 `isInstance()` 和 与 `Class` 对象**直接比较**存在重要区别：

```java
//  typeinfo/FamilyVsExactType.java
// instanceof 与 class 的差别
class Base {
}

class Derived extends Base {
}


public class FamilyVsExactType {
    static void test(Object x) {
        System.out.println("Testing x of type " + x.getClass());
        System.out.println("x instance of Base: " + (x instanceof Base));
        System.out.println("x instanceof Derived: " + (x instanceof  Derived));
        System.out.println("Base.isInstance(x): " + Base.class.isInstance(x));
        System.out.println("Derived.isInstance(x): " + Derived.class.isInstance(x));
        System.out.println("x.getClass() == Base.class: " + (x.getClass() == Base.class));
        System.out.println("x.getClass() == Derived.class: " + (x.getClass() == Derived.class));
        System.out.println("x.getClass.equals(Base.class): " + x.getClass().equals(Base.class));
        System.out.println("x.getClass.equals(Derived.class): " + x.getClass().equals(Derived.class));
    }

    public static void main(String[] args) {
        System.out.println("test Base");
        test(new Base());
        System.out.println("--------------");

        System.out.println("test Derived");
        test(new Derived());
    }
}
/**
输出
test Base
Testing x of type class typeinfo.Base
x instance of Base: true
x instanceof Derived: false
Base.isInstance(x): true
Derived.isInstance(x): false
x.getClass() == Base.class: true
x.getClass() == Derived.class: false
x.getClass.equals(Base.class): true
x.getClass.equals(Derived.class): false
--------------
test Derived
Testing x of type class typeinfo.Derived
x instance of Base: true
x instanceof Derived: true
Base.isInstance(x): true
Derived.isInstance(x): true
x.getClass() == Base.class: false
x.getClass() == Derived.class: true
x.getClass.equals(Base.class): false
x.getClass.equals(Derived.class): true

*/

```

> `test()` 方法使用两种形式的 `instanceof` 对其参数进行类型检查。 然后获取 `Class` 引用并使用 `==` 和 `equals()` 测试 `Class` 对象的相等性。
>
> `instanceof` 和 `isInstance()` 产生的结果相等， ==  和 equals() 产生的结果也相同。
>
> 测试本身得出了不同结论，与类型的概念一致。`instnaceof` 说你是这个类还是这个类的子类。 而使用 `==` 和 `equals()` 则是与具体的类型比较，与继承层级无关。



### 反射：运行时类信息

> **RTTI 可以获取对象的确切类型信息**，但是有一个**限制**：必须在**编译时**知道类型。 这就**限制了要使用 RTTI 则编译器必须知道你使用的所有类。**
>
> 假设当你引用了目前**不在程序空间中的对象**，该对象的类在编译时对程序都不可用，比如从**磁盘文件**或者**网络连接**中获得了大量的字节并被告知这些字节代表一个类。
>
> **反射解决了如何使用这种类的情形：**
>
> 具体使用场景：比如处理GUI组件的编写，反射提供了检测可用方法并生成方法名称的机制 或者  远程方法调用 RMI，反射将网络连接接收到的字节转换为类。
>
> 类 `Class` 支持了反射的概念。 `java.lang.reflect` 库中包含类 `Field`、`Method` 和 `Constructor`（每一个都实现了 `Member` 接口）。 这些类型的对象**由 JVM 在运行时创建**，以表示未知类中的对应成员。
>
> 使用 `Constructor` 创建新对象，`get()` 和 `set()` 方法读取和修改与 `Field` 对象关联的字段， `invoke()` 方法调用与 Method 对象关联的方法。
>
> 还可以使用便利方法： `getFields()` 、 `getMethods()`、`getConstructors()` 等以返回表示 字段、方法和构造函数的对象数组。
>
> 因此，**匿名对象的类信息**可以在**运行时完全确定**，**编译时不需要知道任何信息。**
>
> 反射没有魔力。当你使用反射与位置类型对象交互时，`JVM` 将查看该对象，并看到它属于特定的类（就像普通的 **RTTI**）。
>
> 在对其执行任何操作之前，必须**加载** `Class` 对象。因此，该特定类型的 `.class` 文件必须在本地计算机上或通过网络对 JVM 仍然可用。
>
> 换句话说，你可以用"正常"的方式调用一个对象的所有方法。
>
> 通过**反射** .`class` 文件在**编译时不可用**；它由**运行时环境打开并检查**。

**【总结，反射是为了使用编译时不存在的对象，随着网络编程的越来越普遍，反射用的也越来越多。】**

#### 类的方法提取

> 一般程序员平时不会与反射打太多交道。但是反射可以帮助你创建更多的动态代码。所以那些类库中有许多反射的应用。
>
> 反射是用来支持 Java 其他特性的，例如对象序列化（参见[附录：对象序列化](https://lingcoder.github.io/OnJava8/#/book/Appendix-Object-Serialization)）。但是有时动态提取有关类的信息很有用。
>
> 比如类方法提取器，既可以找到指定类中定义或重写的方法，也可以找到其继承的基类的方法，反射提供了这种编写简单工具就能实现找到类所有方法的功能：

```java
// typeinfo/ShowMethods.java
public class ShowMethods {
    private static String usage =
            "usage:\n" +
                    "ShowMethods qualified.class.name\n" +
                    "To show all methods in class or :\n" +
                    "ShowMethods qualified.class.name word\n" +
                    "To search for methods involving 'word'";

    private static Pattern p = Pattern.compile("\\w+\\.");


    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println(usage);
            System.exit(0);
        }
        int lines = 0;

        try {
            Class<?> c = Class.forName(args[0]);
            Method[] methods = c.getMethods();
            Constructor<?>[] ctors = c.getConstructors();

            if (args.length == 1) {
                for (Method method : methods) {
                    System.out.println(p.matcher(method.toString())
                            .replaceAll(""));
                }
                for (Constructor ctor : ctors) {
                    System.out.println(p.matcher(ctor.toString())
                            .replaceAll(""));
                }
                lines = methods.length + ctors.length;
            } else {
                for (Method method : methods) {
                    if (method.toString().contains(args[1])) {
                        System.out.println(p.matcher(method.toString()).replaceAll(""));
                        lines++;
                    }
                }

                for (Constructor ctor : ctors) {
                    if (ctor.toString().contains(args[1])) {
                        System.out.println(p.matcher(ctor.toString()).replaceAll(""));
                        lines++;
                    }
                }
            }
        } catch (ClassNotFoundException e) {
            System.out.println("No such class: " + e);
        }
    }
}

/**
public static void main(String[])
public final void wait() throws InterruptedException
public final void wait(long,int) throws
InterruptedException
public final native void wait(long) throws
InterruptedException
public boolean equals(Object)
public String toString()
public native int hashCode()
public final native Class getClass()
public final native void notify()
public final native void notifyAll()
public ShowMethods()
*/


```

### 个人勘误：**

【这里原文给的命令是：java ShowMethods ShowMethods

但是这里有误，首先如果不给包名只给类名的话，Class.forName() 是无法加载类的，我也不明白作者有的例子里加了包名，有的单独给个类名是什么意思。

其次如果重复给两次类名的话，会进入 else 逻辑

```java
if (method.toString().contains(args[1])) {}
```

导致只打印含有类名的 Methods 方法。

所以这里正确的 main() 方法入参应该是 `java typeinfo.ShowMethods`】

> Class 方法 getmethods() 和 getconstructors() 分别返回 Method 数组和 Constructor 数组。 
>
> 这些类中的每一个都有进一步的方法来解析它们所表示的方法的名称、参数和返回值。
>
> 也可以像样例中那样使用 toString() 生成带有整个方法签名的字符串。代码的其余部分提取命令行信息，确定特定签名是否与目标字符串匹配，并使用正则表达式删除名称限定符。【这里对正则的使用还是不太理解】
>
> 编译时无法知道 Class.forName() 生成的结果，因此所有方法签名信息都是在运行时提取的。具体的可以看反射的JDK文档，**对编译时完全未知的对象的调用支持非常全面。**
>
> 



### 动态代理

> **代理是基本的设计模式之一**。
>
> 一个对象**封装**真实对象，代替其提供其他或不同的操作，这些操作通常涉及到与**真实**对象的通信，**代理类充当中间对象**。

下图摘自[java-design-patterns](https://github.com/iluwatar/java-design-patterns)

![alt text](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200304173750.png)

```java
// typeinfo/SimpleProxyDemo.java
interface Interface {
    void doSomething();

    void somethingElse(String arg);
}

class RealObject implements Interface {
    @Override
    public void doSomething() {
        System.out.println("doSomething");
    }

    @Override
    public void somethingElse(String arg) {
        System.out.println("somethingElse " + arg);
    }
}

// 代理类
class SimpleProxy implements Interface {
    // 真实要调用的对象
    private Interface proxied;

    SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }

    @Override
    public void doSomething() {
        System.out.println("代理类调用真实类方法");
        proxied.doSomething();
    }

    @Override
    public void somethingElse(String arg) {
        System.out.println("代理类调用真实类带参方法: " + arg);
        proxied.somethingElse(arg);
    }
}


public class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse("bobo");
    }

    public static void main(String[] args) {
        consumer(new RealObject());
        consumer(new SimpleProxy(new RealObject()));
    }
}
/**
输出
doSomething
somethingElse bobo
代理类调用真实类方法
doSomething
代理类调用真实类带参方法: bobo
somethingElse bobo
*/
```

> 这里 `consumer()` 接受 `Interface` 所以它不知道获得的是 真实类 `RealObject` 还是实现真实类接口的代理类 `SimpleProxy`，因为它们都实现了相同的接口。但是在客户端和 `RealObject` 之间插入的 `SimpleProxy` 执行操作，然后在 `RealObject` 上调用相同的方法。
>
> 当你希望**将额外的操作与真实对象做分离**，使用代理可能会有所帮助。（对真实对象可以做一些增强的操作），尤其是当你想要轻松地启用额外的操作时，反之亦然（**设计模式就是封装变化—所以你必须改变一些东西以证明模式的合理性**）。
>
> 例如，如果你想跟踪对 `RealObject` 中方法的调用，或衡量此类的开销，而且这部分代码不应耦合到 `RealObject` 中，代理类可以轻松实现你的目标。
>
> Java 的**动态代理**更进一步，不仅动态创建代理对象而且动态处理对代理方法的调用。 在动态代理上进行的所有调用都被重定向到**单个调用处理程序**，该处理程序负责发现调用的内容并决定如何处理。这是 `SimpleProxyDemo.java` 使用动态代理重写的例子：

```java
// SimpleDynamicProxy.java
// 动态代理类
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;

    public DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("**** Proxy: " + proxy.getClass() +
                ", method: " + method + ", args: " + args);

        if (args != null) {
            for (Object arg : args) {
                System.out.println(" " + arg);
            }
        }
        return method.invoke(proxied, args);
    }
}


public class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse("bobo");
    }

    public static void main(String[] args) {
        System.out.println("---- Simple Proxy ----");
        RealObject real = new RealObject();
        consumer(real);
        System.out.println("----------");
        Interface proxy = (Interface) Proxy.newProxyInstance(
                Interface.class.getClassLoader(),
                new Class[]{Interface.class},
                new DynamicProxyHandler(real));
        consumer(proxy);
    }
}
/**
输出
---- Simple Proxy ----
doSomething
somethingElse bobo
----------
**** Proxy: class typeinfo.$Proxy0, method: public abstract void typeinfo.Interface.doSomething(), args: null
doSomething
**** Proxy: class typeinfo.$Proxy0, method: public abstract void typeinfo.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@d716361
 bobo
somethingElse bobo
*/
```



### 源码：

```java
    
		/**
		返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序	
		loader -> 定义代理类的类加载器
		interfaces -> 代理类要实现的接口列表
		h -> 将方法调用分派到的调用处理程序
		*/
		@CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

```

**【这个方法很长很复杂，抓住重点，看注释就行了，尤其是方法参数的注释，很有用。】**



> 可以通过调用静态方法 Proxy.newProxyInstance() 来创建动态代理。该方法需要一个类加载器（通常可以从已加载对象中获取），代理实现的接口列表（不是类或抽象类）以及接口 InvocationHandler 的一个实现。
>
> 动态代理会将所有调用重定向到调用处理程序，因此通常调用处理程序的构造函数提供对"真实"对象的引用，以便一旦执行中介任务便可以转发请求。
>
> 通常执行代理操作，然后使用 Method.invoke() 将请求转发给被代理对象，并携带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是可以过滤某些方法调用，同时**传递其他方法调用**：

```java
// SelectingMethods.java
class MethodSelector implements InvocationHandler {

    // 持有的被代理的对象
    private Object proxied;

    public MethodSelector(Object proxied) {
        this.proxied = proxied;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 对特定代理方法进行了增强
        if (method.getName().equals("interesting")) {
            System.out.println("Proxy detected the interesting method");
        }
        return method.invoke(proxied, args);
    }
}

interface SomeMethods {
    void boring1();

    void boring2();

    void interesting(String arg);

    void boring3();
}

class Implementation implements SomeMethods {

    @Override
    public void boring1() {
        System.out.println("boring1");
    }

    @Override
    public void boring2() {
        System.out.println("boring2");
    }

    @Override
    public void interesting(String arg) {
        System.out.println("interesting " + arg);
    }

    @Override
    public void boring3() {
        System.out.println("boring3");
    }
}


public class SelectingMethods {
    public static void main(String[] args) {
        SomeMethods proxy = (SomeMethods) Proxy.newProxyInstance(
                SomeMethods.class.getClassLoader(),
                new Class[]{SomeMethods.class},
                new MethodSelector(new Implementation()));

        proxy.boring1();
        proxy.boring2();
        proxy.interesting("bobo");
        proxy.boring3();
    }
}
/**
输出
boring1
boring2
Proxy detected the interesting method
interesting bobo
boring3
*/
```

> 在这个例子中我们在代理类中，对特定方法进行了增强。
>
> 你也可以寻找方法签名的其他方面，甚至可以搜索特定的参数值来确定某些你想代理的方法。
>
> **动态代理不是你每天都会使用的工具，但是它可以很好地解决某些类型的问题。**

