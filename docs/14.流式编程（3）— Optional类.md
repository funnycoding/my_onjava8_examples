---
layout: post
title: 《On Java8》第十四章——流式编程(3) —— Optional类
date: 2020年02月22
tags:
- 读书笔记
categories: 
- 《On Java8》

---

### Optional类

> 在学习 终端操作之前，必须思考如果在一个空流中获取元素会发生什么。我们喜欢为了 "happy path"而将流连接起来，并**假设流不会被中断。**
>
> 在流中放置 **`null`** 是**很好的中断方法**。那么是否有某种对象，可作为**流元素的持有者**，即时**查看元素不存**在也能进行**友好的提示而不会发生异常？**
>
> <!-- more -->	
>
> Optional 可以实现这样的功能。一些标准流操作返回 Optional 对象，因为这些操作不能保证预期结果一定存在。包括：
>
> - `findFirst()` 返回一个包含**第一个元素的 Optional 对象**，如果流为空则返回 **Optional.empty**
> - `findAny()`返回包含**任意元素的 Optional 对象**，如果流为空则返回 **Optional.empty**
> - `max()` 和 `min()` 返回一个包含最大值或最小值的 Optional 对象，如果流为空返回 **Optional.empty** `reduce()` 不再以 `identity` 形式开头，而是将其返回值包装在 Optional 中。（`identity` 对象成为其他形式的 `reduce()` 的默认结果，因此不存在结果空结果的风险）
> - 对于数值流，**IntStream**、**LongStream** 和 **DoubleStream**， `average()` 会将结果包装在 **Optional** 以防止流为空

【之前使用的 Guava 和相当多的类库都有 Optional 的存在，确实很多场景是用来做非空判断的，但是一直没去研究究竟是怎么回事，就一直那么用了，还是要知其所以然啊。】

> 以下是对空流进行所有这些操作的简单测试：

```java
// OptionalsFromEmptyStreams.java
public class OptionalsFromEmptyStreams {
    public static void main(String[] args) {
        System.out.println(Stream.<String>empty().findFirst());
        System.out.println(Stream.<String>empty().findAny());
        System.out.println(Stream.<String>empty().max(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.<String>empty().min(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.<String>empty().reduce((s1,s2) -> s1 + s2));
        System.out.println(IntStream.empty().average());
    }
}
/**
输出
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
OptionalDouble.empty
*/
```

**【这里有个东西是我以前没见过的 `CASE_INSENSITIVE_ORDER`，看了一下是排序的比较器 ，具体怎样实现的和是根据什么算法进行排序，先略过。】**

> **当流为空的时候，你会蝴蝶一个 Optional.empty 对象，而不是抛出异常。**
>
> Optional 拥有 toString() 方法可以用于展示有用的信息。
>
> 注意，空流是通过 `Stream.<String>.empty()` 创建的。如果你在没有任何**上下文环境**的情况下调用 `Stream.empty()` ，**Java 并不知道它的数据类型**，这个语法解决了整个问题。编译器有了足够的上下文信息，比如：

```java
Stream<String> s = Stream.empty();
```

【也就是说 编译器可以根据泛型类型参数在 Lambda 和方法引用中 做出对应的类型推导】

> 就可以在调用 `empty()` 时推断类型。
>
> 下面例子展示了 Optional 的两个基本用法：

```java
// OptionalBasics.java
// Optional的两个基本用法
public class OptionalBasics {
  	// 判断是否有值，有值就输出Optional中的值，没有则输出 Nothing inside
    static void test(Optional<String> optString) {
        if (optString.isPresent()) {
            System.out.println(optString.get());
        } else {
            System.out.println("Nothing inside!");
        }
    }

    public static void main(String[] args) {
        test(Stream.of("Epithets").findFirst());
        test(Stream.<String>empty().findFirst());
    }
}
/**
输出
Epithets
Nothing inside!
*/
```

> 当你接收到 Optional 对象时，应该首先调用 `isPresent()` 检查其中是否包含元素。如果存在，可以使用 `get()` 获取。

#### 便利函数

> 有许多便利函数可以**解包** **Optional**，这简化了上述 对包含的对象的检查和执行的操作
>
> - `ifPresent(Consumer)`：当值存在则调用 **Consumer**，否则什么也不做。
> - `orElse(otherObject)`：如果**存在直接返回**，否则生成 **otherObject**。
> - `orElseGet(Supplier)`：如果**存在直接返回**，否则使用 **Supplier** 函数生成一个可替代对象。
> - `orElseThrow(Supplier)`：如果值**存在直接返回**，否则使用 **Supplier 函数生成一个异常**
>
> 以下针对不同便利函数的演示：

```java
// Optionals.java
public class Optionals {
    static void basics(Optional<String> optString) {

        if (optString.isPresent()) {
            System.out.println(optString.get());
        } else {
            System.out.println("啥也没有");
        }
    }

    static void ifPresent(Optional<String> optString) {
        optString.ifPresent(System.out::println);
    }

    static void orElse(Optional<String> optString) {
        System.out.println(optString.orElse("Nada"));
    }

    static void orElseGet(Optional<String> optString) {
        System.out.println(optString.orElseGet(() -> "Generated"));
    }

    static  void OrElseThrow(Optional<String> optString) {
        try {
            System.out.println(optString.orElseThrow(() -> new Exception("Supplied")));
        } catch (Exception e) {
            System.out.println("Caught" + e);
        }
    }

    static void test(String testName, Consumer<Optional<String>> cos) {
        System.out.println(" === " + testName + " === " );
        cos.accept(Stream.of("Epithets").findFirst());
        cos.accept(Stream.<String>empty().findFirst());
    }

    public static void main(String[] args) {
        test("basics", Optionals::basics);
        test("ifPresent", Optionals::ifPresent);
        test("orElse", Optionals::orElse);
        test("orElseGet", Optionals::orElseGet);
        test("orElseThrow", Optionals::OrElseThrow);
    }
}
/**
输出
 === basics === 
Epithets
啥也没有
 === ifPresent === 
Epithets
 === orElse === 
Epithets
Nada
 === orElseGet === 
Epithets
Generated
 === orElseThrow === 
Epithets
Caughtjava.lang.Exception: Supplied
*/

```

> `test()` 通过传入所有方法都适用的 Consumer 来避免重复代码。
>
> `orElseThrow()` 通过 catch 关键字来捕获抛出的异常。

**【其实之前我一直对内置函数接口的具体使用有一些疑惑，写完这个例子瞬间清晰了很多，仔细看 test的入参和真正使用test时传入的参数，再看 Consumer 里接口的方法，就可以串联起来了。】**

```java
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
  }

```

**【对给定的参数执行操作，上面的例子给定的参数是 Stream 生成的流，传入的操作就是上面定义的 Optional的方法。】**

#### 创建 Optional

> 当我们自己在代码中加入 Optional 时，可以使用下面三个静态方法：
>
> - `empty()`：生成一个空Optional
> - `of(value)`：将一个非空值包装到 Optional 里。
> - `ofNullable(value)`：针对一个可能为空的值，为空时自动生成 **Optional.empty**，否则将值包装在 Optional 中。

```java
// CreatingOptionals.java
public class CreatingOptionals {
    static void test(String testName, Optional<String> opt) {
        System.out.println(" === " + testName + " === ");
        System.out.println(opt.orElse("Null"));
    }

    public static void main(String[] args) {
        test("empty",Optional.empty());
        test("of", Optional.of("Howdy"));
        try {
            test("of", Optional.of(null));
        } catch (Exception e) {
            System.out.println(e);
        }
        test("ofNullAlbe", Optional.ofNullable("Hi"));
        test("ofNullAlbe", Optional.ofNullable(null));
    }
}

```

> 我们不能传入一个 `null` 对象到 `Optional.of` 中来创建 Optional对象，当入参可能为 null 时， 使用 `ofNullable` 来优雅的处理 null 值。

**【好的，看完之后我对 null 的处理又多了一种方法，以前一直是 if(String.isEmpty()】**

#### Optional 对象操作

> 当流管道生成 Optional对象，下面三个方法可以让 Optional 后续能做更多操作：
>
> - `filter(Predicate)`：将 Predicate 应用于 Optional 中的内容并返回结果。当 Optional 不满足 Predicate 时返回空。如果 Optional 为空，则直接返回
> - `map(Function)`：如果 **Optional 不为空**，**应用 Function 于 Optional 中的内容**，并返回结果。**否则直接返回 Optional.empty。**
> - `flatMap(Function)`：同 `map()`，但是提供的映射函数将结果包装在 Optional 对象中，因此 `flatMap()` **不会在最后进行任何包装。**

```java
// OptionalFilter.java
public class OptionalFilter {
    static String[] elements = {"Foo", "", "Bar", "Baz", "Bingo"};

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }
		// 传入的 Predicate 谓词方法将被应用在 testStream 生成的流上的 filter方法中
    static void test(String descr, Predicate<String> pred) {
        System.out.println(" ---(" + descr + " )---");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .filter(pred)
            );
        }
    }

    public static void main(String[] args) {
        test("true", str -> true);
        test("false", str -> false);
        test("str != \"\"", str -> str != "");
        test("str.length() == 3", str -> str.length() == 3);
        test("str.startWith(\"B\")", str -> str.startsWith("B"));
    }
}
/**
输出
 ---(true )---
Optional[Foo]
Optional[]
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---(false )---
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
 ---(str != "" )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---(str.length() == 3 )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional.empty
Optional.empty
 ---(str.startWith("B") )---
Optional.empty
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
*/


```

> 几十输出看起来像流，特别是 `test()` 中的 for循环。每一次 for 循环时重新启动流，然后根据 for 循环的索引跳过 i 个元素，然后获取到 `findFirst()` 剩余元素中的第一个，这个结果会包装在 Optional 中。
>
> 这里的 i <= elements.length，所以最后一个元素超出了数组的界限，返回了 Optional.empty。



> 同 `map()` 一样，`Optionla.map()` **应用于函数**。它**仅在 Optional 不为空时才映射函数**，并将 Optional 的内容提取到映射函数。

```java
// OptionalMap.java
public class OptionalMap {
    static String[] elements = {"12", "", "23", "45"};

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    static void test(String descr, Function<String, String> func) {
        System.out.println(" ---( " + descr + " )--- ");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst() // 生成一个Optional对象
                            .map(func)
            );
        }
    }

    public static void main(String[] args) {
        // 如果 Optional 不为空， map() 首先提取
        // the contents which it then passes
        // to the function:
        test("Add brackets", s -> "[" + s + "]");
        test("Increment", s ->{
            try {
                return Integer.parseInt(s) + 1 + "";
            } catch (NumberFormatException e) {
                return s;
            }
        });
        test("Replace", s -> s.replace("2", "9"));
        test("Take last dighit", s -> s.length() > 0 ? s.charAt(s.length() - 1) + "" : s);
        // function 执行完毕后，map() 方法将返回结果包装为 Optional对象
    }
}

/**
输出
 ---( Add brackets )--- 
Optional[[12]]
Optional[[]]
Optional[[23]]
Optional[[45]]
Optional.empty
 ---( Increment )--- 
Optional[13]
Optional[]
Optional[24]
Optional[46]
Optional.empty
 ---( Replace )--- 
Optional[19]
Optional[]
Optional[93]
Optional[45]
Optional.empty
 ---( Take last dighit )--- 
Optional[2]
Optional[]
Optional[3]
Optional[5]
Optional.empty

*/

```

> 映射函数 map() 的返回结果会自动包装为 Optional。 Optional,empty 会被直接跳过。
>
> **Optional** 的 `flatMap()` 应用于已生成的 **Optional** 的映射函数，所以 `flatMap()` 不会像 `map()` 那样将结果封装在 **Optional** 中。

```java
// OptionalFlatMap.java
// 例子和上个例子一样，只是最后将返回值用 Optional.of() 进行包裹。
public class OptionalFlatMap {
    static String[] elements = {"12", "", "23", "45"};

    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    static void test(String descr, Function<String, Optional<String>> func) {
        System.out.println(" ---( " + descr + " )---");
        for (int i = 0; i <= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .flatMap(func)
            );
        }
    }

    public static void main(String[] args) {
        test("增加括号", s -> Optional.of("[ " + s + " ]"));

        test("加一", s -> {
            try {
                return Optional.of(Integer.parseInt(s) + 1 + "");
            } catch (Exception e) {
                return Optional.of(s);
            }
        });

        test("替换", s -> Optional.of(s.replace("2", "9")));

        test("获取最后一位", s -> Optional.of(
                s.length() > 0 ? s.charAt(s.length() - 1) + ""
                        : s));
    }
}

```

> 同 `map()` 的作用一样， `flatMap()` 将提取非空 Optional 的内容并将其应用在映射函数上。唯一区别是 `flatMap()` 不会把结果包装在 Optional 中，因为映射函数已经被包装过了。
>
> 在如上示例中，我们已经在每一个函数映射中显示地完成了包装，但是显然 `Optional.flatMap()` 是为那些已经**自己生成 Optional 的函数而设计**。

#### Optional 流

> 假设你的生成器可能产生 `null` 值，那么当它用来创建流时，你会自然地想到用 **Optional 来包装元素**。

```java
// streams/Signal.java
public class Signal {
    private final String msg;

    public Signal(String msg) {
        this.msg = msg;
    }

    public String getMsg() {
        return msg;
    }

    @Override
    public String toString() {
        return "Signal(" + msg + ")";
    }

    static Random rand = new Random(47);

    public static Signal morse() {
        switch (rand.nextInt(4)) {
            case 1:
                return new Signal("dot");

            case 2:
                return new Signal("dash");
            default:
                return null;
        }
    }
    
    public static Stream<Optional<Signal>> stream() {
        return Stream.generate(Signal::morse)
                .map(signal -> Optional.ofNullable(signal));
    }
}

```

> 当我们使用这个流的时候，必须先弄清楚如何解包 **Optional** ：

```java

public class StreamOfOptionals {
    public static void main(String[] args) {
        Signal.stream()
                .limit(10)
                .forEach(System.out::println);

        System.out.println("-----------");

        Signal.stream()
                .limit(10)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .forEach(System.out::println);
    }
}

/**
输出
Optional[Signal(dash)]
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional.empty
Optional.empty
Optional[Signal(dash)]
Optional.empty
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional[Signal(dash)]
-----------
Signal(dot)
Signal(dot)
Signal(dash)
Signal(dash)

*/

```

> 在上面例子中使用 `filter()` 来保留非空 Optional，然后在 `map()` 中使用 `get()` 获取 **Optional** 的元素。
>
> **由于每种情况都需要定义 "空值" 的含义，所以通常需要为每个应用程序编写不同的方法。**



### 本章小结：

Optional 类的出现是为了处理空指针异常，其内置的方法可以优雅的在 Optional 为空的情况下返回一个对象 而不是直接抛出异常。

Optional 是一个封装了，里面包含了你放进去的值。

使用 Optiona 的内置方法可以简化对对象是否为空的判断，使代码更加优雅，



