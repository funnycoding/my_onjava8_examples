---
layout: post
title: 《On Java8》第十九章——RTTI
date: 2020年02月28日16:09:46
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### 为什么需要 RTTI

<!-- more -->	

```java
// 最顶层的抽象基类，定义一个通用 draw 方法。打印自己本身，并将 toString 设置为抽象方法让子类自己实现。
// typeinfo/Shapes.java
abstract class Shape {
    void draw() {
        System.out.println(this + ".draw()");
    }

    @Override
    public abstract String toString();
}


class Circle extends Shape {
    @Override
    public String toString() {
        return "Circle";
    }
}

class Square extends Shape {
    @Override
    public String toString() {
        return "Square";
    }
}

class Triangle extends Shape {
    @Override
    public String toString() {
        return "Triangle";
    }
}


public class Shapes {
    public static void main(String[] args) {
        Stream<Shape> shapeStream = Stream.of(new Circle(), new Square(), new Triangle());
        shapeStream.forEach(System.out::println);
    }
}

```



### Class 对象

```java
// typeinfo/SweetShop.java
// 检查类加载器工作方式
class Cookie {
    static {
        System.out.println("Loading Cookie");
    }
}

class Gum {
    static {
        System.out.println("Loading Gum");
    }
}

class Candy {
    static {
        System.out.println("Loading Candy");
    }
}


public class SweetShop {
    public static void main(String[] args) {
        System.out.println("进入 main() 方法了");
        new Candy();
        new Candy(); // 可以看到静态代码块只在第一次类加载的时候被执行

        System.out.println("创建 Candy 对象之后");
        try {
            // 这里要正确的加载只能带上包名 后面作者再次使用的时候也加上了包名，我倾向于这是作者的失误
            Class.forName("typeinfo.Gum");
        } catch (ClassNotFoundException e) {
            System.out.println("Couldn't find Gum");
        }
        System.out.println("After Class.forName(\"Gum\")");

        new Cookie();
        System.out.println("After Create Cookie");

    }
}
/**
输出
进入 main() 方法了
Loading Candy
创建 Candy 对象之后
Loading Gum
After Class.forName("Gum")
Loading Cookie
After Create Cookie
*/

```



```java
// typeinfo/toys/ToyTest.java
// 测试 Class 类
interface HasBatteries {
}

interface Waterproof {
}

interface Shoots {
}

class Toy {
    Toy() {
    }

    Toy(int i) {
    }
}

class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots {
    public FancyToy() {
        super(1);
    }
}


public class ToyTest {
    static void printInfo(Class clazz) {
        System.out.println("ClassName: " + clazz.getName() + "," + " is interface?[" + clazz.isInterface() + "]");

        System.out.println("Simple Nmae : " + clazz.getSimpleName());

        System.out.println("Canonical name: " + clazz.getCanonicalName());
    }

    public static void main(String[] args) {
        Class clazz = null;
        try {
            clazz = Class.forName("typeinfo.toys.FancyToy");
        } catch (ClassNotFoundException e) {
            System.out.println("Can't find FancyToy");
            System.exit(1);
        }

        printInfo(clazz);
        System.out.println("---- Befoe Print CC ----");
        for (Class face : clazz.getInterfaces()) { // 获取到一个类的所有接口信息
            printInfo(face);
        }
        System.out.println("---- After Print CC ----");

        Class superclass = clazz.getSuperclass();
        Object obj = null;

        try {
            obj = superclass.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            System.out.println("Can't Access");
            System.exit(1);
        }
        printInfo(obj.getClass());
    }
}
/**
输出
ClassName: typeinfo.toys.FancyToy, is interface?[false]
Simple Nmae : FancyToy
Canonical name: typeinfo.toys.FancyToy
---- Befoe Print CC ----
ClassName: typeinfo.toys.HasBatteries, is interface?[true]
Simple Nmae : HasBatteries
Canonical name: typeinfo.toys.HasBatteries
ClassName: typeinfo.toys.Waterproof, is interface?[true]
Simple Nmae : Waterproof
Canonical name: typeinfo.toys.Waterproof
ClassName: typeinfo.toys.Shoots, is interface?[true]
Simple Nmae : Shoots
Canonical name: typeinfo.toys.Shoots
---- After Print CC ----
ClassName: typeinfo.toys.Toy, is interface?[false]
Simple Nmae : Toy
Canonical name: typeinfo.toys.Toy
*/


```





#### 类字面常量

```java
// typeinfo/ClassInitialization.java 
class Initable {
    static final int STATIC_FINAL = 47;
    static final int STATIC_FINAL_2 = ClassInitialization.rand.nextInt(1000);

    static {
        System.out.println("Initializing Initable");
    }
}

class Initable2 {
    static int staticNonFinal = 147;

    static {
        System.out.println("Initializing Initable2");
    }
}

class Initable3 {
    static int staticNonFinal = 74;

    static {
        System.out.println("Initializing Initable3");
    }
}

public class ClassInitialization {
    public static Random rand = new Random(47);

    public static void main(String[] args) throws ClassNotFoundException {
        Class initableClass = Initable.class; // 类的字面量常量

        // 使用字面量常量获得 Class 对象并没有触发类的初始化
        System.out.println("After Creating Initable reference");

        // 打印类的静态常量也不会触发类的初始化
        System.out.println(Initable.STATIC_FINAL);

        System.out.println(Initable.STATIC_FINAL_2);

        System.out.println(Initable2.staticNonFinal);

        Class initable3 = Class.forName("typeinfo.Initable3");

        System.out.println("After Initializing initbale3 Ref");

        System.out.println(Initable3.staticNonFinal);

    }
}

/**
输出
After Creating Initable reference
47
Initializing Initable
258
Initializing Initable2
147
Initializing Initable3
After Initializing initbale3 Ref
74
*/
```



#### 泛化的 Class 引用

```java
// typeinfo/GenericClassReferences.java

public class GenericClassReferences {
    public static void main(String[] args) {
        Class intClass = int.class;
        Class<Integer> genericIntClass = int.class;
        genericIntClass = Integer.class; // 同一个东西
        intClass = double.class;
        // genericIntClass = double.class; // 非法 
    }
}
```



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200228200330.png)

```java
Class<Number> geenericNumberClass = int.class; // 不行
```



使用 通配符之后：

```java
// typeinfo/WildcardClassReferences.java

public class WildcardClassReferences {
    public static void main(String[] args) {
        Class<?> intClass = int.class;
        intClass = double.class;
    }
}
```

> 虽然 Class<?> 与 Class 等价，但是使用泛型类型的 Class 却能接受任何类型代表你是故意为之，比使用原始类型要好。
>
> 创建限定某子类的 Class 引用需要通配符 与 extends 关键字配合使用：

```java
// typeinfo/BoundedClassReferences.java
public class BoundedClassReferences {
    public static void main(String[] args) {
        // 可以指向任何任何 Number 的子类的Class对象
        Class<? extends Number> bounded = int.class;
        bounded = double.class;
        bounded = Number.class;

    }
}
```

> 添加泛型是为了提供编译器的错误检查

```

```

> 使用 `newInstance()` 构造对象要求该对象必须存在无参构造器。



> 当 `Class` 使用泛型语法时，其实 `newInstance()` 返回的对象就是有确定类型的， 而不是 `ToyTest.java` 中看到的基类 Object， 但是这再某种程度上受限：

```java
// typeinfo/toys/GenericToyTest.java
// 测试 Class 类
// {java typeinfo.toys.GenericToyTest}
public class GenericToyTest {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException {
        Class<FancyToy> ftClass = FancyToy.class;

        // Produces exat type：
        FancyToy fancyToy = ftClass.newInstance();
        Class<? super FancyToy> superclass = ftClass.getSuperclass();
        // This won't compile: 下面的语句不能编译 具体还是跟泛型的擦除有关
        // Class<Toy> up2 = ftClass.getSuperclass();

        // Only produces Object: 只能构造 Object对象 而不是 Toy 对象
        Object object = superclass.newInstance();
    }
}

```

> 这里虽然明确知道 Toy 是 FancyToy 的超类但是只能这样写
>
>    `Class<? super FancyToy> superclass = ftClass.getSuperclass();`
>
> 而不能确切的持有 Toy
>
> `//  Class<Toy> up2 = ftClass.getSuperclass();`
>
> 正是由于这种特性，`superclass.newInstance();`只能返回 Object
>
> 不过可以使用强制类型转换

```
Toy object = (Toy) superclass.newInstance();
这么写是 OK 的。
```



#### cast() 方法

> Java 中还有用于 Class 引用的**类型转换**语法 即 `cast()` 方法：

```java
// typeinfo/ClassCasts.java
class Building {
}

class House extends Building {
}

public class ClassCasts {
    public static void main(String[] args) {
        Building b = new House();

        Class<House> houseType = House.class;

        // 下面两种方式进行类型转换效果相同
        House h = houseType.cast(b);
        h = (House) b;
    }
}
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200228204857.png)

**【可以看到 cast() 方法多封装了一层异常的判断】**

> 但是这种转换需要的前置工作比直接进行转换  h = (House) b;  要多很多。
>
> 如果你获取并保存了 Class 引用，希望通过这个引用来执行类型转换，就需要使用到 cast() 方法。
>
> 但是作者发现在整个 Java类库中只有 `com.sun.mirror.util.DeclarationFilter` 中使用。

### 类型转换检测

**RTTI类型**：

1. 传统的类型转换。如 Shape s =  (Shape) Object; 如果出错会抛出 ClassCastException 异常。
2. 代表对象类型的 `Class` 对象。通过 Class 对象可以获取运行时信息。

RTTI 在 Java 中还有第三种形式，关键字 instanceof。它返回一个 布尔值，告诉我们对象是不是某类型的实例。

```java
if(x instanceof Dog)
    ((Dog)x).bark();
```

使用 instanceof 可以避免类转换异常。

下面是继承 Individual 类的继承体系 ：

```java
/ typeinfo/pets/PetCreator.java
// Creates random sequences of Pets
package typeinfo.pets;
import java.util.*;
import java.util.function.*;

public abstract class PetCreator implements Supplier<Pet> {
    private Random rand = new Random(47);

    // The List of the different types of Pet to create:
    public abstract List<Class<? extends Pet>> types();

    public Pet get() { // Create one random Pet
        int n = rand.nextInt(types().size());
        try {
            return types().get(n).newInstance();
        } catch (InstantiationException |
                IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
```

> 抽象方法 types() 需要子类来实现，以此来获取 Class 对象构成的 List（这是模板方法设计模式的一种变体。）
>
> 其中类的类型被定义为 任何从 Pet 的继承的子类型。 
>
> 因此 newInstance() 不需要转型就可以产生 Pet。
>
> get() 随机选取出一个 Class 对象，然后可以通过 Class.newInstance() 来生成该类的新的实例。
>
> 在调用 newInstance() 时可能会出现两种异常。（IllegalAccessException 违反了 Java 安全机制，在本例中表示默认构造器为 private 的情况）
>
> 当你创建 PetCreator 子类时，需要为 get() 方法提供 Pet类型的 List。 types() 方法会简单地返回一个 静态 List 的引用。 下面是使用 forNameI() 的一个具体实现：

```java
// typeinfo/pets/ForNameCreator.java
public class ForNameCreator extends PetCreator {
    private static List<Class<? extends Pet>> types = new ArrayList<>();

    // 随机生成的类型名
    private static String[] typeNames = {
            "typeinfo.pets.Mutt",
            "typeinfo.pets.Pug",
            "typeinfo.pets.EgyptianMau",
            "typeinfo.pets.Manx",
            "typeinfo.pets.Cymric",
            "typeinfo.pets.Rat",
            "typeinfo.pets.Mouse",
            "typeinfo.pets.Hamster"
    };
    @SuppressWarnings("unchecked")
    private static void loader() {
        for (String name : typeNames) {
            try {
                types.add((Class<? extends Pet>) Class.forName(name));
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static {
        loader();
    }


    @Override
    public List<Class<? extends Pet>> types() {
        return types;
    }
}

```

> loader() 方法使用 Class.forName() 创建 Class 对象的 List。 可能导致 ClassNotFoundException 异常。 因为传入的是一个 String 类型的参数，不能在编译期间被确认是否合理。由于 Pet 相关文件在 typeinfo 包里，所以使用的时候需要填写完整的包名。

**【这里作者有一个自相矛盾的点，之前使用 Class.forName() 创建对象的时候并没有加上typeinfo 这个包名，而如果不加的话是会抛出异常的】**

> 
>
> 为了使放入 List 的对象是具体的 Class 对象，类型转换是必须的，它会产生一个编译时警告。
>
> loader() 方法是分开编写的，然后被放到一个静态代码块里。因为 `@SuppredssWarning` 注解不能直接放置在静态代码块上。
>
> 为了对 Pet 计数，需要能跟踪不同类型 Pet 的工具。
>
> Map 类型的数据结构是这个需求的首选，我们将 Pet 类型作为Key 其数量作为 Value。

```java
// typeinfo/PetCount.java
// 使用 instanceof
import typeinfo.pets.*;
import java.util.*;

public class PetCount {
    static class Counter extends HashMap<String, Integer> {
        public void count(String type) {
            Integer quantity = get(type);
            if (quantity == null)
                put(type, 1);
            else
                put(type, quantity + 1);
        }
    }

    public static void
    countPets(PetCreator creator) {
        Counter counter = new Counter();
        for (Pet pet : Pets.array(20)) {
            // List each individual pet:
            System.out.print(
                    pet.getClass().getSimpleName() + " ");
            if (pet instanceof Pet)
                counter.count("Pet");
            if (pet instanceof Dog)
                counter.count("Dog");
            if (pet instanceof Mutt)
                counter.count("Mutt");
            if (pet instanceof Pug)
                counter.count("Pug");
            if (pet instanceof Cat)
                counter.count("Cat");
            if (pet instanceof EgyptianMau)
                counter.count("EgyptianMau");
            if (pet instanceof Manx)
                counter.count("Manx");
            if (pet instanceof Cymric)
                counter.count("Cymric");
            if (pet instanceof Rodent)
                counter.count("Rodent");
            if (pet instanceof Rat)
                counter.count("Rat");
            if (pet instanceof Mouse)
                counter.count("Mouse");
            if (pet instanceof Hamster)
                counter.count("Hamster");
        }
        // Show the counts:
        System.out.println();
        System.out.println(counter);
    }

    public static void main(String[] args) {
        countPets(new ForNameCreator());
    }
}
```

> 这里用了大段的 instanceof 来进行类型检测，仅作为例子进行参考，如果真实代码中出现这样的代码就说明设计有问题
>
> instanceof  中有一个严格的限制，instanceof 运算符只能与类名做比较，而不能与 `Class` 对象作比较。



#### 使用类字面量

> 如果使用类字面量重新实现 `PetCreator` 类的话，其结果在很多方面都会更清晰：

```java
// typeinfo/pets/LiteralPetCreator.java
// 使用类字面量
public class LiteralPetCreator extends PetCreator {

    public static final List<Class<? extends Pet>> ALL_TYPES =
            Collections.unmodifiableList(Arrays.asList(
                    Pet.class, Dog.class, Cat.class, Rodent.class,
                    Mutt.class, Pug.class, EgyptianMau.class,
                    Manx.class, Cymric.class, Rat.class,
                    Mouse.class, Hamster.class
            ));

    // 这里是将所有类型的子集 从 Mutt.class 开始到结尾作为一个随机创建的集合返回
    private static final List<Class<? extends Pet>> TYPES = ALL_TYPES
            .subList(ALL_TYPES.indexOf(Mutt.class), ALL_TYPES.size());

    // try 代码块不再需要
    @Override
    public List<Class<? extends Pet>> types() {
        return TYPES;
    }

    public static void main(String[] args) {
        System.out.println(TYPES);
    }
}
/**
输出
[class typeinfo.pets.Mutt, class typeinfo.pets.Pug, class typeinfo.pets.EgyptianMau, class typeinfo.pets.Manx, class typeinfo.pets.Cymric, class typeinfo.pets.Rat, class typeinfo.pets.Mouse, class typeinfo.pets.Hamster]
*/

```

> 即将d奥莱的 PetCount3 中，使用 Pet 类型预先加载一个 Map，因此 ALL_TYPES 列表是必要的。 types 列表是 ALL_TYPES 类型的一部分，它包含精确的宠物类型，用于随机生成 Pet。
>
> 这次 types 的创建不需要用 try 包围，因为字面量常量在编译时计算，不会引发一场，不像 Class.forName()。
>
> 我们现在在 typeinfo.pets 库中有两个 PetCreator 实现。为了提供第二个作为默认实现，我们可以创建一个使用 LiteralPetCreator 的**`外观模式`**：

```java
// typeinfo/pets/Pets.java
public class Pets {
    // 创建一个不可变的 CREATOR
    public static final PetCreator CREATOR = new LiteralPetCreator();

    public static Pet get() {
        return CREATOR.get();
    }

    public static Pet[] array(int size) {
        Pet[] result = new Pet[size];
        for (int i = 0; i < size; i++) {
            result[i] = CREATOR.get();
        }
        return result;
    }

    public static List<Pet> list(int size) {
        ArrayList<Pet> result = new ArrayList<>();
        Collections.addAll(result, array(size));
        return result;
    }

    public static Stream<Pet> stream() {
        return Stream.generate(CREATOR);
    }
}

```

> 这里还提供了对 get()、array()、和 list() 的间接调用，以及生成 `Stream<Pet>` 的新方法。
>
> 因为 PetCount.countPets() 采用了 PetCreator 参数，所以我们可以很容易地测试 LiteralPetCreator （**`通过外观模式）`**

```java
// typeinfo/PetCount2.java
import typeinfo.pets.*;

public class PetCount2 {
    public static void main(String[] args) {
        PetCount.countPets(Pets.CREATOR);
    }
}
/**
输出
Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric 
{EgyptianMau=2, Pug=3, Rat=2, Cymric=5, Mouse=2, Cat=9, Manx=7, Rodent=5, Mutt=3, Dog=6, Pet=20, Hamster=1}
*/
```

#### 这里我有一个迷惑的地方：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200229141144.png)

这里传进去的PetCreator 对象压根就没有用，生成的对象都是 Pets.array() 方法生成的，这个方法内部

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200229141227.png)

就内定了使用 LiteralPetCreator

![image-20200229141253984](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/image-20200229141253984.png)

所以这个方法的入参压根没有意义，不明白作者的Demo为啥要这么写。



#### 一个动态 instanceof 函数

> `Class.isInstance()` 方法提供了一种动态测试对象类型的方法。因此所有这些繁琐的 `instanceof` 语句都可以从 `PetCount.java` 中删除。

```java
public class PetCount3 {
    static class Counter extends LinkedHashMap<Class<? extends Pet>, Integer> {
        Counter() {
            super(LiteralPetCreator.ALL_TYPES.stream()
                    .map(lpc -> Pair.make(lpc, 0))
                    .collect(Collectors.toMap(Pair::key, Pair::value)));
        }

        public void count(Pet pet) {
            // Class.isInstance() 替代 instanceof
            entrySet().stream()
                    .filter(pair -> pair.getKey().isInstance(pet))
                    .forEach(pair -> put(pair.getKey(), pair.getValue()));
        }

        @Override
        public String toString() {
            String result = entrySet().stream()
                    .map(pair -> String.format("%s=%s", pair.getKey().getSimpleName(),
                            pair.getValue()))
                    .collect(Collectors.joining(", "));
            return "{ " + result + " }";
        }

        public static void main(String[] args) {
            Counter petCount = new Counter();
            Pets.stream()
                    .limit(20)
                    .peek(petCount::count)
                    .forEach(p -> System.out.print(p.getClass().getSimpleName() + " "));
            System.out.println("n" + petCount);
        }
    }
}



/**
输出
Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric n{ Rat=0, Rodent=0, Pet=0, Mouse=0, Cymric=0, Manx=0, Mutt=0, Pug=0, Cat=0, EgyptianMau=0, Dog=0, Hamster=0 }
*/
```

【这个类值得考究，第一遍的时候没怎么看明白】

> 为了计算所有不同类型的 Pet，Counter Map 预先加载了来自 LiteralPetCreator.ALL_TYPES 的类型，如果不预先加载 Map，将值计数随机生成的类型，而不是像 Pet 和 Cat 这样的基本类型。
>
> isInstance() 方法消除了对 instanceof 表达式的需要。
>
> 

#### 递归计数



### 注册工厂



### 类的等价比较



### 反射：运行时类信息

#### 类的方法提取



### 动态代理

> 代理是基本的设计模式之一。一个对象封装真实对象，代替其提供其他或不同的操作，这些操作通常涉及到与真实对象的通信，代理类充当中间对象。



### Optional 类

#### 标记接口

#### Mock 对象和桩



### 接口和类型



### 本章小结