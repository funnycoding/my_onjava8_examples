---
layout: post
title: 《On Java8》第十五章——异常(1)
date: 2020-02-24 22:16:37
tags:
- 读书笔记
categories: 
- 《On Java8》
---



> Java 的基本理念是 "结构不佳的代码不能运行"
>
> 异常是 Java 针对程序出现错误时的处理机制。 发现错误最佳实际是在编译阶段，但是总有错误只能在运行时发现，这就需要错误能通过某种方式，把适当的信息传递给某个接收者，并被正确地处理。
>
> Java 使用异常来提供一一致的错误报告模型。
>
> **异常处理是 Java 中唯一官方的错误报告机制，并且通过编译器强制执行。**
>
> 

<!-- more -->	

【个人前言：

Java异常是非常重要的特性，根据28法则，20%的代码用来处理程序正常运转的逻辑，而80%的代码则要处理各种异常情况。

而我们一般采用的是**防御性编程**，默认前端传来的数据都是不可信的。

对于错误的处理不可避免的会大量的用到异常的定义，抛出，处理。

如果不能正确的使用 Java 异常，那么你的系统肯定是不够健壮的。

而异常没有什么复杂的技巧，属于工程概念，只要学了，就会有收获，就能增强程序的健壮性。】

### 异常概念

程序中发生的错误：

- 输入参数错误
- IO流打开文件错误
- NetWork网络调用超时错误

异常这个词有对此感到意外的意思，我们总要对可能出现的问题做处理。

异常往往能降低 处理错误代码的复杂度。 

异常机制能保证捕获错误，理想情况下只需要在一个地方处理错误。







### 基本异常

异常情形是指当前方法无法继续下去的情况。

发生异常后，在当前环境下无法获得必要的信息来解决问题，需要将问题提交给上一级环境，这就是抛出异常时所发生的事情：



> 参数异常：比如除数为0。当除数为0时会发生异常，但是这个异常到底代表什么，你也许不清楚应该如何处理，那就要抛出异常，而不是顺着以前的路径继续执行。
>
> 当抛出异常后，会在堆上创建一个异常对象，同时程序正常流程结束，异常处理机制开始接管程序。使程序要么从错误状态中恢复，要么换一种方式运行。
>
> 下面的例子就抛出了一个异常：

```java
if(t == null) {
	throw new NullPointException()
}
```

于是当前环境就不必在为 t 引用没有初始化这个问题操心，它将在别的地方被处理。



异常使得我们可以将每件事都当做一个事务来考虑，而异常是这些事务的底线，事务的基本保障使我们所需的在分布式计算中的异常处理。事务是计算机中的合同法，如果出了问题，只需要放弃整个计算。

**异常最重要的方面之一就是如果发生问题，JVM 不会允许程序沿着正常路径继续运行。从而不会导致系统长时间的运行在错误的状态中并且已经计算了很多错误的值。**



#### 异常参数

异常对象的构造也伴随着存储空间的分配和构造器的调用。

标准异常有两个构造器：一个无参构造器，一个接受字符串作为参数，将相关信息放入异常对象。

```java
throw new NullPointerException("t = null");
```

提取异常类中的字符串内容有很多种不同的方法。

在使用 new 创建了异常对象之后，此对象的引用将传给 throw。尽管异常对象的类型通常与方法的返回类型不同，但从效果上看就像是被方法返回的。

**还能使用抛出异常的方法从当前的作用域退出，在这两种情况下，会返回一个异常对象，然后退出方法或作用域。**

异常的返回地点与普通方法返回的地点完全不同（异常将在一个恰当的异常处理程序中得到解决，它的位置可能会跨越方法调用栈的许多层级。）

异常的顶层接口是 **Throwable**，对于不同类型的错误，要抛出相应的异常。

【我们在开发中定义异常的时候也会根据不同的模块定义不同的异常，这样一眼就能看出来是哪个模块发生的问题】

> 通常，唯一的信息只有异常的类型名，而在异常内部没有任何有意义的信息。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225002011.png)

### 异常捕获

> 明白异常如何被捕获需要先理解 监控区域的概念。

【所谓监控区域也就是被 try 块包围的代码】

#### try语句

> 如果方法内部抛出了异常（或者方法内部调用的其他方法抛出了异常）这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，应该使用 try 来包裹可能发生异常的地方。

```java
try {
	可能发生异常的代码
}
```



【关于异常的应用的要点就在这里，之前做业务的有个反例：有的小的输入参数的异常不影响整个业务，但是我没有使用 catch 将其捕获 或是直接 return 解析某个子方法，而是向上抛出了一个异常，导致整个方法失败，后续的业务没有进行】

> 如果是不支持异常的语言，那么要想检查错误就需要在方法调用的前后都加上错误检查的代码，这样就将业务无关的代码混淆在业务中、

#### 异常处理程序

> 抛出的异常必须得到处理，针对可能捕获的异常，需要准备对应的处理程序。

```java
try {
	// 可能抛出异常的代码
} catch(异常1) {
		//针对异常1进行处理的代码
	}
	catch(异常2) {
		// 针对异常2进行处理的代码
	}
	
	...

```

> 每个 catch 子句就像是一个接收且仅接收一个特殊类型的方法。
>
> 异常处理程序必须紧跟在 try 块之后。
>
> 当异常被抛出时，异常处理机制将负责搜索参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行。一旦 catch 子句结束，则处理程序的查找过程也结束。
>
> try 块中不同的方法调用可能产生同类型的异常，只需要一个针对该异常的 catch 块就可以。

#### 终止与恢复

异常有两种基本模型：

- 终止模型 —— 假设错误非常严重，程序崩溃，无法返回到异常发生的地方继续执行。一旦异常被抛出，也代表错误无法挽回，不能反悔发生地继续执行。
- 恢复模型 —— 异常被处理之后继续执行。也就是被 catch 块中的代码尝试恢复。

> 在过去，使用恢复模型异常处理的操作系统的程序员们最终还是转向类似 终止模型的代码，并且忽略恢复行为。
>
> 因为恢复模型虽然吸引人，但是不实用，还容易导致代码的耦合。

【但是在平时开发过程中，catch 还是有用的，但是有句话那么说 throw early catch later，能抛出去还是要抛出去，不要把错误掩盖，否则可能在控制台都看不到发生了什么错程序就终止了】



### 自定义异常

只要继承 Java 已有的异常类就可以创建新的异常类型，建立新的异常类型最简单的方法就是让编译器为你产生无参构造器。

```java
// InheritingExceptions.java
    
class SimpleException extends Exception { }


public class InheritingExceptions {
    public void f() throws SimpleException {
        System.out.println("抛出简单异常");
        throw new SimpleException();
    }

    public static void main(String[] args) {
        InheritingExceptions sed = new InheritingExceptions();
        try {
            sed.f();
        } catch (SimpleException e) {
            System.out.println("抓住你了: " + e.getClass().getSimpleName());
        }
    }
}

/**
输出
抛出简单异常
抓住你了: SimpleException
*/
```

这里创建了一个 自定义的异常类 继承 Exception ，这个类中什么也没有定义。所以存在编译器自动生成的 无参构造器。  

> 对异常来说，最重要的部分就是类名，所以本例中建立的异常类在大多数情况下已经够用了。
>
> 本例的结果被打印到了控制台上，但是你也许想通过写入 System.err 而将错误发送给标准错误流，通常这比把信息输出到 System.out 要好。因为 System.ou 也许会被重定向。而 Sytem.err 不会被重定向，更容易被用户注意到。

```java
// System.java

  public final static PrintStream err = null;
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225145028.png)

可以看到换成 `System.err` 输出流之后字体变成了红色，以及 `System.out` 会被重定向 而 `System.err` 不会被重定向这个新的小知识点也 get 到了。



> 你也可以为异常类创建一个接受字符串参数的构造器：

```javascript
// FullCOnstrctors.java

class MyException extends Exception {
    public MyException() {
    }

    public MyException(String message) {
        super(message);
    }
}


public class FullCOnstrctors {
    public static void f() throws MyException {
        System.out.println("抛出 MyException 。");
        throw new MyException();
    }

    public static void g() throws MyException {
        System.out.println("抛出带参数的 MyException from g()");
        throw new MyException("带参数的 Exception 来自 g()");
    }

    public static void main(String[] args) {
        try {
            f();
        } catch (MyException e) {
            e.printStackTrace(System.out);
        }

        try {
            g();
        } catch (MyException e) {
            e.printStackTrace();
        }
    }
}
/**
输出
抛出 MyException 。
com.aibook.onjava.exceptions.MyException
	at com.aibook.onjava.exceptions.FullCOnstrctors.f(FullCOnstrctors.java:23)
	at com.aibook.onjava.exceptions.FullCOnstrctors.main(FullCOnstrctors.java:33)
抛出带参数的 MyException from g()
com.aibook.onjava.exceptions.MyException: 带参数的 Exception 来自 g()
	at com.aibook.onjava.exceptions.FullCOnstrctors.g(FullCOnstrctors.java:28)
	at com.aibook.onjava.exceptions.FullCOnstrctors.main(FullCOnstrctors.java:39)

*/
```

这里我注意到个有意思的小现象，当打印栈轨迹的时候，如果不传入输入流类型，默认使用 `System.err` 打印 可以看到 方法 `g()` 的错误打印日志是红色的，因为使用了默认的 `e.printStackTrace()`

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225145734.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225145655.png)



#### 异常与记录日志

> 你可能还想使用 `java.util.logging` 工具将输出记录到日志中。 基本的日志记录功能相当简单易懂：

```java
// LoggingException.java

class LoggingException extends Exception {
    private static Logger logger = Logger.getLogger("LoggingException");

    // 创建这个异常对象的时候会将栈轨迹打印
    public LoggingException() {
        StringWriter trace = new StringWriter();
        printStackTrace(new PrintWriter(trace));
        logger.severe(trace.toString());  // 将栈信息转为String并打印
    }
}

public class LoggingExceptions {
    public static void main(String[] args) {
        try {
            throw new LoggingException();
        } catch (LoggingException e) {
            System.err.println("Caught: " + e);
        }

        try {
            throw new LoggingException();
        } catch (LoggingException e) {
            System.err.println("Caught " + e);
        }
    }
}

/**
输出
二月 25, 2020 3:06:49 下午 com.aibook.onjava.exceptions.LoggingException <init>
严重: com.aibook.onjava.exceptions.LoggingException
	at com.aibook.onjava.exceptions.LoggingExceptions.main(LoggingExceptions.java:28)

Caught: com.aibook.onjava.exceptions.LoggingException
二月 25, 2020 3:06:49 下午 com.aibook.onjava.exceptions.LoggingException <init>
严重: com.aibook.onjava.exceptions.LoggingException
	at com.aibook.onjava.exceptions.LoggingExceptions.main(LoggingExceptions.java:34)

Caught com.aibook.onjava.exceptions.LoggingException

*/


```

【**这里我的程序的输出和作者Demo的输出是有差异的。因为操作系统的原因我这里显示的是中文 严重 ，作者的输出是 SEVERE 其实都一个意思**】



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225150755.png)



**【看一下作者对这段代码的说明：】**

> `Logger.getLogger()` 创建了一个 `String` 参数相关联的 `Logger` 对象

```java
// Logger.java

		@CallerSensitive
    public static Logger getLogger(String name) {

        return demandLogger(name, null, Reflection.getCallerClass());
    }

```

【我一般使用的都是 SLF4J 的日志，然后使用 Lombok 直接注入就行了，非常方便，但是我也一直好奇 SLF4J 和  JDK 中自带的日志是否存在关系，这块是一直以来比较疑惑的点，记下来，单独学习】

> 这个 `Logger` 对象会将其输出发送到 System.err。 向 Logger 写入的最简单的方式就是直接调用与日志记录消息的级别相关联的方法，这里的是  `servere()`。
>
> 为了产生日志记录消息，我们需要获取**异常抛出处的栈轨迹。**但是 printStackTrace() 不会默认的产生字符串。为了获取字符串，我们需要使用重载的 printStackTrace() 方法，它接收一个 **java.io.PrinterWriter** 对象作为参数。
>
> 然后通过调用 `toString()` 方法，就可以将输出抽取为一个 String。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225151915.png)



> 虽然上面的情形非常方便，异常被构造出来之后可以自动打印，但是更常见的情形是我们需要**捕获和记录其他人编写的异常**，因此我们必须在异常处理程序中生成日志消息：

```java
// LoggingExceptions2
public class LoggingExceptions2 {
    private static Logger logger = Logger.getLogger("LoggingExceptions2");

    // 这里作为一个异常的打印器
    static void logException(Exception e) {
        StringWriter trace = new StringWriter();
        e.printStackTrace(new PrintWriter(trace));
        logger.severe(trace.toString());
    }

    public static void main(String[] args) {
        try {
            throw new NullPointerException();
        } catch (NullPointerException e) {
            logException(e);
        }
    }
}
/**
输出
二月 25, 2020 3:24:25 下午 com.aibook.onjava.exceptions.LoggingExceptions2 logException
严重: java.lang.NullPointerException
	at com.aibook.onjava.exceptions.LoggingExceptions2.main(LoggingExceptions2.java:25)
*/
```

> 还可以进一步自定义异常，比如加入额外的构造器和成员：

```java
// ExtraFeatures.java
class MyException2 extends Exception {
    private int x;

    public MyException2() {
    }

    public MyException2(String message) {
        super(message);
    }

    public MyException2(String message, int x) {
        super(message);
        this.x = x;
    }

    public int val() {
        return x;
    }

    @Override
    public String getMessage() {
        return "Detail Message: " + x + " " + super.getMessage();
    }
}

public class ExtraFeatures {
    public static void f() throws MyException2 {
        System.out.println("Throwing MyException2 from f()");
        throw new MyException2();
    }

    public static void g() throws MyException2 {
        System.out.println("Throwing MyException2 from h()");
        throw new MyException2("Originated in g()");
    }

    public static void h() throws MyException2 {
        System.out.println("Throwing MyException2 from h()");
        throw new MyException2("Originated in h()", 47);
    }


    public static void main(String[] args) {
        try {
            f();
        } catch (MyException2 myException2) {
            myException2.printStackTrace(System.out);
        }

        try {
            g();
        } catch (MyException2 myException2) {
            myException2.printStackTrace(System.out);
        }

        try {
            h();
        } catch (MyException2 myException2) {
            myException2.printStackTrace(System.out);
            System.out.println("e.val() = " + myException2.val());
        }
    }
}

/**
输出
Throwing MyException2 from f()
com.aibook.onjava.exceptions.MyException2: Detail Message: 0 null
	at com.aibook.onjava.exceptions.ExtraFetures.f(ExtraFetures.java:38)
	at com.aibook.onjava.exceptions.ExtraFetures.main(ExtraFetures.java:54)
Throwing MyException2 from h()
com.aibook.onjava.exceptions.MyException2: Detail Message: 0 Originated in g()
	at com.aibook.onjava.exceptions.ExtraFetures.g(ExtraFetures.java:43)
	at com.aibook.onjava.exceptions.ExtraFetures.main(ExtraFetures.java:60)
Throwing MyException2 from h()
com.aibook.onjava.exceptions.MyException2: Detail Message: 47 Originated in h()
	at com.aibook.onjava.exceptions.ExtraFetures.h(ExtraFetures.java:48)
	at com.aibook.onjava.exceptions.ExtraFetures.main(ExtraFetures.java:66)
e.val() = 47

*/

```

这里覆写了 getMessage() 方法之后 打印异常时发生了对应的变化。

> **对于异常类来说，`getMessage()` 方法有点类似于 `toString()` 方法。**

【打印异常具体信息】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225153612.png)

> 异常可以继续增加很多增强的功能，但是程序包客户端程序员可能仅仅查看一下抛出的异常类型，所以对异常添加其他的功能可能也许根本用不上。

### 异常声明

如果方法可能抛出异常，需要在方法后使用 `throws` 标注可能抛出的异常类型的列表

```java
void f() throws TooBig, TooSmall, DivZero { // ...
```

如果不这样写，就代表此方法不会抛出受检查类型的异常

【运行时异常随时可能抛出】

```java
void f() { // ...
```



> **可以声明方法将抛出异常，但是实际并不抛出，为以后准备抛出的异常占位。**



### 捕获所有异常

异常捕获时存在父子关系，可以只写一个异常处理程序来捕获所有类型的异常。

```java
catch(Exception e) { // 可以捕获任何继承 Exception 类的异常
    System.out.println("Caught an exception");
}
```

> Exception 不会包含太多具体的信息，但是可以调用继承自 Throwable 的方法获取详细信息：
>
> `String getMessage()`
>
> `String getLocalizedMessage()`

返回对 Throwable 的简单描述，要是有详细信息的话，也会把它包含在内。

```java
void printStackTrace()
void printStackTrace(PrintStream)
void printStackTrace(java.io.PrintWriter)
```

用来获取详细信息，或者使用本地语言表示的详细信息：

```java
String toString()
```



打印 Throwable 和 Throwable 调用栈轨迹显示了异常抛出地点的方法调用序列。

其中第一个版本输出到标准错误，后两个版本允许要选择的输出流（在[附录 I/O 流 ](https://lingcoder.github.io/OnJava8/#/)中，你将会理解为什么有两种不同的流）。

```java
Throwable fillInStackTrace()
```

> 用于重新记住对象内部栈桢状态，这再程序重新抛出错误或异常时很有用。
>
> 对于异常来说 `getClass().getSimpleName()` 也是个好方法

```java
// ExceptionMethods.java

public class ExceptionMethods {
    public static void main(String[] args) {
        try {
            throw new Exception("My Exception");
        } catch (Exception e) {
            System.out.println("Caught Exception");
            System.out.println("Get Message : " + e.getMessage());
            System.out.println("getLOcalizedMessage(): " + e.getLocalizedMessage());
            System.out.println("to String() " + e);
            System.out.println("打印堆栈信息: ");
            e.printStackTrace(System.out);
        }
    }
}
/**
输出
Caught Exception
getMessage():My Exception
getLocalizedMessage():My Exception
toString():java.lang.Exception: My Exception
printStackTrace():
java.lang.Exception: My Exception
at
ExceptionMethods.main(ExceptionMethods.java:7)
*/
```

> 可以发现每个方法都比前一个提供了更多的信息 —— 它们每个都是前一个的超集。



#### 多重捕获

**【Java 7 之前如果一组异常没有相同的基类 需要一个个单独编写 catch 语句：】**

```java
public class SameHandler {
    void x() throws Except1, Except2, Except3, Except4 {}
    void process() {}
    void f() {
        try {
            x();
        } catch(Except1 e) {
            process();
        } catch(Except2 e) {
            process();
        } catch(Except3 e) {
            process();
        } catch(Except4 e) {
            process();
        }
    }
}
```



**【Java 7增加了多重捕获语句，可以将不同类型的异常进行组合捕获：】**

```java
// exceptions/MultiCatch.java
public class MultiCatch {
    void x() throws Except1, Except2, Except3, Except4 {}
    void process() {}
    void f() {
        try {
            x();

        } catch(Except1 | Except2 | Except3 | Except4 e) {
            process();
        }
    }
}
```

或

```java
// exceptions/MultiCatch2.java
public class MultiCatch2 {
    void x() throws Except1, Except2, Except3, Except4 {}
    void process1() {}
    void process2() {}
    void f() {
        try {
            x();
        } catch(Except1 | Except2 e) {
            process1();
        } catch(Except3 | Except4 e) {
            process2();
        }
    }
}
```



#### 栈轨迹

> printStackTrace() 方法提供的信息可以通过 getStackTrace() 方法直接访问。
>
> 这个方法将返回一个由栈轨迹中的元素构成的数组，每个元素都表示栈中的一帧，元素0 是栈顶元素，并且是调用序列的最后一个方法调用（这个 Throwable 被创建和抛出之处）。
>
> 数组中的最后一个元素和栈底是调用序列中的第一个方法调用：

【也就是阅读异常的时候通常跟你的异常有关的信息都在下面】

```java
// WhoCalled.java

public class WhoCalled {
    static void f() {
        try {
            throw new Exception();
            //
        } catch (Exception e) {
            System.out.println("开始打印f栈桢");
            // 打印栈桢元素
            for (StackTraceElement ste : e.getStackTrace()) {
                System.out.println(ste.getMethodName());
            }
        }
    }

    static void g() {
        System.out.println("我是 g() 我调用了 f()");
        f();
    }

    static void h() {
        g();
        System.out.println("我是 h() 我调用了 g()");
    }

    public static void main(String[] args) {
        System.out.println("-------------- f() --------------");
        f();
        System.out.println("---------------");

        System.out.println("-------------- g() --------------");
        g();
        System.out.println("---------------");

        System.out.println("-------------- h() --------------");
        h();
        System.out.println("---------------");
    }
}
/**
输出
-------------- f() --------------
开始打印f栈桢
f
main
---------------
-------------- g() --------------
我是 g() 我调用了 f()
开始打印f栈桢
f
g
main
---------------
-------------- h() --------------
我是 g() 我调用了 f()
开始打印f栈桢
f
g
h
main
我是 h() 我调用了 g()
---------------

*/

```

**这里可以看到，调用顺序和打印顺序是相反的，调用是从 main() 开始，而打印中 main() 方法最后被打印，这就是栈的数据结构特性。先进后出**

#### 重新抛出异常

在 catch 块中我们可能无法完成对异常的处理，需要将异常抛给更上层的调用者：

```java
catch(Exception e) {
    System.out.println("我打印一下异常，然后将其重新抛出" + e.getMessage());
    throw e;
}
```

> 重新抛出异常后 同一个 try 块的后续 catch 子句将被忽略。
> 此外异常对象的所有信息都会被保持。所以高一级环境中捕获的异常处理程序可以获得该异常中所有完整的信息。
>
> 如果只是重新抛出，那么栈轨迹记录的还是之前的轨迹，并非根据重新抛出点刷新信息，如果想要更新栈轨迹信息，可以调用 `fillInStackTrace() 方法`，这将返回一个 `Throwable` 对象，**它将当前调用栈的信息填入之前被捕获的异常对象：**

```java
	// Rethrowing.java
public class Rethrowing {
    public static void f() throws Exception {
        System.out.println("我是 ： f() 抛出的异常");
        throw new Exception("throw from f()");
    }

    public static void g() throws Exception {
        try {
            f();
        } catch (Exception e) {
            System.out.println("g 捕获了 f() 抛出的异常，打印其异常栈桢信息: ");
            e.printStackTrace(System.out);
            System.out.println("栈桢打印完毕，g() 重新抛出 f() 的异常");
            throw e;
        }
    }

    public static void h() throws Exception {
        try {
            f();
        } catch (Exception e) {
            System.out.println("h 捕获了 f() 抛出的异常，打印其异常栈桢信息: ");
            e.printStackTrace(System.out);
            System.out.println("栈桢打印完毕，h重新装填 f()异常 的栈桢信息");

            throw (Exception) e.fillInStackTrace();
        }
    }

    public static void main(String[] args) {
        try {
            g();
        } catch (Exception e) {
            System.out.println("Main方法打印 g() 的栈桢");
            e.printStackTrace(System.out);
        }
        try {
            h();
        } catch (Exception e) {
            System.out.println("Main方法打印 H(） 的栈桢信息");
            e.printStackTrace(System.out);
        }
    }
}
/**
输出
我是 ： f() 抛出的异常
g 捕获了 f() 抛出的异常，打印其异常栈桢信息: 
java.lang.Exception: throw from f()
	at com.aibook.onjava.exceptions.Rethrowing.f(Rethrowing.java:13)
	at com.aibook.onjava.exceptions.Rethrowing.g(Rethrowing.java:18)
	at com.aibook.onjava.exceptions.Rethrowing.main(Rethrowing.java:41)
栈桢打印完毕，g() 重新抛出 f() 的异常
Main方法打印 g() 的栈桢
java.lang.Exception: throw from f()
	at com.aibook.onjava.exceptions.Rethrowing.f(Rethrowing.java:13)
	at com.aibook.onjava.exceptions.Rethrowing.g(Rethrowing.java:18)
	at com.aibook.onjava.exceptions.Rethrowing.main(Rethrowing.java:41)
我是 ： f() 抛出的异常
h 捕获了 f() 抛出的异常，打印其异常栈桢信息: 
java.lang.Exception: throw from f()
	at com.aibook.onjava.exceptions.Rethrowing.f(Rethrowing.java:13)
	at com.aibook.onjava.exceptions.Rethrowing.h(Rethrowing.java:29)
	at com.aibook.onjava.exceptions.Rethrowing.main(Rethrowing.java:47)
栈桢打印完毕，h重新装填 f()异常 的栈桢信息
Main方法打印 H(） 的栈桢信息
java.lang.Exception: throw from f()
	at com.aibook.onjava.exceptions.Rethrowing.h(Rethrowing.java:35)
	at com.aibook.onjava.exceptions.Rethrowing.main(Rethrowing.java:47)

*/
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225162554.png)

> 调用 fillInStackTrace() 那一行就变成了新的异常发生地，所以 f() 方法栈消失了。
>
> 有可能在捕获异常之后抛出另外一种异常，这么做的话，效果类似使用 fillInStackTrace()。
> 原来异常的发生点的信息会丢失，剩下的是与新的抛出点有关的信息：

```java
// RethrowNew.java

class OneException extends Exception {
    public OneException(String message) {
        super(message);
    }
}

class TwoException extends Exception {
    public TwoException(String message) {
        super(message);
    }
}


public class RethrowNew {
    public static void f() throws OneException {
        System.out.println("f()抛出 OneException");
        throw new OneException("来自f()的异常对象");
    }

    public static void main(String[] args) {
        try {
            f();
        } catch (OneException e) {
            System.out.println("f()的异常对象被捕获，并打印其栈桢信息");
            e.printStackTrace(System.out);
            System.out.println("抛出新的异常对象 TwoException");
            try {
                throw new TwoException("在 Catch 语句中重新抛出的异常对象 TwoException ");
            } catch (TwoException ex) {
                System.out.println("捕获 Two Exception 异常对象，并打印其栈桢");
                ex.printStackTrace(System.out);
            }
        }
    }

}
/**
输出
f()抛出 OneException
f()的异常对象被捕获，并打印其栈桢信息
com.aibook.onjava.exceptions.OneException: 来自f()的异常对象
	at com.aibook.onjava.exceptions.RethrowNew.f(RethrowNew.java:26)
	at com.aibook.onjava.exceptions.RethrowNew.main(RethrowNew.java:31)
抛出新的异常对象 TwoException
捕获 Two Exception 异常对象，并打印其栈桢
com.aibook.onjava.exceptions.TwoException: 在 Catch 语句中重新抛出的异常对象 TwoException 
	at com.aibook.onjava.exceptions.RethrowNew.main(RethrowNew.java:37)
*/
```

可以看到重新抛出的异常对象的栈桢只有 main 而对 f() 一无所知。

永远不必为异常对象的清理而担心，因为异常对象也是在 堆上创建的，所以垃圾回收器会自动清理这些对象。

#### 精准的重新抛出异常

> Java 7之前，如果遇到异常，则**只能重新抛出该类型的异常。**这导致在 Java7 中修复的代码不精确，所以在 Java 7 中这无法编译

```java
// PreciseRethrow.java
class BaseException extends Exception {}
class DerivedException extends BaseException {}
public class PreciseRethrow {
    void catcher() throws DerivedException {
        try {
            throw new DerivedException();
        } catch (BaseException e) {
            throw e;
        }
    }
}
```



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225175324.png)

将语言等级调为6 抛出异常。

> catch 捕获了一个 BaseException，所以编译器强迫你抛出 BaseException，哪怕抛出的是其子类也会抛出错误。 
>
> 从 Java7 开始这段代码可以编译，这是一个很小但很有用的修复。

#### 异常链

> 如果想在捕获一个异常后抛出另一个异常，并将原始的异常信息保存下来，这被称为异常链。
>
> 在 JDK 1.4 之前，程序员必须自己编写代码来保存原始异常的信息。
>
> 现在所有 Throwable 的子类在构造器中都可以接受一个 cause 对象作为参数。 这个对象就表示原始异常。也能通过这个异常链追踪到异常最初发生的位置。
>
> 在 Throwable 的子类中，只有三种基本异常类提供了带 cause 参数的构造器：
>
> - **Error**
> - **Exception**
> - **RuntimeException**
>
> **如果需要把其他类型的异常链接起来，应该使用 InitCause0() 而不是构造器。**

```java
// DynamicFields.java
// 这个例子挺有意思的，不过挺长

class DynamicFieldsException extends Exception {
}

public class DynamicFields {
    // 一个存储信息的二维数组
    private Object[][] fields;

    // 初始化 二维数组，第二维只包含2个元素
    public DynamicFields(int initiaSize) {
        fields = new Object[initiaSize][2];
        for (int i = 0; i < initiaSize; i++) {
            fields[i] = new Object[]{null, null};
        }
    }

    // 打印数组中的元素
    @Override
    public String toString() {
        StringBuilder result = new StringBuilder();
        for (Object[] obj : fields) {
            result.append(obj[0]);
            result.append(": ");
            result.append(obj[1]);
            result.append("\n");

        }
        return result.toString();
    }

    // 判断数组中是否包含传入的值 返回-1表示不包含
    private int hasField(String id) {
        for (int i = 0; i < fields.length; i++) {
            if (id.equals(fields[i][0])) {
                return i;
            }
        }
        return -1;
    }

    // 调用判断是否包含对应元素的方法，如果返回-1抛出异常
    private int getFieldNumber(String id) throws NoSuchFieldException {
        int fieldNum = hasField(id);
        if (fieldNum == -1) {
            throw new NoSuchFieldException();
        }
        return fieldNum;
    }

    // 遍历 fields 如果二维数组的第一个元素为空，则将传入id赋值给第一个元素并返回
    private int makeField(String id) {
        for (int i = 0; i < fields.length; i++) {
            if (fields[i][0] == null) {
                fields[i][0] = id;
                return i;
            }
        }
        // 如果不为空，则将id放入第二个元素中
        // No Empty Fields . Add One
        // 创建一个新的临时数组，其维度比 fields 的第一个元素长度大1
        Object[][] tmp = new Object[fields.length + 1][2];
        // 遍历 fields 给 tmp 临时数组赋值
        for (int i = 0; i < fields.length; i++) {
            tmp[i] = fields[i];
        }

        // 将tmp 比 fields 长的那个两个元素的数组初始化
        for (int i = fields.length; i < tmp.length; i++) {
            tmp[i] = new Object[]{null, null};
        }
        // 将临时数组赋值给fields 赋值完成
        fields = tmp;
        // 具有扩展字段的递归调用 将id赋值给刚才拓展的那个二维数组的第一个元素
        return makeField(id);
    }


    // 获得二维数组的第一个元素
    public Object getField(String id) throws NoSuchFieldException {
        return fields[getFieldNumber(id)][1];
    }

    // 异常链的
    public Object setField(String id, Object value) throws DynamicFieldsException {
        if (value == null) {
            System.out.println("入参 value 为 null，抛出异常。");
            // Most exceptions don't have a "cause"
            // constructor. In these cases you must use
            // initCause(), available in all
            // Throwable subclasses.
            DynamicFieldsException dfe = new DynamicFieldsException();
            dfe.initCause(new NullPointerException());
            throw dfe;
        }
        int fieldNumber = hasField(id);
        if (fieldNumber == -1) {
            fieldNumber = makeField(id);
        }
        Object result = null;

        try {
            result = getField(id); // Get Old Value
        } catch (NoSuchFieldException e) {
            // Use constructor that takes "cause": 异常链的调用，将 NosuchFieldException 转为 Runtime Exception
            throw new RuntimeException(e);
        }
        // 数组赋值
        fields[fieldNumber][1] = value;
        return result;
    }

    public static void main(String[] args) {
        // 生成一个 Object[3][2] 的二维数组
        DynamicFields df = new DynamicFields(3);

        System.out.println(df);

        try {
            df.setField("d", "A value for d");
            df.setField("number", 47);
            df.setField("number2", 48);
            System.out.println(df);
            df.setField("d", "A new Value for d");
            df.setField("number3", 11);
            System.out.println("df: " + df);
            System.out.println("df.getFiled(\"d\") : " + df.getField("d"));

            Object d = df.setField("d", null);

        } catch (DynamicFieldsException | NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}
/**
输出
null: null
null: null
null: null

d: A value for d
number: 47
number2: 48

df: d: A new Value for d
number: 47
number2: 48
number3: 11

df.getFiled("d") : A new Value for d
入参 value 为 null，抛出异常。
com.aibook.onjava.exceptions.DynamicFieldsException
	at com.aibook.onjava.exceptions.DynamicFields.setField(DynamicFields.java:99)
	at com.aibook.onjava.exceptions.DynamicFields.main(DynamicFields.java:136)
	// 看这里，异常链 
Caused by: java.lang.NullPointerException
	at com.aibook.onjava.exceptions.DynamicFields.setField(DynamicFields.java:100)
	... 1 more
*/
```



> 调用 `setField()` 方法的时候回，如果试图设置一个字段为空值，那么将抛出一个 `DynamicFieldsException` 异常，它是通过 `initCause()` 方法把 NUllPointerException 对象插入而创建的。
>
> 如果调用 setField 的时候传入的参数为 null，这种情况被视为运行时错误，所以使用接受 cause 参数的构造器把 **NoSuchFieldException** 转换为 **RuntimeExcetpion** 异常。
>
> 异常链的应用主要就在这里。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225183821.png)

```java
// Throwable.java

		public synchronized Throwable initCause(Throwable cause) {
        if (this.cause != this)
            throw new IllegalStateException("Can't overwrite cause with " +
                                            Objects.toString(cause, "a null"), this);
        if (cause == this)
            throw new IllegalArgumentException("Self-causation not permitted", this);
        this.cause = cause;
        return this;
    }
```


