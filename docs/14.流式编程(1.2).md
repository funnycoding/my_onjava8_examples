---
layout: post
title: 《On Java8》第十四章——流式编程(1.2) —— 流创建 
date: 2020-02-20
tags:
- 读书笔记
categories: 
- 《On Java8》
---


#### int 类型的范围

> `IntStream` 类提供了 `range()` 方法用于生成整形序列的流。编写循环时使用这个会更方便：

<!-- more -->	

```java
// Ranges.java
public class Ranges {
    public static void main(String[] args) {
        // 传统方法生成整数序列
        int result = 0;
        for (int i = 10; i < 20; i++) {
            result += i;
        }
        System.out.println(result);

        // for-in  遍历流生成的数组 
        result = 0;
        for (int i : IntStream.range(10, 20).toArray()) {
            result += i;
        }
        System.out.println(result);

        // 使用流直接进行计算
        System.out.println(IntStream.range(10,20).sum());
    }
}


/**
输出
145
145
145
*/
```

> **第一种方式是传统的 for 循环**
>
> **第二种使用 range 创建流并转为数组同时使用 for-in 语法遍历**
>
> **第三种使用 `sum()`在流中直接进行求和操作。**
>
> **实用小功能 `repeat()` 可以用来替换简单的 `for`循环：**

```java
//Repeat.java
public class Repeat {
    public static void repeat(int n, Runnable action) {
        IntStream.range(0,n).forEach(i -> action.run());
    }
  	
  // 作为对比的传统循环
   public static void repeat2(int n, Runnable action) {
        for (int i = 0; i < n; i++) {
            action.run();
        }
    }
}

```

```java
public class Looping {
    static void hi() {
        System.out.println("Hi!");
    }

    public static void main(String[] args) {
        Repeat.repeat(3,()-> System.out.println("Looping!~"));
        Repeat.repeat(2,Looping::hi);

    }
}
/*
输出
Looping!
Looping!
Looping!
Hi!
Hi!
*/
```

> 原则上，在代码中包含并解释 `repeat()`并不值得。诚然它是一个相当透明的工具，但是结果取决于你的团队和公司的运作方式

**【也就是这么写代码没啥意义？不太明白这里作者想表达什么意思】**



#### generator()

> 参照 `RandomWords.java` 中的 `Stream.generate()` 搭配 `Supplier<T>` 使用的例子：

```java
// Generator.java
public class Generator implements Supplier<String> {
    Random rand = new Random(47);
    char[] letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    int i = 0;

    // 这个 get 是在什么时候被调用的呢？
    public String get() {
        System.out.println("get 被调用了" + i);
        i++;
        return "" + letters[rand.nextInt(letters.length)];
    }

    public static void main(String[] args) {
        String word = Stream.generate(new Generator())
                .limit(30)
                .collect(Collectors.joining());
        System.out.println(word);
    }
}

/**
输出
YNZBRNYGCFOWZNTCQRGSEGZMMJMROE
*/
```

【这里我的问题是 `get()` 是什么时候被调用的呢？ 还是对内置的函数接口不太熟】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200302222200.png)

【Debug 看方法栈可以看到 在 tryAdvance() 中调用了 `supplier.get()`】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200302222237.png)

> 使用 `Random.nextInt()` 方法来挑选字母表中的大写字母。
>
> `Random.nextInt()`的参数代表可以接受的最大随机数范围，**所以使用数组的边界是经过深思熟虑的。**
>
> **要创建包含相同对象的流，只需要传递一个生成那些对象的 `lambda` 到 `generate()` 中：**

```java
// Duplicator.java
public class Duplicator {
    public static void main(String[] args) {
        Stream.generate(()->"duplicate")
                .limit(3) // 这里如果把limit 改为10 就会输出10个
                .forEach(System.out::println);
    }
}
/**
输出
duplicate
duplicate
duplicate
*/
```

**【这个例子很好懂，生成一个流，并打印其中前三个元素】**

看完这个例子应该对 "流" 这个概念有了更深刻的了，流本身是没有长度的，当 调用 limit 的时候，有一个限制，不能超过最大长度，除此之外，流是没有具体长度的。

```java
// Stream.java
Stream<T> limit(long maxSize);
```



> 如下是在本章之前例子中使用过的 `Bubble` 类。注意它包含了自己的静态生成器（Static generator) 方法。

```java
// streams/Bubble.java
// 这个类在之前使用的时候已经放在代码里了。
import java.util.function.*;
public class Bubble {
    public final int i;

    public Bubble(int n) {
        i = n;
    }

    @Override
    public String toString() {
        return "Bubble(" + i + ")";
    }

    private static int count = 0;
    public static Bubble bubbler() {
        return new Bubble(count++);
    }
}
```

> 由于 `bubbler()` 与 `Supplier<Bubble>`是接口兼容的，我们可以将其方法引用直接传递给 `Stream.generator()`:

【这里说 `bubbler()` 与 `Supplier<Bubble>`是接口兼容的 是因为 Supplier 的get 方法是返回类泛型参数的无参方法吧】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200221140151.png)



```java
// streams/Bubbles.java
import java.util.stream.*;
public class Bubbles {
  // 生成5个 Bubble 对象，并调用其 toString 方法，打印 Bubble + i
    public static void main(String[] args) {
        Stream.generate(Bubble::bubbler)
              .limit(5)
              .forEach(System.out::println);
    }
}

/**输出
Bubble(0)
Bubble(1)
Bubble(2)
Bubble(3)
Bubble(4)
*/
```

> 这是**创建单独工厂类**（Separate Factory class） 的另一种方式。
>
> 在很多方面它更加整洁，但是这是一个对哦与代码组织和不同品味的问题—你总是可创建一个完全不同的工厂类。

【使用Stream的语法创建 Bubble对象】

#### iterate()

```java
// Stream.java

		public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {
        Objects.requireNonNull(f);
        final Iterator<T> iterator = new Iterator<T>() {
            @SuppressWarnings("unchecked")
            T t = (T) Streams.NONE;

            @Override
            public boolean hasNext() {
                return true;
            }

            @Override
            public T next() {
                return t = (t == Streams.NONE) ? seed : f.apply(t);
            }
        };
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
                iterator,
                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);
    }

```



> `Stream.iterate()` 以种子（第一个参数）开头，并将其传给第方法(第二个参数)。
>
> 方法的结果将添加到流，并存储作为第一个参数用于下次调用 `iterate()`，**以此类推我们可以利用 `iterate()` 生成一个 斐波那契额数列**

```java
// Fibonacci.java
public class Fibonacci {
    int x = 1;
    Stream<Integer> numbers() {
        return Stream.iterate(0, i -> {
            int result = x + i;
            x = i;
            return result;
        });
    }

    public static void main(String[] args) {
        new Fibonacci().numbers()
                .skip(20) // 跳过前20个
                .limit(10) // 然后取前10个
                .forEach(System.out::println);
    }
}
/**
输出
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
*/
```

**【这里我增加输出之后的，可以很清晰的看到 iterate 的入参是上次返回的 result。】**

```java
// Fibonacci.java
public class Fibonacci {
    int x = 1;
    Stream<Integer> numbers() {
        return Stream.iterate(0, i -> {
            int result = x + i;
            System.out.println("i numbers: " + i + "result : " + result);
            x = i;
            return result;
        });
    }

    public static void main(String[] args) {
        new Fibonacci().numbers()
                //.skip(20) // 跳过前20个
                .limit(10) // 然后取前10个
                .forEach(System.out::println);
    }
}
/**
输出
0
i numbers: 0result : 1
1
i numbers: 1result : 1
1
i numbers: 1result : 2
2
i numbers: 2result : 3
3
i numbers: 3result : 5
5
i numbers: 5result : 8
8
i numbers: 8result : 13
13
i numbers: 13result : 21
21
i numbers: 21result : 34
34
*/
```





> 斐波那契额数列：将数列中最后两个元素进行求和产生下一个元素**。
>
> `iterate()` 只能记忆结果，因此我们需要变量 `x` 追踪另一个元素。
>
> 在主方法中，我们使用了 `skip()`操作它根据参数丢弃指定数量的元素。

```java
// ReferencePipeline.java
// skip() 函数的源码

	@Override
    public final Stream<P_OUT> skip(long n) {
        if (n < 0)
            throw new IllegalArgumentException(Long.toString(n));
        if (n == 0)
            return this;
        else
            return SliceOps.makeRef(this, n, -1);
    }
```



#### 流的建造者模式

> 在**建造者设计模式**（也叫**构造器设计模式**）中，首先创建一个 `builder`对象，传递给它多个构造器信息，最后执行**构造**。 **Stream**库提供了这样的 `Builder`。
>
> 这里，我们重新审视文件读取并将其转换为单词流的过程：

```java
// FileToWordsBuilder.java
public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream.builder();

    // 当 Stream 真正被构件时该标志位被设置为 true.
    boolean isStreamBuild = false;

    public FileToWordsBuilder(String filePath) throws IOException {
        Files.lines(Paths.get(filePath))
                .skip(1) // 跳过开头行
                .forEach(line -> {
                    for (String w : line.split("[ .?,]+")) { // 这里的正则是以空格开头的
                        builder.add(w);
                    }
                });
    }

    // 手动向 Builder中添加单词的方法
    public void addToBuilder(String words) {
        builder.add(words);
    }



    // 构造一个Stream
    Stream<String> stream() {
        isStreamBuild = true;
        return builder.build();
    }

    public static void main(String[] args) throws IOException {
        FileToWordsBuilder fileToWordsBuilder = new FileToWordsBuilder("Cheese.dat");
        fileToWordsBuilder.addToBuilder("手动添加一哈");
        Stream<String> stream = fileToWordsBuilder
                .stream();
        //fileToWordsBuilder.addToBuilder("Builder被构建为 Stream之后再添加点元素进去"); // 当Builder 已经被构建时再调用 add()会导致异常
        stream
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
输出
Not much of a cheese shop really is it Finest in the district sir And what leads you to that conclusion Well it's so clean It's certainly uncontaminated by cheese 手动添加一哈 
*/
```

> **注意**，构造器会添加文件中的所有单词（除了第一行，它是包含文件路径信息的注释），但是其并没有调用 `builder()`。只要你不调用 `stream()` 方法，就可以继续向 `builder` 对象中添加单词。
>
> 在该类的更完整形式中，**你可以添加一个标志位** 用于查看 `builder`是否被调用，并且可能的话增加一个可以添加更多单词的方法。
>
> 在 `Stream.Builder` 调用 `builder()`方法后继续尝试添加单词会产生一个异常。

```java
// 完整版 FileToWordsBuilder.java 我添加了上面书上说的两个实验

// FileToWordsBuilder.java
public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream.builder();

    // 当 Stream 真正被构件时该标志位被设置为 true.
    boolean isStreamBuild = false;

    public FileToWordsBuilder(String filePath) throws IOException {
        Files.lines(Paths.get(filePath))
                .skip(1) // 跳过开头行
                .forEach(line -> {
                    for (String w : line.split("[ .?,]+")) { // 这里的正则是以空格开头的
                        builder.add(w);
                    }
                });
    }

    // 手动向 Builder中添加单词的方法
    public void addToBuilder(String words) {
        builder.add(words);
    }



    // 构造一个Stream
    Stream<String> stream() {
        isStreamBuild = true;
        return builder.build();
    }

    public static void main(String[] args) throws IOException {
        FileToWordsBuilder fileToWordsBuilder = new FileToWordsBuilder("Cheese.dat");
        fileToWordsBuilder.addToBuilder("手动添加一个单词");
        Stream<String> stream = fileToWordsBuilder
                .stream();
        fileToWordsBuilder.addToBuilder("当Builder 已经被构建时再调用 add()会导致异常");
        stream
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
Exception in thread "main" java.lang.IllegalStateException
	at java.util.stream.Streams$StreamBuilderImpl.accept(Streams.java:373)
	at java.util.stream.Streams$StreamBuilderImpl.add(Streams.java:378)
	at com.aibook.onjava.streams.FileToWordsBuilder.addToBuilderAfterBuild(FileToWordsBuilder.java:39)
	at com.aibook.onjava.streams.FileToWordsBuilder.main(FileToWordsBuilder.java:55)
	*/

```

#### Arrays

> `Arrays` 类中含有一个名为 `stream()`的静态方法，用于把数组转换称为流。
>
> 我们可以重写 `interfaces/Machine.java` 中的主方法用于创建一个流，并将 `execute()` 应用于每一个元素:

```java

public class Machine2 {
    public static void main(String[] args) {
        Arrays.stream(new Operations[]{
                () -> Operations.show("Bing"),
                () -> Operations.show("Crack"),
                () -> Operations.show("Twist"),
                () -> Operations.show("Pop"),
        }).forEach(Operations::execute);
    }
}

/**
输出
Bing
Crack
Twist
Pop
*/
// 这里 Operations 的代码是第十章的，一并放这:
public interface Operations {
    void execute();


    static void runOps(Operations... ops) {
        for (Operations o : ops) {
            o.execute();
        }
    }

    static void show(String msg) {
        System.out.println(msg);
    }

}
```

> `new Operations[]` 动态创建了 `Operation` 对象的的数组
>
> `stream` 同样可以产生 IntStream,LongStream和 DoubleStream

【也就是说存在基础类型的包装器类的流】

```java
// ArrayStreams.java

public class ArrayStreams {
    public static void main(String[] args) {
        Arrays.stream(new double[] {3.14159,2.718,1.618})
                .forEach( n -> System.out.format("%f ",n));
        System.out.println();

        Arrays.stream(new int[]{1,3,5})
                .forEach(n->System.out.format("%d",n));
        System.out.println();

        Arrays.stream(new long[] { 11, 22, 44, 66 })
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        // 选择一个子域 [3,6]
        Arrays.stream(new int[]  { 1, 3, 5, 7, 15, 28, 37 },3,6)
                .forEach(n -> System.out.format("%d ",n));

    }
}

/**
输出
3.141590 2.718000 1.618000 
135
11 22 44 66 
7 15 28 
*/
```

**【最后一个Stream增加了range范围，这里是闭合区间。】**



#### 正则表达式

> Javae 的正则会在 字符串一张详细介绍。
>
> Java 8在 `java.util.regex.Pattern` 中增加了一个新的方法 `splitStream()`。 这个方法可以根据传入的公式将字符序列转化为流。
>
> **但是有一个限制，输入只能是 CharSequence，因此不能讲流作为 `splitAsStream()` 的参数**

> 再次查看将文件处理为单词刘的过程。这一次，我们使用流将文件分割为单独的字符串，接着使用正则表达式将字符串转为单词流。

```java
// FileToWordsRegexp.java

public class FileToWordsRegexp {
    private String all;

    // 读取文件内容
    public FileToWordsRegexp(String filePath) throws Exception {
        all = Files.lines(Paths.get(filePath))
                .skip(1) // First (comment) line
                .collect(Collectors.joining(" "));
    }
		// 将字符串转化为流
    public Stream<String> stream() {
        return Pattern.compile("[ .,?]+").splitAsStream(all);
    }

    public static void main(String[] args) throws Exception {
        FileToWordsRegexp fw = new FileToWordsRegexp(
                "/Users/xuyanxin/Documents/xu-self-project/aibook/aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat");
        fw.stream()
                .limit(7)
                .map(w -> w + " ")
                .forEach(System.out::print);
      
      // 再次调用 stream,往String中添加后2个单词
        fw.stream()
                .skip(7)
                .limit(2)
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
输出
Not much of a cheese shop really is it
*/
```

> 在构造器中我们读取了文件中的所有内容。（跳过第一行）
>
> 现在，当你调用 stream() 的时候，可以像往常一样获取一个流，但是现在可以多次调用 stream()  在已存储的字符串中创建一个新的流。
>
> 但是这里有个限制：整个文件必须存储在内存中【因为读取到了String里】，在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：
>
> 1. 流"不需要存储"。流需要一些内部存储，但是只是序列的一小部分，和持有整个序列不同。
> 2. 流是懒加载计算的。
>
> 幸运的是稍后就会知道如何解决这个问题。



### 小结：

本章主要讲了各种情况下对流的创建。

首先 Collection 支持了返回流的接口默认方法，Arrays 也支持了 int ,double ,long 的流的创建，Random 随机数类支持了返回流的形式。

还使用了Stream中的 建造者模式 Builder。

以及接触了 Stream中的 一些基本的Api 比如 `range()`,`Stream.generator()`,

`Stream.iterate()` ,`Stream.skip()`，一些基础的流的操作。





### 参考：

[命令式编程（Imperative） vs声明式编程（ Declarative）](https://zhuanlan.zhihu.com/p/34445114)

[Java Stream API 进阶篇](https://www.cnblogs.com/CarpenterLee/p/6550212.html)  —对各个Stream的API 的分析很清晰。



