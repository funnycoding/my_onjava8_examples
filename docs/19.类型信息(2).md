---
layout: post
title: 《On Java8》第十九章——RTTI(2)
date: 2020-02-28
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### 类型转换检测

> 直到现在，我们已知的 RTTI 类型包括：
>
> 1. **传统的类型转**换。如 `Shape s =  (Shape) Object;` 如果出错会抛出 `ClassCastException` 异常。
> 2. 代表对象类型的 `Class` 对象。通过 `Class` 对象可以获取运行时信息。

<!-- more -->	

> 在C++中，经典的类型转换并不实用 RTTI。 它只是简单地告诉编译器将整个对象作为新的类型对待。而 Java 会进行**类型检查**，这种类型检查一般被称为**类型安全的向下转**型。
>
> 之所以称为向下转型是因为看类图可以得知，Circle 肯定是一个 Shape（子类可以看作父类）所以向上转型不需要显示的转型操作。
>
> 但是当你将父类引用转为子类对象的时候，编译器并不知道该引用具体指向的是什么类型的子类对象，可能是 Circle 也可能是 Square。在编译期间，编译器只能知道这是一个 Shape。因此，**向下转型需要显示地进行类型转换。**
>
> RTTI 在 Java 中还有第三种形式，关键字：`instanceof`。使用这个关键字组成的表达式返回一个布尔值，告诉我们某个对象是不是特定类型的实例。

```java
if(x instanceof Dog){
    ((Dog)x).bark();
  }
```

> 在将 `x` 转为 `Dog` 之前，`if` 语句会根据 表达式 `x instanceof Dog` 的结果判断是否进入后续代码块。
>
> 在进行向下转型前，使用 `instanceof` 是非常重要的，它避免了发生 `ClassCastException` 异常。

> 加入你想查找某种类型（比如如果是三角形，就填充为紫色）这时可以轻松使用 `instanceof` 来度量所有对象。
>
> 举个例子，假如你有一个类的继承体系，描述了 `Pet` 以及它们的主任。在这个体系中每个 `Individual` 都有一个 `id` 和可选的名字。 尽管下面的类都继承自 `Individual`，但是 `Individual` 类的复杂性较高，所以将其代码放在 附录：容器 中进行说明。
>
> 此处不需要去了解 `Individual` 的代码，你只需要了解你快要创建其具名或不具名的对象，并且每个 `Individual`  都有一个 `id()` 方法，如果你没有为其提供名字，`toString()` 只产生 类型名。、

**下面是继承 Individual 类的继承体系 ：**

```java
// typeinfo/pets/Person.java
package typeinfo.pets;

public class Person extends Individual {
    public Person(String name) { super(name); }
}
```

```java
// typeinfo/pets/Pet.java
package typeinfo.pets;

public class Pet extends Individual {
    public Pet(String name) { super(name); }
    public Pet() { super(); }
}
```

```java
// typeinfo/pets/Dog.java
package typeinfo.pets;

public class Dog extends Pet {
    public Dog(String name) { super(name); }
    public Dog() { super(); }
}
```



```java
// typeinfo/pets/Mutt.java
package typeinfo.pets;

public class Mutt extends Dog {
    public Mutt(String name) { super(name); }
    public Mutt() { super(); }
}
```

```java
// typeinfo/pets/Pug.java
package typeinfo.pets;

public class Pug extends Dog {
    public Pug(String name) { super(name); }
    public Pug() { super(); }
}
```

```java
// typeinfo/pets/Cat.java
package typeinfo.pets;

public class Cat extends Pet {
    public Cat(String name) { super(name); }
    public Cat() { super(); }
}
```

```java
// typeinfo/pets/EgyptianMau.java
package typeinfo.pets;

public class EgyptianMau extends Cat {
    public EgyptianMau(String name) { super(name); }
    public EgyptianMau() { super(); }
}
```

```java
// typeinfo/pets/Manx.java
package typeinfo.pets;

public class Manx extends Cat {
    public Manx(String name) { super(name); }
    public Manx() { super(); }
}
```

```java
// typeinfo/pets/Cymric.java
package typeinfo.pets;

public class Cymric extends Manx {
    public Cymric(String name) { super(name); }
    public Cymric() { super(); }
}
```

```java
// typeinfo/pets/Rodent.java
package typeinfo.pets;

public class Rodent extends Pet {
    public Rodent(String name) { super(name); }
    public Rodent() { super(); }
}
```



````java
// typeinfo/pets/Mouse.java
package typeinfo.pets;

public class Mouse extends Rodent {
    public Mouse(String name) { super(name); }
    public Mouse() { super(); }
}
````

```java
// typeinfo/pets/Hamster.java
package typeinfo.pets;

public class Hamster extends Rodent {
    public Hamster(String name) { super(name); }
    public Hamster() { super(); }
}
```



【**总共有十二个类，这例子有必要弄这么多类么，增加无谓的复杂度。**】



> 接下来，有一个类随机地创建不同类型的宠物，同时它还可以创建宠物数组和持有宠物的 List。为了使它更具普遍性，我们将其定义为抽象类：



```java
/ typeinfo/pets/PetCreator.java
// Creates random sequences of Pets
package typeinfo.pets;
import java.util.*;
import java.util.function.*;

public abstract class PetCreator implements Supplier<Pet> {
    private Random rand = new Random(47);

   	// 生成 Pet Class类 的抽象方法
    public abstract List<Class<? extends Pet>> types();

    public Pet get() { // Create one random Pet
        int n = rand.nextInt(types().size());
        try {
            return types().get(n).newInstance();
        } catch (InstantiationException |
                IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
```



> 
>
> 抽象方法 `types()` 需要子类来实现，以此来获取 `Class` 对象构成的 List（这是**模板方法设计模式**的一种变体。）
>
> 其中类的类型被定义为 任何从 `Pet` 的继承的子类型，因此 `newInstance()` 不需要转型就可以产生 Pet。
>
> `get()` 随机选取出一个 `Class` 对象，然后可以通过 `Class.newInstance()` 来生成该类的新的实例。
>
> 在调用 `newInstance()` 时可能会出现两种异常。（`IllegalAccessException` 违反了 Java 安全机制，在本例中表示默认构造器为 private 的情况）
>
> 当你创建 `PetCreator` 子类时，需要为 `get()` 方法提供 Pet类型的 List。 `types()` 方法会简单地返回一个 **静态 List 的引用**。 下面是使用 `forName()` 的一个具体实现：

```java
// typeinfo/pets/ForNameCreator.java
public class ForNameCreator extends PetCreator {
    private static List<Class<? extends Pet>> types = new ArrayList<>();

    // 随机生成的类型名
    private static String[] typeNames = {
            "typeinfo.pets.Mutt",
            "typeinfo.pets.Pug",
            "typeinfo.pets.EgyptianMau",
            "typeinfo.pets.Manx",
            "typeinfo.pets.Cymric",
            "typeinfo.pets.Rat",
            "typeinfo.pets.Mouse",
            "typeinfo.pets.Hamster"
    };
    @SuppressWarnings("unchecked")
    private static void loader() {
        for (String name : typeNames) {
            try {
                types.add((Class<? extends Pet>) Class.forName(name));
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static {
        loader();
    }


    @Override
    public List<Class<? extends Pet>> types() {
        return types;
    }
}

```

> `loader()` 方法使用 `Class.forName()` 创建 Class 对象的 List。 可能导致 `ClassNotFoundException` 异常。 因为传入的是一个 String 类型的参数，不能在编译期间被确认是否合理。由于 Pet 相关文件在 `typeinfo` 包里，所以使用的时候需要填写完整的包名。
>
> 为了使放入 `List` 的对象是具体的 `Class` 对象，**类型转换**是必须的，**它会产生一个编译时警告**。
>
> **loader()** 方法是分开编写的，然后被放到一个静态代码块里。因为 `@SuppredssWarning` 注解不能直接放置在静态代码块上。
>
> 为了对 **Pet** 计数，需要能跟踪不同类型 Pet 的工具。`Map` 类型的数**据结构**是这个需求的首选，我们将 Pet 类型作为Key 其数量作为 Value。
>





```java
// typeinfo/PetCount.java
// 使用 instanceof
import typeinfo.pets.*;
import java.util.*;

public class PetCount {
    static class Counter extends HashMap<String, Integer> {
        public void count(String type) {
            Integer quantity = get(type);
            if (quantity == null)
                put(type, 1);
            else
                put(type, quantity + 1);
        }
    }

    public static void
    countPets(PetCreator creator) {
        Counter counter = new Counter();
        for (Pet pet : Pets.array(20)) {
            // List each individual pet:
            System.out.print(
                    pet.getClass().getSimpleName() + " ");
            if (pet instanceof Pet)
                counter.count("Pet");
            if (pet instanceof Dog)
                counter.count("Dog");
            if (pet instanceof Mutt)
                counter.count("Mutt");
            if (pet instanceof Pug)
                counter.count("Pug");
            if (pet instanceof Cat)
                counter.count("Cat");
            if (pet instanceof EgyptianMau)
                counter.count("EgyptianMau");
            if (pet instanceof Manx)
                counter.count("Manx");
            if (pet instanceof Cymric)
                counter.count("Cymric");
            if (pet instanceof Rodent)
                counter.count("Rodent");
            if (pet instanceof Rat)
                counter.count("Rat");
            if (pet instanceof Mouse)
                counter.count("Mouse");
            if (pet instanceof Hamster)
                counter.count("Hamster");
        }
        // Show the counts:
        System.out.println();
        System.out.println(counter);
    }

    public static void main(String[] args) {
        countPets(new ForNameCreator());
    }
}
```

> 在 countPets() 中，一个简短的静态方法 Pets.array() 生产出了一个随机动物的集合。每个 Pet 都被 instanceof 检测并计算了一遍。
> 
>
> `instanceof`  中有一个严格的限制，`instanceof` 运算符只能与类名做比较，而不能与 `Class` 对象作比较。前面的例子写了一大堆 `instanceof` 很乏味，但是没有办法让 `instanceof` 聪明起来，让它能自动创建 `Class` 对象的数组，然后将目标与数组中的对象逐一比较。（稍后会看到替代限制）
>
> 你的程序中不应出现大量的 `instnaceof` 语句，否则说明设计有问题
>
> 



#### 使用类字面量

> 如果使用类字面量重新实现 `PetCreator` 类的话，其结果在很多方面都会更清晰：

```java
// typeinfo/pets/LiteralPetCreator.java
// 使用类字面量
public class LiteralPetCreator extends PetCreator {

    public static final List<Class<? extends Pet>> ALL_TYPES =
            Collections.unmodifiableList(Arrays.asList(
                    Pet.class, Dog.class, Cat.class, Rodent.class,
                    Mutt.class, Pug.class, EgyptianMau.class,
                    Manx.class, Cymric.class, Rat.class,
                    Mouse.class, Hamster.class
            ));

    // 这里是将所有类型的子集 从 Mutt.class 开始到结尾作为一个随机创建的集合返回
    private static final List<Class<? extends Pet>> TYPES = ALL_TYPES
            .subList(ALL_TYPES.indexOf(Mutt.class), ALL_TYPES.size());

    // try 代码块不再需要
    @Override
    public List<Class<? extends Pet>> types() {
        return TYPES;
    }

    public static void main(String[] args) {
        System.out.println(TYPES);
    }
}
/**
输出
[class typeinfo.pets.Mutt, class typeinfo.pets.Pug, class typeinfo.pets.EgyptianMau, class typeinfo.pets.Manx, class typeinfo.pets.Cymric, class typeinfo.pets.Rat, class typeinfo.pets.Mouse, class typeinfo.pets.Hamster]
*/

```

> 即将到来的 PetCount3 中，使用 Pet 类型**预先加载**一个 Map，因此 `ALL_TYPES` 列表是必要的。 types 列表是 ALL_TYPES 类型的一部分，它包含精确的宠物类型，用于**随机生成 `Pet`。**
>
> 这次 types 的创建不需要用 try 包围，因为字**面量常量在编译时计算**，不会引发异常，不像 `Class.forName()。`
>
> 我们现在在 typeinfo.pets 库中有**两个 `PetCreator`** **实现**。为了提供第二个作为默认实现，我们可以创建一个使用 LiteralPetCreator 的**外观模式**：

```java
// typeinfo/pets/Pets.java
public class Pets {
    // 创建一个不可变的 CREATOR
    public static final PetCreator CREATOR = new LiteralPetCreator();

    public static Pet get() {
        return CREATOR.get();
    }

    public static Pet[] array(int size) {
        Pet[] result = new Pet[size];
        for (int i = 0; i < size; i++) {
            result[i] = CREATOR.get();
        }
        return result;
    }

    public static List<Pet> list(int size) {
        ArrayList<Pet> result = new ArrayList<>();
        Collections.addAll(result, array(size));
        return result;
    }

    public static Stream<Pet> stream() {
        return Stream.generate(CREATOR);
    }
}

```

> 这里还提供了对 get()、array()、和 list() 的间接调用，以及生成 `Stream<Pet>` 的新方法。
>
> 因为 PetCount.countPets() 采用了 PetCreator 参数，所以我们可以很容易地测试 LiteralPetCreator （**`通过外观模式）`**

```java
// typeinfo/PetCount2.java
import typeinfo.pets.*;

public class PetCount2 {
    public static void main(String[] args) {
        PetCount.countPets(Pets.CREATOR);
    }
}
/**
输出
Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric 
{EgyptianMau=2, Pug=3, Rat=2, Cymric=5, Mouse=2, Cat=9, Manx=7, Rodent=5, Mutt=3, Dog=6, Pet=20, Hamster=1}
*/
```

#### 这里我有一个迷惑的地方：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200229141144.png)

这里传进去的PetCreator 对象压根就没有用，生成的对象都是 Pets.array() 方法生成的，这个方法内部

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200229141227.png)

就内定了使用 LiteralPetCreator

![image-20200229141253984](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/image-20200229141253984.png)

所以这个方法的入参压根没有意义，不明白作者的Demo为啥要这么写。



**【个人觉得应该根据传入的Createor 类型不同调用不同的生成方法。】**



#### 一个动态 instanceof 函数

> `Class.isInstance()` 方法提供了一种动态测试对象类型的方法。因此所有这些繁琐的 `instanceof` 语句都可以从 `PetCount.java` 中删除。

**源码：**

```java
//  java.lang/Class.java
/**
This method is the dynamic equivalent of the Java language instanceof operator.  
可以看到这是一个 native 方法，其作用与 instanceof 操作符相同。
*/
public native boolean isInstance(Object obj);
```





```java
// PetCount3.java
public class PetCount3 {
    static class Counter extends LinkedHashMap<Class<? extends Pet>, Integer> {
        Counter() {
            super(LiteralPetCreator.ALL_TYPES.stream()
                    .map(lpc -> Pair.make(lpc, 0))
                    .collect(Collectors.toMap(Pair::key, Pair::value)));
        }

        public void count(Pet pet) {
            // Class.isInstance() 替代 instanceof
            entrySet().stream()
                    .filter(pair -> pair.getKey().isInstance(pet)) // 判断类型是否相同
                    .forEach(pair -> put(pair.getKey(), pair.getValue() + 1));
        }

        @Override
        public String toString() {
            String result = entrySet().stream()
                    .map(pair -> String.format("%s=%s", pair.getKey().getSimpleName(),
                            pair.getValue()))
                    .collect(Collectors.joining(", "));
            return "{ " + result + " }";
        }

        public static void main(String[] args) {
            Counter petCount = new Counter();
            Pets.stream()
                    .limit(20)
                    .peek(petCount::count)
                    .forEach(p -> System.out.print(p.getClass().getSimpleName() + " "));
            System.out.println();
            System.out.println("------------");
            System.out.println( petCount);
        }
    }
}




/**
输出
Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric 
------------
{ Rat=2, Rodent=5, Pet=20, Mouse=2, Cymric=5, Manx=7, Mutt=3, Pug=3, Cat=9, EgyptianMau=2, Dog=6, Hamster=1 }

*/
```



> 为了计算所有不同类型的 `Pet`，`Counter Map` 预先加载了来自 `LiteralPetCreator.ALL_TYPES` 的类型。
>
> 如果不预先加载 `Map`，将只计数随机生成的类型，而不是像 Pet 和 Cat 这样的基本类型。 
>
> 
>
> `isInstance()` 方法**消除了**对 `instanceof` 表达式的需要。 此外，这意味着你可以通过更改 LiteralPetCreator.types 数组来添加新的 Pet 类型；其余程序都不需要修改。
>
> `toString()` 方法被重载，以便更容易读取输出，该输出扔与打印 Map 时看到的典型输出匹配。
>
> 

#### 递归计数

>  PetCount3.Counter 中的 Map 预加载所有不同的 Pet 类。可以使用 Class.isAssignableFrom() 而不是预加载 Map，并创建一个不限于计数的 Pet 通用工具：

```java
// Class.java
/**
Determines if the class or interface represented by this Class object is either the same as, or is a superclass or superinterface of, the class or interface represented by the specified Class parameter. 确定传入 CLass 表示的类或者接口是否与指定 Class的类或接口相同
*/
public native boolean isAssignableFrom(Class<?> cls);
```



```java
// TypeCounter.java
public class TypeCounter extends HashMap<Class<?>, Integer> {
    private Class<?> baseType;

    public TypeCounter(Class<?> baseType) {
        this.baseType = baseType;
    }

    public void count(Object obj) {
        Class<?> type = obj.getClass();
        if (!baseType.isAssignableFrom(type)) {
            throw new RuntimeException(obj + "incorrect type" + type + ", should be type or subtype of " + baseType);
        }
        countClass(type);
    }

    // 递归计数，直到继承根对象。
    private void countClass(Class<?> type) {
        System.out.println(type.getSimpleName());
        Integer quantity = get(type);
        put(type, quantity == null ? 1 : quantity + 1);
        Class<?> superclass = type.getSuperclass();
        // 确定传入 CLass 表示的类或者接口是否与指定 Class的类或接口相同 如果不为空且相同，则在基类上调用 countClass 方法
        if (superclass != null && baseType.isAssignableFrom(superclass)) {
            countClass(superclass);
        }
    }

    @Override
    public String toString() {
        String result = entrySet().stream().map(
                pair -> String.format("%s=%s",
                        pair.getKey().getSimpleName(),
                        pair.getValue()))
                .collect(Collectors.joining(", "));

        return "{" + result + "}";
    }
}
```

> count() 方法获取其参数的 Class类型，并使用 isAssignableFrom() 进行运行时检查，以验证传递的对象实际上属于感兴趣的层次结构。 countClass() 首先计算类的确切类型。
>
> 然后如果 `baseType` 可以从超类赋值，则在超类上递归调用 `countClass();`

```java
// PetCount4.java
public class PetCount4 {
    public static void main(String[] args) {
        TypeCounter counter = new TypeCounter(Pet.class);
        Pets.stream()
                .limit(20)
                .peek(counter::count)
                .forEach(p -> System.out.print(p.getClass().getSimpleName() + " "));

        System.out.println("n" + counter);


    }
}

/**
输出
Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric n{Manx=7, Pet=20, Dog=6, Cymric=5, Rat=2, Cat=9, EgyptianMau=2, Mouse=2, Rodent=5, Hamster=1, Mutt=3, Pug=3}
*/

```

> 输出表明两个基类型及精确类型都被计数了。

### 