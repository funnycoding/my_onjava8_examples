---
layout: post
title: 《On Java8》第十四章——流式编程(4) —— 终端操作【完】
date: 2020年02月22
tags:
- 读书笔记
categories: 
- 《On Java8》

---

### 终端操作

> 以下操作将会获取流的最终结果。至此流无法继续往后传递。
>
> 终端操作是在流管道中做的最后一件事。

【即数据的终结操作。】

<!-- more -->	

#### 数组

> - `toArray()` ：将流转换成适当类型的数组。
> - `toArray(generator)`：在特殊情况下，生成自定义类型的数组。
>
> 当需要获得数组类型以便进行后续操作的时候上面的方法就很有用。

```java
// RandInts.java
public class RandInts {
    private static int[] randomInts = new Random(47)
            .ints(0, 1000)
            .limit(100)
            .toArray();

    public static IntStream rands() {
        return Arrays.stream(randomInts);
    }
}

```

> 这个例子生成 100个 0 到1000 之间的随机数的流转换成数组并将其存储在 `rints` 中。这样每次调用 `rands()`  的时候可以重复获取相同的整数流。

#### 循环

> - `forEach(Consumer)` 常见如 System.our::println 作为 Consumer 函数。
> - `forEachOrdered(Cosumer)` ：保证 forEach 按照**原始流顺序**操作
>
> 第一种形式是无序操作，仅在引入并行流时才有意义。 在并发之前不会深入讨论这个问题。 
>
> 这里简单介绍 `parallel()：`可实现**多处理器并行操作**。**实现原理为将流分割为多个（通常是CPU核心数）并在不同处理器上分别执行操作**。因为采用的是**内部迭代**而不是外部迭代，所以这是可能实现。

**【那么具体内部迭代是怎样的呢？】**

- 内部迭代是我们提供做什么，将怎么做的任务交给了 `JVM`

【也就是隐藏了细节，由虚拟机帮我提升效率】

> `parallel()`看似简单，其实很复杂，会在并发编程章节中深入学习。
>
> 下例引入 parallel() 来帮助理解 forEachOrdered(Consumer) 的作用和使用场景：

```java
// ForEach.java
public class ForEach {
    static final int SZ = 14;

    public static void main(String[] args) {
        RandInts.rands()
                .limit(SZ)
                .forEach(n -> System.out.format("%d ", n));

        System.out.println();

        RandInts.rands()
                .limit(SZ)
                .parallel()
                .forEach(n -> System.out.format("%d ", n));

        System.out.println();

        RandInts.rands().limit(SZ)
                .parallel()
                .forEachOrdered(n -> System.out.format("%d ", n));

    }
}
/**
输出
258 555 693 861 961 429 868 200 522 207 288 128 551 589 
551 589 868 555 861 258 429 288 128 207 200 522 961 693 
258 555 693 861 961 429 868 200 522 207 288 128 551 589 
*/

```

> 可以看到使用 `parallel()` 之后 输出第二个输出顺序发生了改变，这是由于多处理器并行操作的原因。并且多次运行测试其结果均不同。**多处理器并行操作带来的非确定性因素造成了这样的结果。**
>
> 最后一个流中使用了 `parallel()` 和 `forEachOrdered()` 来**强制保持原始流顺序**。因此**对非并行流使用 `forEachOrdered()` 是没有任何影响的。**

#### 集合

> - `collect(Collector)`：使用 Collector 将流转为集合
> - `coolect(Supplier,BiConsumer,BiConsumer)`：同上，第一个参数 **Supplier** **创建了一个新的结果集**，第二个参数 **BiConsumer** **将下一个元素包含到结果中**，**第三个 BiConsumer 用于将两个值组合起来。**
>
> 这里只介绍几个简单的 Collectors 的运用实例。复杂的建议查看 `java.util.stream.Collectors` 的 API 文档。 例如可以将元素收集到任意一种特定的集合中。
>
> 假设为了保证元素有序，将元素存储在 TreeSet 中。 **Collectors 里没有特定的 `toTreeSet()`**，但是我们可以通过**将集合的构造函数引用传递给** `Collectors.toCollection()` 从而构建任何类型的集合：

```java
	// streams/TreeSetOfWords.java
public class TreeSetOfWords {
    public static void main(String[] args) throws IOException {
        Set<String> words2 =
                Files.lines(Paths.get("TreeSetOfWords.java"))
                        .flatMap(s -> Arrays.stream(s.split("\\W+")))
                        .filter(s -> !s.matches("\\d+")) // 非数字
                        .map(String::trim)
                        .filter(s -> s.length() > 2)
                        .limit(100)
                        .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(words2);
    }
}
/**
输出
[Arrays, Collectors, Exception, Files, Output, Paths,
Set, String, System, TreeSet, TreeSetOfWords, args,
class, collect, file, filter, flatMap, get, import,
java, length, limit, lines, main, map, matches, new,
nio, numbers, out, println, public, split, static,
stream, streams, throws, toCollection, trim, util,
void, words2]
*/
```

> Files.lines() 打开 Path 并将其转换为 `Stream<String>`。
>
> 下一行d挨骂将匹配一个或多个非单词字符(`\\w+`)进行分割，然后使用 Arrays.stream() 将其转化为流，并将结果 使用 flatMap() 获取流中元素映射为单词流。
>
> 然后使用 `matches(\\d+)` 查找并移除全数字字符串（注意 `words2`是通过的）。接下来使用 `String.trim()` 去除单词两边的空白，filter() 过滤长度小于3的单词，`limit()` 取前100个单词，然后使用 `collect()` 最终消费流保存到 TreeSet中



> 也可以在流中生成 Map：

```java
// MapCollector.java
class utils.Pair {
    public final Character c;
    public final Integer i;

    public utils.Pair(Character c, Integer i) {
        this.c = c;
        this.i = i;
    }

    public Character getC() {
        return c;
    }

    public Integer getI() {
        return i;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", utils.Pair.class.getSimpleName() + "[", "]")
                .add("c=" + c)
                .add("i=" + i)
                .toString();
    }
}

class RandomPair {
    Random rand = new Random(47);

    // 生成随机数然后转为 Char 类型
    Iterator<Character> capChars = rand.ints(65, 91)
            .mapToObj(i -> (char) i)
            .iterator();

    public Stream<utils.Pair> stream() {
        return rand.ints(100, 1000)
                .distinct()
                .mapToObj(i -> new utils.Pair(capChars.next(), i));
    }
}

public class MapCollector {
    public static void main(String[] args) {
        Map<Integer, Character> map = new RandomPair().stream()
                .limit(8)
                .collect(Collectors.toMap(utils.Pair::getI, utils.Pair::getC));
        System.out.println(map);
    }
}

/**
输出
{688=W, 309=C, 293=B, 761=N, 858=N, 668=G, 622=F, 751=N}
*/
```



> **Piar** 是一个封装基础数据的对象。 **RandomPair** 创建了随机生成 Piar 的对象的流。
>
> 在 Java中，不能直接以某种方式组合两个流，所以这里创建了一个整数流，并且使用 `mapToObject()` 将其转化为 **utils.Pair** 流。
>
> **capChars** 随机生成的大写字母迭代器从生成一个 `IntStream` 整数流开始，然后 使用 `mapToObject()` 转为 `Stream<Character>` 并使用 `iterator()` 获取其迭代器。 `iterator()` 允许我们在 `stream()` 中使用它。就我所知，这是组合多个流以生成新对象的唯一方法。
>
> 在例子中只使用了最简单的 Collector.toMap() ，这个方法需要一个可以从流中获取键值对的函数。还有其他重载形式没比如在遇到键值冲突时，需要一个函数来处理这种情况。
>
> 大多数情况，预设的 `java.util.Collector`能满足我们的要求，除此之外，也可以使用第二周形式的 `collect()`。

 ```java
// streams/SpecialCollector.java
import java.util.*;
import java.util.stream.*;
public class SpecialCollector {
    public static void main(String[] args) throws Exception {
        ArrayList<String> words =
                FileToWords.stream("Cheese.dat")
                        .collect(ArrayList::new,
                                ArrayList::add,
                                ArrayList::addAll);
        words.stream()
                .filter(s -> s.equals("cheese"))
                .forEach(System.out::println);
    }
}
/**
输出
cheese
cheese
*/
 ```

【这里主要看生成ArrayList 的那一行，这里使用的是下面的方法】

```java
  <R> R collect(Supplier<R> supplier,
                  BiConsumer<R, ? super T> accumulator,
                  BiConsumer<R, R> combiner);

```

**复习前面的：【第一个参数 Supplier 创建了一个新结果集合，第二个参数 BiConsumer 将下一个元素包含到结果中，第三个参数 BiConsumer 用于将两个值组合起来】**



> 在这里 **ArrayLIst** 的方法已经执行了你需要的操作，如果你必须使用这种形式 `collect()` ,则**必须自己创建特殊的定义** 也就是上面的 **Supplier** , **Biconsumer**。



#### 组合

> - `reduce(BinaaryOperator)`：**使用 BinaryOperator 来组合流中所有元素。 流可能返回为空，其返回值为 Optional。**
> - `reduce(identity,BinaryOperator)`：功能同上，使用 identity 作为其组合的初始值，**如果流为空，则 identity 为结果。**
> - `reduce(identity, BiFunction, BinaryOperator)`：更复杂的形式，暂时不介绍，它可以提高效率。可以使用 `map()` + `reduce()` 的组合来简单表示它。
>
> 下面是一个 reduce 的简单示例：

```java
// Reduce.java
class Frobnitz {
    int size;

    public Frobnitz(int size) {
        this.size = size;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Frobnitz.class.getSimpleName() + "[", "]")
                .add("size=" + size)
                .toString();
    }

    static Random rand = new Random(47);
    static final int BOUND = 100;

    static Frobnitz supply() {
        return new Frobnitz(rand.nextInt(BOUND));
    }
}

public class Reduce {
    public static void main(String[] args) {
        Stream.generate(Frobnitz::supply)
                .limit(10)
                .peek(System.out::println)
                .reduce((fr0, fr1) -> fr0.size < 50 ? fr0 : fr1)
                .ifPresent(System.out::println);
    }
}
/**
输出
Frobnitz[size=58]
Frobnitz[size=55]
Frobnitz[size=93]
Frobnitz[size=61]
Frobnitz[size=61]
Frobnitz[size=29]
Frobnitz[size=68]
Frobnitz[size=0]
Frobnitz[size=22]
Frobnitz[size=7]
Frobnitz[size=29]
*/
```

> Frobnitz 包含了一个名为 suppky() 的生成器，这个方法对于 `Supplier<Frobnitz>`是签名兼容的，我们可以将其方法引用传递给 `Stream.generator()`（这种方法签名的兼容性被称为结构一致性）。
>
> 无 初始值的 reduce() 方法返回值是 Optional 类型。 `Optional.ifPresent()` 只有在结果**非空**的时候才会调换用 `COnsumer<Frobnitz>`（`println` 方法可以被调用是因为 Frobnitz 可以通过 `toString()` 方法转成 String)
>
> Lambda 表达式的第一个参数 `fr0` 是上一次调用 `reduce()` 的结果，第二个参数 `fr1` 是从**流传递**过来的值。
>
> `reduce()` 中的 Lambda 表达式使用了三元表达式来获取结果，当其长度小于 50获取 fr0 否则获取序列中的下一个值 fr1。**当取得第一个长度小于50的 Frobnitz，只要得到结果就会忽略其他。**
>
> 这是一个非常奇怪的约束，也让我们对 `reduce()` 有了更多了解。

#### 匹配

> - `allMatch(Predicate)` ：如果流的每个元素根据提供的 **Predicate** 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。【全匹配】
> - `anyMatch(Predicate)`：如果流中的任意一个元素根据提供的 **Predicate** 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。【任意匹配】
> - `noneMatch(Predicate)`：如果流的每个元素根据提供的 **Predicate** 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。【全不匹配】
>
> 我们已经在 `Prime.java` 中看到了 `noneMatch()` 的示例；`allMatch()` 和 `anyMatch()` 的用法基本上是等同的。下面我们来探究一下短路行为。为了消除冗余代码，我们创建了 `show()`。首先我们必须知道如何统一地描述这三个匹配器的操作，然后再将其转换为 **Matcher** 接口。代码示例：

```java

//Matching.java
interface Matcher extends BiPredicate<Stream<Integer>, Predicate<Integer>> {
}

public class Matching {
    static void show(Matcher match, int val) {
        System.out.println(
                match.test(
                        IntStream.rangeClosed(1, 9)
                                .boxed()
                                .peek(n -> System.out.format("%d ", n)),
                        n -> n < val
                )
        );
    }

    public static void main(String[] args) {
        show(Stream::allMatch,10);
        show(Stream::allMatch,4);
        show(Stream::anyMatch,2);
        show(Stream::anyMatch,0);
        show(Stream::noneMatch,5);
        show(Stream::noneMatch,0);
    }
}
/**
输出
1 2 3 4 5 6 7 8 9 true
1 2 3 4 false
1 true
1 2 3 4 5 6 7 8 9 false
1 false
1 2 3 4 5 6 7 8 9 true
*/
```

> 
>
> 这里 **BiPredicate** 是一个**二元谓词**。接受两个参数且只返回 true 或 false。
>
> 它的第一个参数是我们要测试的流，第二个参数是一个谓词 Predicate。
>
> Matcher 适用于所有的 `Stream::*Match` 方法，所以我们可以将这些方法应用到每一个 `show()` 中。
>
> `match.test()` 的调用会被转换成 `Stream::*Match` 函数调用。
>
> `show()` 获取两个参数，**Matcher 匹配器**和用于表示谓词测试 **n < val** 中最大值的 val。 
>
> 这个方法生成一个 1-9 之间的整数流。 peek() 向我们展示短路的情况，每次都发生了短路，只要匹配就停止输出。



#### 查找

> - `findFirst()`：返回第一个流元素的 **Optional**，如果流为空返回 **Optional.empty**。 
> - `findAny(`：返回含有任意流元素的 **Optional**，如果流为空返回 **Optional.empty**。

```java
// SelectElement.java
public class SelectElement {
    public static void main(String[] args) {
        System.out.println(RandInts.rands().findFirst().getAsInt());
        System.out.println(RandInts.rands().parallel().findFirst().getAsInt());
        System.out.println(RandInts.rands().findAny().getAsInt());
        System.out.println(RandInts.rands().parallel().findAny().getAsInt());
    }
}
/**
输出
258
258
258
242
*?
```

> `findFirst()` **无论流是否为并行化的，总是会选择流中的第一个元素**。对于**非并行流**，`findAny()`**会选择流中的第一个元素**（即使从定义上来看是选择任意元素）。在这个例子中，**我们使用 `parallel()` 来并行流从而引入 `findAny()` 选择非第一个流元素的可能性。**

#### 信息

> - `count()`：流中的元素个数。
> - `max(Comparator)`：根据所传入的 **Comparator** 所决定的“最大”元素。
> - `min(Comparator)`：根据所传入的 **Comparator** 所决定的“最小”元素。

```java
// streams/Informational.java
import java.util.stream.*;
import java.util.function.*;
public class Informational {
    public static void
    main(String[] args) throws Exception {
        System.out.println(
                FileToWords.stream("Cheese.dat").count());
        System.out.println(
                FileToWords.stream("Cheese.dat")
                        .min(String.CASE_INSENSITIVE_ORDER)
                        .orElse("NONE"));
        System.out.println(
                FileToWords.stream("Cheese.dat")
                        .max(String.CASE_INSENSITIVE_ORDER)
                        .orElse("NONE"));
    }
}
/**
输出
32
a
you
*/
```

> `min()` 和 `max()` 的返回类型为 **Optional**，这需要我们使用 `orElse()`获取其中的数据.



#### 数字流信息

> - `average()` ：求取流元素平均值。
> - `max()` 和 `min()`：数值流操作无需 **Comparator**。
> - `sum()`：对所有流元素进行求和。
> - `summaryStatistics()`：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。



```java
public class NumericStreamInfo {
    public static void main(String[] args) {
        System.out.println(RandInts.rands().average().getAsDouble());
        System.out.println(RandInts.rands().max().getAsInt());
        System.out.println(RandInts.rands().min().getAsInt());
        System.out.println(RandInts.rands().sum());
        System.out.println(RandInts.rands().summaryStatistics());
    }
}
/**
输出
507.94
998
8
50794
IntSummaryStatistics{count=100, sum=50794, min=8, average=507.940000, max=998}
*/
```



### 小结：

本节是一个实践性非常强的章节，在不断重写样例的过程中，也同时不断加深了对十三十四章的理解。