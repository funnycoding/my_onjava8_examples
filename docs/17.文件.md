---
layout: post
title: 《On Java8》第十七章——文件
date: 2020年02月23日16:09:46
tags:
- 读书笔记
categories: 
- 《On Java8》

---

> 在丑陋的 Java I/O 编程方式诞生多年以后，Java 终于简化了读写文件的操作

**【疑问】**

【之前的例子，当需要读取文件的时候，作者使用的是 `Paths.get()`直接传入文件名即可，但是我这样做会抛出文件无法找到异常，必须传入文件的绝对定位地址才行。

那么是什么导致了这个差异？是因为 **classpath** 类路径的配置吗？

加上这章也是操作性很强且篇幅不是很长的章节，所以拿到前面来学习快速将所有例子过一遍

】



<!-- more -->	

> Java7 对此引入了巨大的改进。这些元素在 java.nio.file 包下。过去 nio 被理解为 new io,现在更应该理解为 non-blocking io 非阻塞 io。
>
> Java 8 的 stream 与文件的集合使得文件操作系统更加优雅。
>
> 文件操作系统的两个基本组件：
>
> 1. 文件或者目录的路径
> 2. 文件本身。

### 文件和目录路径

> Path 对象表示一个文件或者目录的路径，是一个跨操作系统 和 文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同操作系统上。
>
> `java.nio.file.Paths` 类包含一个重载方法 `static.get()`，该方法接受一系列 String 字符串或一个 统一资源标识符（URI）作为参数，并且进行转换返回一个 Path对象。

```java
// files/PathInfo.java
public class PathInfo {
    static void show(String id, Object p) {
        System.out.println(id + ": " + p);
    }

    static void info(Path p) {
        show("toString", p);
        show("Exists", Files.exists(p));
        show("RegularFile", Files.isRegularFile(p));
        show("Directory", Files.isDirectory(p));
        show("Absolute", p.isAbsolute());
        show("FileName", p.getFileName());
        show("Parent", p.getParent());
        show("Root", p.getRoot());
        System.out.println("******************");
    }
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        info(Paths.get("C:", "path", "to", "nowhere", "NoFile.txt"));
        Path p = Paths.get("PathInfo.java");
        info(p);
        Path ap = p.toAbsolutePath();
        info(ap);
        info(ap.getParent());
        try {
            info(p.toRealPath());
        } catch(IOException e) {
           System.out.println(e);
        }
        URI u = p.toUri();
        System.out.println("URI: " + u);
        Path puri = Paths.get(u);
        System.out.println(Files.exists(puri));
        File f = ap.toFile(); // Don't be fooled
    }
}

/* 输出:

这里的输出与你自己的操作系统有关，每个人的都不一样。

Windows 10
toString: C:\path\to\nowhere\NoFile.txt
Exists: false
RegularFile: false
Directory: false
Absolute: true
FileName: NoFile.txt
Parent: C:\path\to\nowhere
Root: C:\
******************
toString: PathInfo.java
Exists: true
RegularFile: true
Directory: false
Absolute: false
FileName: PathInfo.java
Parent: null
Root: null
******************
toString: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples\files\PathInfo.java
Exists: true
RegularFile: true
Directory: false
Absolute: true
FileName: PathInfo.java
Parent: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples\files
Root: C:\
******************
toString: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples\files
Exists: true
RegularFile: false
Directory: true
Absolute: true
FileName: files
Parent: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples
Root: C:\
******************
toString: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples\files\PathInfo.java
Exists: true
RegularFile: true
Directory: false
Absolute: true
FileName: PathInfo.java
Parent: C:\Users\Bruce\Documents\GitHub\onjava\
ExtractedExamples\files
Root: C:\
******************
URI: file:///C:/Users/Bruce/Documents/GitHub/onjava/
ExtractedExamples/files/PathInfo.java
true
*/
```



> `toString()` 方法生成完整形式的路径
>
> `getFileName()` 返回当前文件名
>
> `Files.exists(p)` 判断文件是否存在
>
> `Files.isDirectory(p)`判断文件是否是文件夹
>
> Nofile.txt 这个示例展示我们描述的文件可能并不在指定的位置，这样允许你创建一个新的路径。
>
> 真实路径在文档中的定义模糊，它取决于具体的文件系统。
>
> URI 看起来只能用于描述文件，实际上 URI 可以用于描述更多的东西。【只要是资源都可以，包括网络资源之类的】
>
> **Path 中存在欺骗的东西**， `toFile()` 方法生成一个 File对象。但是这个方法得到的并不是类似文件的东西，只是为了向后兼容，看上去应该被称为路径，实际上却应该表示目录或者文件本身。 
>
> 这是个非常草率并且令人困惑的命名，但是 java.nio.file 的存在让我们可以安全地忽略它的存在。【作者为什么这么说？】
>
> 

【其实之前我个人用的 文件类的 API 更多的是 最老的io包中的 File 而不是 nio 中的 Files。新的API在根据路径获取文件上好像是简单了一些。】



#### 选取路径和部分片段

> **Path** 对象可以非常容易地生成路径的某一部分：

```java
// PartsOfPaths.java
public class PartsOfPaths {
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        Path p = Paths.get("PartsOfPaths.java").toAbsolutePath();
        for (int i = 0; i < p.getNameCount(); i++) {
            System.out.println(p.getName(i));
        }
        System.out.println("ends with '.java' :" + p.endsWith(".java"));

        for (Path pp : p) {
            System.out.print(pp + ": ");
            System.out.print(p.startsWith(pp) + " : ");
            System.out.println(p.endsWith(pp));
        }
        System.out.println("Start with " + p.getRoot() + " " + p.startsWith(p.getRoot()));
    }
}
/**
输出
Mac OS X
Users
xuyanxin
Documents
xu-self-project
aibook
PartsOfPaths.java
ends with '.java' :false
Users: false : false
xuyanxin: false : false
Documents: false : false
xu-self-project: false : false
aibook: false : false
PartsOfPaths.java: false : true
Start with / true
*/

```

> 可以通过 getName() 来索引 Path 的各个部分，直到达到上限 geNameCount()。
>
> dPtah 也实现了 Itearable 接口，所以可以使用 for-in 直接遍历。
>
> 即时路径以 .java 结尾， 使用 endsWith() 方法也会返回 false，因为 endsWith() 比较的是 整个路径部分，**而不会包含文件路径的后缀。**
>
> 通过 `startWIth()` 和 `endsWith()` 也可以完成**路径的遍历**，但是 **Path** **对象并不包根路径**，只有使用 `startsWith()` 检测根路径时才会返回 true。

#### 路径分析

> **Files** 工具类包含一系列完整的方法用于获得 **Path** 相关的信息。

```java
// PathAnalysis.java
public class PathAnalysis {
    static void say(String id, Object result) {
        System.out.print(id + " : ");
        System.out.println(result);
    }

    public static void main(String[] args) throws IOException {
        Path p = Paths.get("PathAnalysis.java").toAbsolutePath();
        //Path p = Paths.get("PathAnalysis.java");
        say("Exists", Files.exists(p));
        say("Directory", Files.isDirectory(p));
        say("Excutable", Files.isExecutable(p));
        say("ReadAble", Files.isReadable(p));
        say("RegularFile", Files.isRegularFile(p));
        say("WriteAble", Files.isWritable(p));
        say("nonExist", Files.notExists(p));
        say("Hidden", Files.isHidden(p));
        say("size", Files.size(p));
        say("FileStore", Files.getFileStore(p));
        say("LatModified", Files.getLastModifiedTime(p));
        say("Owner", Files.getOwner(p));
        say("ContentType", Files.probeContentType(p));
        say("SymbolicLink", Files.isSymbolicLink(p));
        if (Files.isSymbolicLink(p)) {
            say("Symbolink", Files.readSymbolicLink(p));
        }

        if (FileSystems.getDefault().supportedFileAttributeViews().contains("posix")) {
            say("PosixFilePermissions", Files.getPosixFilePermissions(p));
        }
    }
}
/**
输出
Exists : true
Directory : false
Excutable : false
ReadAble : true
RegularFile : true
WriteAble : true
nonExist : false
Hidden : false
size : 537
FileStore : / (/dev/disk1s1)
LatModified : 2020-02-23T13:17:49Z
Owner : xuyanxin
ContentType : null
SymbolicLink : false
PosixFilePermissions : [OWNER_WRITE, OWNER_READ, OTHERS_READ, GROUP_READ]

*/
```

> 调用最后一个测试方法 `getPosixFilePermission()` 之前需要确认一下当前文件系统是否支持 `Posix` 接口，否则会抛出运行时异常
>
> **【很明显 MacOS 是支持的】**

#### Paths的增减修改

> 我们必须通过 Path 对象增加或者删除一部分来构造一个新的 Path 对象。
> 我们使用 `relativize()` 移除 Path 的根路径，使用 `resolve()` 添加 Path 的尾路径（不一定是 可发现的名称）
>
> 下面例子中的示例，使用 `relativize()` 方法从所有输出中移除根路径，部分原因是为了示范，部分是为了简化输出结果。 说明可以使用该方法将绝对路径转为相对路径。

```java
	// AddAndSubtractPaths.java
public class AddAndSubtractPaths {
    static Path base = Paths.get("..", "..", "..").toAbsolutePath().normalize();

    static void show(int id, Path result) {
        // 如果是绝对路径，则输出它的相对路径¬
        if (result.isAbsolute()) {
            System.out.println("(" + id + ") ：" + base.relativize(result));
        } else {
            System.out.println("(" + id + ")" + result);
        }
        try {
            System.out.println("Real Path: " + result.toRealPath());
        } catch (IOException e) {
            System.out.println(e);
        }
    }

    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        System.out.println(base);

        Path p = Paths.get("AddAndSubtractPaths.java").toAbsolutePath();
        show(1, p);
        Path convoluted = p.getParent().getParent()
                .resolve("strings").resolve("..")
                .resolve(p.getParent().getFileName());
        show(2, convoluted);
        show(3, convoluted.normalize());

        Path p2 = Paths.get("..", "..");
        show(4, p2);
        show(5, p2.normalize());
        show(6, p2.toAbsolutePath().normalize());
        Path p3 = Paths.get(".").toAbsolutePath();
        Path p4 = p3.resolve(p2);

        show(7, p4);
        show(8, p4.normalize());

        Path p5 = Paths.get("").toAbsolutePath();
        show(9, p5);
        show(10, p5.resolveSibling("strings"));
        show(11, Paths.get("nonexistent"));

    }
}
/**
输出
Mac OS X
/Users/xuyanxin
(1) ：Documents/xu-self-project/aibook/AddAndSubtractPaths.java
Real Path: /Users/xuyanxin/Documents/xu-self-project/aibook/AddAndSubtractPaths.java
(2) ：Documents/xu-self-project/strings/../aibook
java.nio.file.NoSuchFileException: /Users/xuyanxin/Documents/xu-self-project/strings/../aibook
(3) ：Documents/xu-self-project/aibook
Real Path: /Users/xuyanxin/Documents/xu-self-project/aibook
(4)../..
Real Path: /Users/xuyanxin/Documents
(5)../..
Real Path: /Users/xuyanxin/Documents
(6) ：Documents
Real Path: /Users/xuyanxin/Documents
(7) ：Documents/xu-self-project/aibook/./../..
Real Path: /Users/xuyanxin/Documents
(8) ：Documents
Real Path: /Users/xuyanxin/Documents
(9) ：Documents/xu-self-project/aibook
Real Path: /Users/xuyanxin/Documents/xu-self-project/aibook
(10) ：Documents/xu-self-project/strings
java.nio.file.NoSuchFileException: /Users/xuyanxin/Documents/xu-self-project/strings
(11)nonexistent
java.nio.file.NoSuchFileException: nonexistent

*/
```

【这里作者并没有对用到的 API 进行解说，导致我第一遍的时候其实是有点懵逼的，所以要么自己去查一下相关的 Paths  和 Files 的 API 要么直接去看官方的 javadoc，我这里选择先快速的过一遍。】

> 我还为 `toRealPath()` 添加了更多的测试，为了扩展和规则化，防止路径不存在时抛出运行时的异常。



### 目录

> Files 工具类包含了大部分我们需要的**目录操作**和**文件操作**的方法。
>
> 出于某种原因，它们没有包含输出目录树相关的方法。

【是因为安全和系统权限的原因吗？】

```java
// RmDir.java
public class RmDir {
    public static void rmdir(Path dir) throws IOException {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        Files.delete(file);
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                        Files.delete(dir);
                        return FileVisitResult.CONTINUE;
                    }
                }
        );
    }
}

```

> 删除目录树的方法实现依赖于 `Files.walkFileTree()` ， "walking" 目录树意味着遍历每个子目录和文件。
>
> Vistor 设计模式提供了一种 标准机制来访问集合中的每个对象，然后你需要提供在每个对象上执行的操作。 
>
> 此操作的定义取决于 实现 FileVisitor 的四个抽象方法，包括

```java
/**
文件的访问者。 向Files.walkFileTree方法提供此接口的实现，以访问文件树中的每个文件。
用法示例：假设我们要删除文件树。 在这种情况下，应删除目录中的条目，然后删除每个目录。
*/
public interface FileVisitor<T> {
  	/**
  	在访问目录中的条目之前调用了目录。
如果此方法返回CONTINUE，则将访问目录中的条目。 如果此方法返回SKIP_SUBTREE或SKIP_SIBLINGS，则将不会访问目录（以及任何后代）中的条目
		*/	
		FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)   throws IOException;
  	
  	// 调用目录中的文件
    FileVisitResult visitFile(T file, BasicFileAttributes attrs)
        throws IOException;
     // 调用了无法访问的文件。如果无法读取问价你的属性，文件是无法打开的目录以及其他原因，则调用此方法。
    FileVisitResult visitFileFailed(T file, IOException exc)
        throws IOException;
  	// 在访问目录中的条目及其所有后代之后，调用该目录。 当目录的迭代过早完成时（通过 visitFile 方法返回 SKIP_SIBLINGS 或在目录上进行迭代时 发生 I/O 错误）也会调用此方法
    FileVisitResult postVisitDirectory(T dir, IOException exc)
        throws IOException;
}
```

> 为了简化，`java.nio.file.SimpleFileVisitor` 提供了 `FileVisitor` 的所有方法的默认实现。
>
> 这样在匿名内部类中，我们只需要重写非标准行为的方法：`visitFile()` 和 `postVisitDirectory()` 实现删除文件和删除目录。 
>
> 这两者都应该返回标志位决定是否继续访问（这样就可以继续访问，直到找到所需要的）。作为探索目录操作的一部分，现在我们可以有条件地删除已存在的目录。
>
> 在以下例子中 makeVariant() 接受基本目录测试，并通过旋转部件列表生成不同的子目录路径。这些旋转与路径分隔符 sep 使用 `String.join()` 贴在一起，然后返回一个 `Path` 对象。

**【所以前面说的没有提供删除方法，只是默认实现没有删除，还是可以自己修改非标准实现来达到删除效果的。】**

```java
// Directories.java
public class Directories {
    static Path test = Paths.get("test");
    static String sep = FileSystems.getDefault().getSeparator();

    static List<String> parts = Arrays.asList("foo", "bar", "baz", "bag");

    static Path makeVariant() {
        Collections.rotate(parts, 1);
        return Paths.get("test", String.join(sep, parts));
    }

    static void refreshTestDir() throws IOException {
        if (Files.exists(test)) {
            System.out.println("test已经存在，开始删除该目录");
            RmDir.rmdir(test);
        }
        // 直接一个 else 不就行了么。。。 其实不行，因为如果 else 的话就二选一了，这里是需要2个都执行
        if (!Files.exists(test)) {
            System.out.println("test不存在，开始创建目录...");
            Files.createDirectory(test);
        }
    }

    public static void main(String[] args) throws IOException {
        refreshTestDir();
        Files.createFile(test.resolve("Hello.txt"));

        Path variant = makeVariant();
        try {
            Path directory = Files.createDirectory(variant);
        } catch (Exception e) {
            System.out.println("创建 Directory 并没有工作");
        }

        populateTestDir();

        Path tempDir = Files.createTempDirectory(test, "DIR_");
        Files.createTempFile(tempDir, "pre", ".non");

        Files.newDirectoryStream(test).forEach(System.out::println);
        System.out.println("*****************");
        // 遍历了
        Files.walk(test).forEach(System.out::println);


    }

    static void populateTestDir() throws IOException {
        for (int i = 0; i < parts.size(); i++) {
            Path variant = makeVariant();
            if (!Files.exists(variant)) {
                Files.createDirectories(variant);
                Files.copy(Paths.get("Directories.java"), variant.resolve("File.txt"));
                Files.createTempFile(variant, null, null);
            }
        }
    }
}
/**
输出
test已经存在，开始删除该目录
test不存在，开始创建目录...
创建 Directory 并没有工作
Exception in thread "main" java.nio.file.NoSuchFileException: Directories.java
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:86)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)
	at sun.nio.fs.UnixCopyFile.copy(UnixCopyFile.java:526)
	at sun.nio.fs.UnixFileSystemProvider.copy(UnixFileSystemProvider.java:253)
	at java.nio.file.Files.copy(Files.java:1274)
	at com.aibook.onjava.files.Directories.populateTestDir(Directories.java:71)
	at com.aibook.onjava.files.Directories.main(Directories.java:53)

*/
```

【这里我跟例子有不少矛盾的地方，首先就是我的 父目录和作者的差别很大，所以在我这里找不到对应的文件。Files 这一章是一个个性化很强的章节，每个人的 文件目录都不一样，所以需要调整，才能做到和样例代码一样的效果，而这个调整的过程，也是你不断认识、学习 Java 和 操作系统 文件目录结构的一个过程。】



> 首先 `refreshTestDir()` 用于检测 test 目录是否已经存在，若存在则删除后创建一个新的。
>
> 看起来检查是否 exists 是多余的，但是我想说明一点，**如果你对于已经存在的目录调用 `createDirectory()` 将会抛出异常。** 
>
> `createFile()` 使用参数 Path 创建一个空文件；
>
> `resolve()` 将文件名添加到 test Path 的末尾。
>
> 我们尝试使用 `createDirectory()` 来创建多级路径，但是这样会抛出异常，因为这个方法只能创建单级路径。
>
> 我已经将 `populateTestDir()` 作为一个单独的方法，因为它将在后面的例子中被重用。对于每一个变量 variant，我们都能使用 `createDirectories()` 创建完整的目录路径，然后使用此文件的副本以不同的目标名称填充该终端目录。
>
> 然后我们使用 `createTempFileI()` 生成一个临时文件。
>
> 在调用 `populateTestDir()` 之后，我们再 test 目录下面创建一个临时目录。
>
> 请注意 `createTempDirectory()` 只有名称的前缀选项。与 `createTempFile()` 不同，我们再次使用它将临时文件放入新的临时目录中。
>
> 你可以从输出中卡拿到，如果未指定后缀，将默认使用 .tmp 作为后缀。
>
> 为了展示结果，使用了 `newDirectoryStream()` 但是事实证明这个方法只是返回 test 目录内容的 Stream 流，并没有更多的内容，要获取目录树全部的内容的流需要使用 `Files.walk()`



【因为这章每个人的差异都很大，并且是一个拥有个性化 也就是操作文件时候才会使用的场景，所以到这里我打算先跳过，直接进入并发章节】

### 文件系统



### 路径监听



### 文件查找



### 文件读写 

> 此时，我们可以对路径和目录做任何事情。现在让我们操纵一下文件本身的内容。
>
> 【那么就是修改文件的文本或者是二进制的数据了】
>
> Files.readAllLines() 一次读取整个文件。(因此小文件很有必要)，产生一个 `List<String>`。对于实例文件，将用 `stream/Cheese.data` 作为示例。

```java
public class ListOfLines {
    public static void main(String[] args) throws IOException {
        Files.readAllLines(Paths.get("aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat"))
                .stream()
                .filter(line -> !line.startsWith("//"))
                .map(line -> line.substring(0, line.length() / 2))
                .forEach(System.out::println);
    }
}

/**
输出
Not much of a cheese
Finest in the 
And what leads you 
Well, it's
It's certainly uncon
*/

```

> 跳过注释行，其余的内容每行只打印一半。
>
> 这实现起来很简单：你只需要将 Path 传递给 `readAllLines()` （以前的 Java 实现这个功能很复杂）**【那么我们需要去探究一下以前的是怎样实现的，新的jdk是怎样改进的】** 
>
> `readAllLines()` 有一个重载版本，包含一个 Charset 参数来存储文件的 Unicode 编码。
>
> `Files.writeI()` 被重载以写入 byte 数组或任何 Iterable 对象（它也有 Charset 选项）：

```java
// Writing.java
public class Writing {
    static Random rand = new Random(47);
    static final int SIZE = 1000;

    public static void main(String[] args) throws IOException {
        // Write bytes to a file：
        byte[] bytes = new byte[SIZE];
        rand.nextBytes(bytes);
        Files.write(Paths.get("bytes.dat"), bytes);
        System.out.println("bytes.dat: " + Files.size(Paths.get("bytes.dat")));

        // Write an iterable to a file
        List<String> lines = Files
                .readAllLines(Paths.get("aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat"));

        Files.write(Paths.get("Cheese.txt"), lines);
        System.out.println("Cheese.txt: " + Files.size(Paths.get("Cheese.txt")));

    }
}
/**
输出
bytes.dat: 1000
Cheese.txt: 193
*/ 

```

> 我们使用 	Random 来创建后一个随机的 byte 数组，可以看到生成的文件大小是 1000。
>
> 一个 List 被写入文件，任何 实现 Iterable 接口的对象都可以这么做。
>
> 如果文件大小有问题怎么办？ 比如：
>
> - 文件太大，如果一次性读完整个文件，可能会耗尽内存。
> - 只需要在文件的中途工作获得所需的结果，读取整个文件会浪费时间。
>
> Files.lines() 方便地将文件转换为行的 Stream() `Stream<String>`

```java
// files/ReadLineStream.java
public class ReadLineStream {
    public static void main(String[] args) throws IOException {
        Files.lines(Paths.get("PathInfo.java"))
                .skip(13)
                .findFirst()
                .ifPresent(System.out::println);
    }
}
/**
输出
 * @date 2020/2/23 6:40 下午
 */

```

> 这对本章的第一个示例代码做了流式处理。跳过13行，然后选择下一行并将其打印出来。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200224180526.png)

> `Files.lines()`  对于吧文件处理行的传入流时非常有用【这句话怎么读怎么别扭，还是翻译的问题】 但是如果你想在 Stream 中读取，处理或写入 怎么操作呢？

```java
// StreamInAndOut.java
public class StreamInAndOut {
    public static void main(String[] args) {
        // 这里使用了 try-with-resource
        try (
                Stream<String> input = Files.lines(Paths.get("StreamInAndOut.java"));
                PrintWriter output = new PrintWriter("StreamInAndOut.txt");
        ) {
            input.map(String::toUpperCase)
                    .forEachOrdered(output::println);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200224181131.png)生成的StreamInAndOut.txt 文件。



> 因为w哦们在同一个块中执行所有操作，所以这两个文件都可以在相同的 try-with-resources 语句中打开。
>
> PrintWriter 是一个旧式的 java.io 类，允许你打印到一个文件，所以它是这个应用的理想选择。
>
> 如果你看一下 StreamInAndOut.txt 你会发现里面的内容确实是大写的。

### 本章小结

> 虽然本章对文件和目录操作做了相当全面的介绍，但是仍然有没被介绍的类库中的功能，一定要研究 `java.nio.file` 的 javadocs 尤其是 `java.nio.file.Files` 这个类。

---



### 其他资料

[Path操作](https://zq99299.github.io/java-tutorial/essential/io/pathOps.html)

[Java NIO之拥抱Path和Files](https://segmentfault.com/a/1190000014901038)