---
layout: post
title: 《On Java8》第十五章——异常(3)
date: 2020-02-25
tags:
- 读书笔记
categories: 
- 《On Java8》

---

### Try-With-Resources 用法

> 上面的例子让人头疼。在考虑所有可能发生异常的方法时，找出放置所有 try-catch-finally 块的位置变得令人生畏。
>
> <!-- more -->	
>
> **确保没有任何故障路径，使系统远离不稳定状态，这非常具有挑战性。**
>
> InputFile.java 是一个特别棘手的情况，因为文件被打开（包含所有可能的异常），然后它在对象的生命周期中保持打开状态。每次调用 getLine()都会导致异常，因此可以调用 dispose() 方法【因为当读取流的时候如果出了问题需要关闭这个流】。
>
> 这是一个很好的例子，因为它显示了事物的混乱程度。它还表明你应该尝试最好不要那样设计代码（但是你会遇到这种代码，所以你需要理解它）
>
> InputFile.java 更好的实现是如果构造函数读取文件并在内部缓冲它 —— 这样，文件的打开，读取和关闭都发生在构造函数中。
>
> 或者，如果读取和存储文件不切实际，可以改为 Stream。

**【这句是什么意思没看明白，什么意味着不切实际？】**

> 你可以设计成如下：

```java
// InputFile2.java
public class InputFile2 {
    private String fname;

    public InputFile2(String fname) {
        this.fname = fname;
    }
    public Stream<String> getLines() throws IOException {
        return Files.lines(Paths.get(fname));
    }

    public static void main(String[] args) throws IOException {
        new InputFile2("InputFile2.java").getLines()
                .skip(15)
                .limit(1)
                .forEach(System.out::println);
    }
}
/**
输出
private String fname;
*/
```

**【用了流之后感觉真的好简单。】**

> 现在 getLines() 全权负责打开文件并创建 Stream。
>
> 有时会有以下问题：
>
> 1. 需要资源清理。
> 2. 需要在特定的时刻进行资源清理，比如当离开作用域的时候。（通常情况下意味着通过异常进行清理）。
>
> 一个常见的例子是 `java.io.FileInputStream` 会在 附录：I/O流中提到 。要正确使用它，必须编写一些棘手的样板代码。

```java
// MessyException.java
public class MessyException {
    public static void main(String[] args) {
        InputStream in = null;

        try {
            in = new FileInputStream(new File("MessyException.java"));
            int contents = in.read();
            // 处理 contents
        } catch (IOException e) {
            // 在这里处理创建in的异常
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    // 在这里处理in关闭的异常
                }
            }
        }
    }
}

```

> 当 finally 拥有自己的 try 块时，事情变得过于复杂。
>
> 幸运的是， Java 7 引入了 try-with-resources 语法，可以非常清楚地简化上面的代码：

```java
// TryWithResources.java
public class TryWithResources {
    public static void main(String[] args) {
        try (
                FileInputStream in = new FileInputStream(new File("InputFile2.java"))
        ) {
            int contents = in.read();
            // 处理 contents
            System.out.println(contents);
        } catch (IOException e) {
            // 处理异常
            System.out.println(e);
        }
    }
}

```

> 这里 try 后面跟着的括号定义，是我们创建的 FileInputStream 对象。
>
> 括号内的部分称为 资源规范头(resource specification header)。
>
> 现在可用于整个 try 块的其余部分，最重要的是 无论是否正常退出 try 块，都会执行前一个 finally 子句的等价代码，关闭你打开的资源。
>
> 它是如何工作的？
>
> 在 try-with-resources定义子句中创建的对象（括号内）必须实现 `java.lang.AutoCloaseble` 接口，这个接口有一个方法： close()。 当在 Java 7中引入 AutoCloseable 时，许多接口和类被修改以实现它，查看 javadocs 中的 AutoCloseable 可以看到实现接口类，包括 Stream。

```java
public interface AutoCloseable {
    void close() throws Exception;
}

public interface Stream<T> extends BaseStream<T, Stream<T>> {
  ...
}

public interface BaseStream<T, S extends BaseStream<T, S>>
        extends AutoCloseable {
  ...
}
```

```java
// StreamsAreAutoCloseable.java
public class StreamsAreAutoCloseable {
    public static void main(String[] args) throws IOException {
        try (Stream<String> in = Files.lines(Paths.get("StreamsAreAutoCloseable.java"));
                PrintWriter outfile = new PrintWriter("Results.txt"); //[1]
        ) {
            in.skip(5)
                    .limit(1)
                    .map(String::toLowerCase)
                    .forEachOrdered(outfile::println);
        } //[2]
    }
}

```

> [1] 资源规范头中可以包含多个定义，并且通过分号分割（最后一个分号可以省略）定义的每个对象都会在 try 语句块运行结束之后调用 close() 方法。
>
> [2] try-with-resources 里面的 try 语句块可以不包含 catch 或者 finally 语句而独立存在。在这里 IOException 被 main() 方法抛出，所以这里不需要在 try 后面跟着一个 catch 语句块。
>
> **Java 5 中的 Closeable 已经被修改，修改之后的接口继承了 AutoCloseable 接口。所以所有实现了 Closeable 接口的对象，都支持了 try-with-resources 特性。**

#### 揭示细节

> 下面创建一个自己的 AutoCloseable 类：

```java
// exceptions/AutoCloseableDetails.java
// AutoCloseableDetails.java
class Reporter implements AutoCloseable {
    String name = getClass().getSimpleName();

    public Reporter() {
        System.out.println("Createing: " + name);
    }

    @Override
    public void close() {
        System.out.println("Closing " + name);
    }
}

class First extends Reporter {
}

class Second extends Reporter {
}


public class AutoCloseableDetails {
    public static void main(String[] args) {
        try (
                First first = new First();
                Second second = new Second()
        ) {
        }
    }
}

/**
输出
Creating First
Creating Second
Closing Second
Closing First
*/
```

> 退出 try 块会调用两个对象的 close() 方法，并以与创建顺序相反的顺序关闭它们。
>
> **顺序很重要**，因为在此配置中，Second 对象可能依赖于 First 对象，因此如果 First 在 Second 关闭之前已经关闭，那么 Second 的 close() 可能会尝试访问 First中某些不再可用的功能。



> 加入我们在 资源规范头 中定义了一个不是 AutoCloseable 的对象：

```java
// exceptions/TryAnything.java
// {WillNotCompile}
class Anything {}
public class TryAnything {
    public static void main(String[] args) {
        try(
                Anything a = new Anything()
        ) {
        }
    }
}
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200227160524.png)

> **正如我们所期望那样：编译器会检查并报错。**

> 如果其中一个构造函数抛出异常怎么办？

```java
// ConstructorException.java
class CE extends Exception {

}
// 继承的类实现了 AutoCloseable接口
class SecondExcept extends Reporter {
    public SecondExcept() throws CE{
        super();
        throw new CE();
    }
}

public class ConstructorException {
    public static void main(String[] args) {
        try (
                final First first = new First();
                SecondExcept s = new SecondExcept();
                Second s2 = new Second();
        ) {
            System.out.println("In body");
        } catch (CE ce) {
            System.out.println("Caught: " + ce);
        }
    }
}

/**
输出
Createing: First
Createing: SecondExcept
Closing First
Caught: exceptions.CE
*/

```

> 这里资源规范头中定义了3个对象，中间的对象在构建过程中抛出了异常。
>
> **因此 编译器强制我们使用 catch 子句来捕获构造函数异常。这意味着资源规范头实际上被 try 块包围。**
>
> 正如预期，First 创建时没有发生异常，SecondExcept 在创建期间抛出异常。这里看输出 并没有调用 SecondExcept 的关闭函数，**因为如果构造函数失败，则无法假设你快要安全地对该对象执行任何操作，包括关闭它。**
>
> 由于 SecondExcept 的异常，Second 对象不会被创建，也就不会被清理。



> 如果没有构造函数抛出异常，但你可能会在 try 的主体重获取它们，则再次强制你实现 catch 子句：

```java
// exceptions/BodyException.java

class Third extends Reporter {
}

public class BodyException {
    public static void main(String[] args) {
        try (
                final First first = new First();
                final Second second = new Second()
        ) {
            System.out.println("In boyd");
            final Third t = new Third();
            final SecondExcept secondExcept = new SecondExcept();
            System.out.println("End of body");
        } catch (CE ce) {
            System.out.println("Caught " + ce);
        }
    }
}
/**
输出
Creating First
Creating Second
In body
Creating Third
Creating SecondExcept
Closing Second
Closing First
Caught: CE
*/
```



> **第三个创建的对象永远不会被清除，因为没有在 资源规范头中创建，所以没有被保护。**
>
> Java 在这里没有以警告或错误的形式提醒，如果使用集成开发环境来编写 try-with-resources 特性，那么它只会保护它们遇到的第一个对象，而忽略其他对象。



> 最后，来一个抛出异常的 `close()` 方法：



```java
// CloseExceptions.java
class CloseException extends Exception {

}

class Report2 implements AutoCloseable {
    String name = getClass().getSimpleName();

    public Report2() {
        System.out.println("Creating: " + name);
    }


    @Override
    public void close() throws CloseException { // 声明抛出异常，但是实际没有抛出
        System.out.println("Closing " + name);

    }
}

class Closer extends Report2 {
    @Override
    public void close() throws CloseException { // 覆写父类方法 抛出异常
        super.close();
        throw new CloseException();
    }
}

public class CloseExceptions {
    public static void main(String[] args) {
        try (
                final First first = new First();
                final Closer closer = new Closer();
                final Second second = new Second()

        ) {
            System.out.println("In body");
        } catch (CloseException e) {
            System.out.println("Caught " + e);
        }
    }
}

/**
输出
Creating First
Creating Closer
Creating Second
In body
Closing Second
Closing Closer
Closing First
Caught: CloseException
*/
```

**【这里结果跟我预想的不一样，我以为当关闭 Closer 发生异常后 First 就无法被关闭了。结果还是正常关闭了，最后才进入 catch 子句】**



> 从技术上来讲，对于 Closer 可能抛出的异常没有强制捕获，也可以抛出，但是 catch 子句是放置错误处理代码的典型位置。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200227162415.png)

**【抛出并运行之后的结果，该异常被打印】**



> 请注意，三个对象都已经创建，所以它们都已相反的顺序关闭，即使 Closer 也是如此。
>
> Closer.close() 抛出异常，这就是你想要发生的事。但是如果你必须自己编写这些异常处理的逻辑，那么你可能会错过一些错误。
>
> 应始终尽可能使用 try-with-resource 。它有助于实现该功能，使得代码更清晰，更易于理解。







### 异常匹配

> 抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的 catch 处理程序。
>
> 找到匹配的处理程序之后，它就认为异常得到处理，然后就不再查找。
>
> 查找的时候并不要求抛出的异常和 Catch 的异常类型完全匹配。Catch 处理程序可以匹配 子类的异常对象：

```java
// Human.java
class Annoyance extends Exception {
}

class Sneeze extends Annoyance {

}

public class Human {
    // 捕获更具体的异常类型
    public static void main(String[] args) {
        try {
            throw new Sneeze();
        } catch (Sneeze sneeze) {
            System.out.println("捕获Sneeze");
        } catch (Annoyance a) {
            System.out.println("捕获 Anooyance");
        }

        // 捕获基本父类异常
        try {
            throw new Sneeze();
        } catch (Annoyance annoyance) {
            System.out.println("捕获父类异常Anooyance");
        }
    }
}
/**
捕获Sneeze
捕获父类异常
*/
```

> 第一个例子匹配到了最近的子类异常对象，就不再继续匹配了。
>
> 第二个例子可以看到 Catch 语句只要捕获的是抛出对象的父类异常，则程序依然正常，这意味着如果决定在方法里增加更多子类异常的话，只要客户端程序员捕获的是基类异常，那么它们的代码就无需修改。

> 如果将捕获基类的 catch 子句放在前面：

```java
try {
    throw new Sneeze();
} catch(Annoyance a) {
    // ...
} catch(Sneeze s) {
    // ...
}
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200227163615.png)

编译器会报错。

### 其他可选方式

> 异常处理系统就像一个活门（trap door），是你能放弃程序正常的执行序列。
>
> 当异常情形发生时，正常的执行流程已经变得不可能或者不需要了，这时就需要用到这个"活门"。
>
> 异常代表了当前方法不能继续执行的情况。
>
> 开发异常处理系统的原因是，如果为每个方法所有可能发生的错误都进行处理的话，任务就显得过于繁重，结果常常是将错误忽略。
>
> **应该注意到，开发异常处理的初衷是为了方便 程序员处理错误。**
>
> 异常处理一个重要的原则是"只有在你知道如何处理的情况下才捕获异常"。
>
> **Throw Early  Catch Later，否则很容易造成异常侵吞，系统出错终止了，却找不到原因。**

#### 历史

【讲了一些异常的历史和C++的历史，没啥大用。】

#### 观点

【作者认为 Java 被检查的异常没啥大用，当程序规模开始膨胀，大量的异常会变得无法管理。】

> **作者认为使用异常实际的好处在于：**
>
> 1. 不在于编译器是否强制程序员处理错误，而是要有一致的事业异常报告错误的模型。
> 2. 不在于什么时候进行检查，而是一定要有类型检查。也就是必须强制程序使用正确的类型，至于这种强制措施是编译时还是运行时都无所谓。

#### 把异常传递给控制台

> 对于简单的异常，可以将其信息直接传递给控制台：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200227184909.png)

**【也就是直接抛出异常。】**

#### 把被检查的异常转换为不检查的异常

> 当你在一个普通方法里调用别的方法时，要考虑不知道该如何处理异常，也不能将其侵吞后啥也不处理，或者打印一些没用的信息。
>
> 异常链提供了一个新的思路来解决这个问题：
>
> 将被检查的异常包装进运行时异常里面：

```java
try {
	//业务代码
} catch(受检查的异常类型 e) {
		throw new RuntimeException(e)
}
```



> 如果想屏蔽掉被检查异常的编译器显示处理要求并且不吞下异常的话，这个方法不错，异常链保证了不丢失原始异常信息。
>
> 这种技巧带来了一种选择：不写 try-catch 子句或异常说明，直接忽略异常，让它自己沿着调用栈网上冒泡，同时还可以用 getCause() 并处理特定异常，就像这样：

```java
// TurnOffChecking.java
class WrapCheckedException {
    void throwRuntimeException(int type) {
        try {
            switch (type) {
                case 0:
                    throw new FileNotFoundException();
                case 1:
                    throw new IOException();
                case 2:
                    throw new
                            RuntimeException("Where am I?");
                default:
                    return;
            }
        } catch (IOException | RuntimeException e) {
            // Adapt to unchecked:
            throw new RuntimeException(e);
        }
    }
}


class SomeOtherException extends Exception {
}

public class TurnOffChecking {
    public static void main(String[] args) {
        WrapCheckedException wce = new WrapCheckedException();
        wce.throwRuntimeException(3);

        for (int i = 0; i < 4; i++) {
            try {
                if (i < 3) {
                    wce.throwRuntimeException(i);
                } else {
                    throw new SomeOtherException();
                }
            } catch (SomeOtherException e) {
                System.out.println("SomeOtherException " + e);
            } catch (RuntimeException re) {
                try {
                    throw re.getCause();
                } catch (FileNotFoundException e) {
                    System.out.println("FileNotFound Exception: " + e );
                } catch (IOException e) {
                    System.out.println("IOException: " + e);
                } catch (Throwable throwable) {
                    System.out.println("Throwable: " + throwable);
                }
            }
        }
    }
}
/**
输出
FileNotFound Exception: java.io.FileNotFoundException
IOException: java.io.IOException
Throwable: java.lang.RuntimeException: Where am I?
SomeOtherException exceptions.SomeOtherException
*/
```

> `WrapCheckedException.throwRuntimeException()` 的代码可以生成不同类型的异常。这些异常被捕获并包装进了 `RuntimeException` 对象，所以它们成了这些运行时异常的"`cause`"了。
>
>  `throwRuntimeException()` 捕获了方法可能抛出的异常并重新抛出运行时异常。
>
> 但是，当你准备好去捕获异常的时候，**还是可以用 try 块来捕获任何你想捕获的异常的**。应该捕获 try 块肯定会抛出的异常，这里就是 SomeOtherException，RuntimeException 要放到最后去捕获。





### 异常指南

> 应该在下列情况下使用异常：
>
> - **尽可能使用 try-with-resource。**
>
> - **在恰当的级别处理问题（只有当你知道该如何处理的时候才捕获异常）**
> - **解决问题并重新调用产生异常的方法。**
> - **进行少许修补，然后绕过异常发生的地方继续执行。**
>
> - **把别的数据进行计算，以代替方法预计会返回的值。**
> - **把当前运行环境下能做的事情尽量做完，然后把 相同 的异常抛到更高层。**
> - **把当前运行环境下能做的事情尽量做完，然后把 不同 的异常抛到更高层。**
> - **终止程序**
> - **进行简化（如果异常模式使问题太复杂，那用起来也很痛苦）**
> - **让类库和程序更安全。**
>
> 

### 本章小结

**异常是 Java 程序设计不可分割的一部分，如果不了解如何使用它们，那你只能完成很有限的工作**。正因为如此，本书专门在此介绍了异常——对于许多类库（例如提到过的 I/O 库），如果不处理异常，你就无法使用它们。

**异常处理的优点之一就是它使得你可以在某处集中精力处理你要解决的问题**，而在另一处处理你编写的这段代码中产生的错误。

就像你将要在后续章节中看到的，通过将这个问题甩给其他代码-即使你是通过抛出 RuntimeException 来实现这一点的--你在设计和实现时，便可以专注于更加有趣和富有挑战性的问题了。



### 个人总结：

其实异常这块最核心的就是不要侵吞异常，不处理又把异常吞掉是真的很坑。

写了这些 Demo 比较大的收获就是 finally 的各种姿势 和了解了 try-with-resource的机制，这样就可以实现自己的自动关闭的类了，真的很方便。

还是那句话 28法则，80%以前干活的时候都用到了，但是有20%的收获就已经很好了，每天进步一些，积累下来就是很多。