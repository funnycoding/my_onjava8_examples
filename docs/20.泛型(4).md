### 补偿擦除

> 因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：

```java
	// Erased.java
public class Erased <T> {
    private final int SIZE = 100;
    public void f(Object arg) {
        // error: illegal generic type for instanceof
        // 无法对泛型参数 T 使用 instanceof 操作符
     /*   if (arg instanceof T) {

        }*/

        // error: unexpected type
        // 不能实例化 T 类型的对象 因为 T 不是一个确切的类
        //T t = new T();

        // error: generic array creation
        // 同理，不能创建 T类型的数组 但是可以进行类型强转创建数组
        //T[] array = new T[SIZE];
        // warning: [unchecked] unchecked cast
        T[] array = (T[]) new Object[SIZE];
    }
}

```

> 有时，我们可以对这些问题进行编程，但是有时必须通过**引入类型标签来补偿擦除**。这意味着我们为所需的类型显式传递一个 Class 对象，以在类型表达式中使用它。
>
> 例如，由于擦除了类型信息，因此在上一个程序中尝试使用 instanceof 将会失败。类型标签可以使用动态 `isInstance()` :

```java
// 使用 isInstance() 来确认泛型类的类型参数
// ClassTypeCapture.java
class Building {

}

class House extends Building {

}

public class ClassTypeCapture<T> {
    Class<T> kind;

    public ClassTypeCapture(Class<T> kind) {
        this.kind = kind;
    }

    // 变向实现判断类类型
    public boolean f(Object arg) {
        return kind.isInstance(arg);
    }

    public static void main(String[] args) {
        ClassTypeCapture<Building> ctt1 = new ClassTypeCapture<>(Building.class);

        System.out.println(ctt1.f(new Building()));
        System.out.println(ctt1.f(new House()));
        ClassTypeCapture<House> ctt2 = new ClassTypeCapture<>(House.class);
        System.out.println(ctt2.f(new Building()));
        System.out.println(ctt2.f(new House()));

    }

}

/**
输出
true
true
false
true
*/
```

> 编译器来保证**类型标签（type tag)**与泛型参数(generic argument)相匹配。

#### 创建类型的实例

> 试图在 `Erased.java` 中 使用 `new` 关键字创建 泛型参数 T 的对象 `new T()` 是行不通的，部分原因是因为擦除，部分原因是编译器无法验证 T 是否含有无参构造函数。
>
> 但是在 C++ 中，此操作自然，直接且安全：（C++ 编译器可以在编译时检查类型）

**【又到了作者熟悉的比较 Java 与 C++ 的时间，而且一般是 C++ 吊打 Java...】**

```c++
// generics/InstantiateGenericType.cpp
// C++, not Java!

template<class T> class Foo {
  T x; // Create a field of type T
  T* y; // Pointer to T
public:
  // Initialize the pointer:
  Foo() { y = new T(); }
};

class Bar {};

int main() {
  Foo<Bar> fb;
  Foo<int> fi; // ... and it works with primitives
}
```

> 这里又是 C++ 的代码。作者是想告诉我们再 C++ 中是可以完成 `new T()` 这种操作的。



> Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 Class 对象，因此如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：

```java
// 创建类的工厂
// generics/InstantiateGenericType.java
class ClassAsFactory<T> implements Supplier<T> {
    Class<T> kind;

    public ClassAsFactory(Class<T> kind) {
        this.kind = kind;
    }

    @Override
    public T get() {
        try {
            return kind.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}


class Employee {
    @Override
    public String toString() {
        return "Employ";
    }
}


public class InstantiateGenericType {
    public static void main(String[] args) {
        ClassAsFactory<Employee> fe = new ClassAsFactory<>(Employee.class);
        System.out.println(fe.get());
        ClassAsFactory<Integer> fi =
                new ClassAsFactory<>(Integer.class);
        try {
            System.out.println(fi.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
/**
输出
Employee
java.lang.InstantiationException: java.lang.Integer
*/
```

> 这里使用 `ClassAsFactory<Integer>` 创建对象失败是因为 Integer 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，**以便只有实现该工厂的类可以这样创建对象。**
>
> 这是创建工厂的两种不同方法：

```java
// generics/FactoryConstraint.java
class IntegerFactory implements Supplier<Integer> {
    private int i = 0;

    @Override
    public Integer get() {
        return i++;
    }
}


class Widget {
    private int id;

    public Widget(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Widget " + id;
    }

    // Widget 的工厂
    public static class Factory implements Supplier<Widget> {
        private int i = 0;

        @Override
        public Widget get() {
            return new Widget(++i);
        }
    }

}

class Fudge {
    private static int count = 1;
    private int n = count++;

    @Override
    public String toString() {
        return "Fudge " + n;
    }
}

class Foo2<T> {
    private List<T> x = new ArrayList<>();

    // 生成 5个 Supplier 工厂生产的对象
    Foo2(Supplier<T> factory) {
        Suppliers.fill(x, factory, 5);
    }

    @Override
    public String toString() {
        return x.toString();
    }
}


public class FactoryConstraint {
    public static void main(String[] args) {
        System.out.println(new Foo2<>(new IntegerFactory()));
        System.out.println(new Foo2<>(new Factory()));
        System.out.println(new Foo2<>(Fudge::new));
    }
}

```

> `IntegerFactory`  实现了`Supplier<Integer>` 接口。 `Widget` 包含一个内部类，它是一个工厂。
>
> `Fudge` 没有任何类似工厂的操作，并且传递的是 `Fudege::new` ，但是仍然会产生工厂行为，因为编译器对函数方法 `:: new` 的调用转换为 对 `get()` 的调用

**【个人理解其实就是把无参构造函数与 Supplier 的get() 方法进行了方法绑定】**

> 另一种方法是 **模板方法** 设计模式。在下例中，create() 是模板方法，在子类中被重写以生成该类型的对象：

```java
// generics/CreatorGeneric.java
abstract class GenericWithCreate<T> {
    final T element;

    // 创造Creator 的时候就默认调用了子类的 create() ，创建了工厂目标对象的实例
    GenericWithCreate() {
        element = create();
    }

    // 让子类实现自己不同的工厂方法
    abstract T create();
}

class X {

}

// 类 X 的工厂类
class XCreator extends GenericWithCreate<X> {


    @Override
    X create() {
        return new X();
    }

    // 打印对象类名
    void f() {
        System.out.println(element.getClass().getSimpleName());
    }

}


public class CreatorGeneric {
    public static void main(String[] args) {
        XCreator xc = new XCreator();
        xc.f();
    }
}

```

> `GnericWithCrate` 包含 `element` 字段，**并通过无参构造函数强制其初始化**，该构造函数又调用抽象 `create`() 方法。
>
> 这种创建方式可以在子类中定义，同时确定 T 的类型。

#### 泛型数组

> 正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList**：

```java
// generics/ListOfGenerics.java
// 泛型类使用 ArrayList 存储类型对象实例
public class ListOfGenerics<T> {
    private List<T> array = new ArrayList<>();

    public void add(T t) {
        array.add(t);
    }

    public T get(int index) {
        return array.get(index);
    }
}
```

> 这样做可以获得数组的行为，**并且还具有泛型提供的编译时类型安全性。**
>
> 有时，仍然会创建泛型类型的数组（例如，**ArrayList** 内部使用数组）。
>
> 可以通过使编译器满意的方式定义对数组的通用引用：

```java

// generics/ArrayOfGenericReference.java
class Generic<T> {

}


public class ArrayOfGenericReference {
    // 定义一个泛型类的数组
    static Generic<Integer>[] gia;
}

```

> 编译器接受了这个泛型类数组的定义而没有产生警告。但是我们**永远无法创建**具有**该确切类型**（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组的插槽的大小和数组的布局），因此似乎可以**创建一个 Object 数组并将其转换为所需的数组类型**。
>
> 实际上这**确实可以编译**，但是会产生 类转换异常 **ClassCastException**：

```java
// generics/ArrayOfGeneric.java
    
public class ArrayOfGeneric {
    static final int SIZE = 100;
    static Generic<Integer>[] gia;

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        try {
            // 创建一个 Object 数组并将其强转为 Generic<Integer> 数组
            gia = (Generic<Integer>[]) new Object[SIZE];
        } catch (ClassCastException e) {
            System.out.println(e.getMessage());
        }
        // Runtime type is the raw (erased) type:
        // 运行时类型是泛型擦除的
        gia = (Generic<Integer>[]) new Generic[SIZE];
        System.out.println(gia.getClass().getSimpleName());
        gia[0] = new Generic<>();
        //gia[1] = new Object(); // Compile-time error  编译器告诉你需要一个 Generic 类
        // Discovers type mismatch at compile time:
        //gia[2] = new Generic<Double>(); // 类型参数错误，之前顶一个 Generic[] 的类型参数是 Integer

    }
}
/**
输出
[Ljava.lang.Object; cannot be cast to [Lgenerics.Generic;
Generic[]
*/

```

> 问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ， **该信息也仅在编译时存在**（并且没有 @SuppressWarnings 注解，将会收到有关该强制转换的警告）。
>
> **在运行时，它仍然是一个 `Object` 数组**。 这会引起问题。 **成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。**
> 让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：

```java
// GenericArray.java
public class GenericArray<T> {
    private T[] array;

    @SuppressWarnings("unchecked")
    public GenericArray(int sz) {
        array = (T[]) new Object[sz];
    }

    public void put(int index, T item) {
        array[index] = item;
    }

    public T get(int index) {
        return array[index];
    }

    // Method that exposes the underlying representation:
    // 返回当前 T 类型的数组
    public T[] rep() {
        return array;
    }

    public static void main(String[] args) {
        GenericArray<Integer> gai = new GenericArray<>(10);
        try {
            Integer[] ia = gai.rep();
        } catch (ClassCastException e) {
            System.out.println(e.getMessage());
        }
        // This is OK: 这是正常的 但是实际上这里需要对返回的数组做 Object 的强转，而作者并没有这样写
        Object[] oa = (Object[]) gai.rep();
    }
}
/**
输出
[Lorg.omg.CORBA.Object; cannot be cast to [Lonjava.Count$Integer;
*/
```

> 和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 Object 数组，并将其强制转换为 `T`类型的数组。
>
> `rep()` 方法返回一个 `T[]`，在主方法中它应该是 `gai` 的 `Integer[]` ，但是如果调用它并尝试将它转为 `Integer[]` 引用，就会得到类转换异常，这是因为实际运行类型是 `Object[]`
>
> 如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：

```
GenericArray.java uses unchecked or unsafe operations.
Recompile with -Xlint:unchecked for details.
```

![image-20200313213232266](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200313213232.png)

其实 IDEA 中只会提示这个。

> 在这里，我们收到了一个警告，我们认为这是有关强制转换的。
>
> 但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：

```
GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
```

> 确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
>
> 由于**擦**除，**数组的运行时类型只能是 `Object[]`** 。 如果我们立即将其转换为 `T[]` ，**则在编译时会丢失数组的实际类型**，并且编译器可能会错过一些潜在的错误检查。因此，**最好在集合中使用 `Object[]`** ，**并在使用数组元素时向 T 添加强制类型转换**。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：

**【意思就是定义数组不要进行强制转换的泛型定义，而是定义为 Object[] 使用时再进行转换】**

```java
// generics/GenericArray2.java
// 泛型数组的元素 put 和 get 都正常，但是将数组强转为泛型类型的数组仍然会抛出类型转换异常
public class GenericArray2<T> {
    private Object[] array;

    public GenericArray2(int sz) {
        array = new Object[sz];
    }

    public void put(int index, T item) {
        array[index] = index;
    }

    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index]; // Unchecked cast
    }

    @SuppressWarnings("unchecked")
    public T[] rep() {
        return (T[]) array; // 将当前数组用泛型参数进行类型强转
    }


    public static void main(String[] args) {
        GenericArray2<Integer> gai = new GenericArray2<>(10);
        for (int i = 0; i < 10; i++) {
            gai.put(i, i);
        }

        for (int i = 0; i < 10; i++) {
            System.out.print(gai.get(i) + " ");
        }
        System.out.println();

        try {
            Integer[] rep = gai.rep(); // 仍然会抛出类型转换异常
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
/**
输出
0 1 2 3 4 5 6 7 8 9 
[Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
*/
```

> 这个例子与上个不同的是，这个例子中保存的是 `Object[]` 而不是 `T[]` ，调用` get()` 时，将对象强制转换为 T类型，实际上这是正确的类型，因此很安全。
>
> 但是如果调用 `rep()` 它将再次尝试将 `Object[]` 转为` T[]`，但仍然不正确，并在编译时生成警告并在运行时生成异常。
> 因此，无法破坏基础数组的类型，基础数组只能是 `Object[]` 。 在内部将数组视为 `Object[]` 而不是 `T[]`的优点是：我们不会忘记数组的运行时类型并意外地引入Bug。尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。

**【也就是靠程序员自己进行类型转换，并且这种转换发生的概率不高，因为程序员自己清楚自己的泛型数组存储的是什么类型的元素】**

> 对于新代码，请传入类型标记，在这种情况下 泛型数组 **GenericArray** 如下所示：

```java
// generics/GenericArrayWithTypeToken.java
public class GenericArrayWithTypeToken<T> {
    private T[] array;


    // 生成对应类型的指定长度的数组并进行类型强转 这里跟之前不一样的就是这里构造的数组是根据 Class 构造的对应类型的数组 而前面都是 Object[]
    @SuppressWarnings("unchecked")
    public GenericArrayWithTypeToken(Class<T> type, int sz) {
        array = (T[]) Array.newInstance(type, sz);
    }

    public void put(int index, T item) {
        array[index] = item;
    }

    // 在这里也不需要对元素进行强转，因为之前的数组已经被强转为对应类型
    public T get(int index) {
        return array[index];
    }

    // Expose the underlying representation:
    public T[] rep() {
        return array;
    }

    public static void main(String[] args) {
        GenericArrayWithTypeToken<Integer> gai = new GenericArrayWithTypeToken<>(
                Integer.class, 10);
        // 此时不会在生成类型转换异常 it works
        Integer[] rep = gai.rep();
    }
}
```

**【这三个例子牛逼啊，有意思，值得仔细看啊】**

> 类型标记 Class<T> 被传递到构造函数中以恢复被擦除的类型，因此尽管必须使用 @SuppresWarrnings 关闭来自强制类型转换的警告，但是**我们仍然可以创建所需的实际数组类型。**
>
> 一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样，**数组的运行时类型是确切的类型 `T[]`。**
>
> 不幸的是，如果查看 Java 标准库的源代码，你会发现导出都有从 Object 数组到参数化类型的转换。 例如，这是从 ArrayList 中赋值一个 Collection 的构造函数，这里为了简化，去除了源码中对此不重要的代码：

```java
public ArrayList(Collection c) {
  size = c.size();
  elementData = (E[])new Object[size];
  c.toArray(elementData);
}
```

【这里 JDK8 的源码已经变了，使用了 copyOf】

![image-20200314102504501](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200314102504.png)

> 如果你浏览 ArrayList.java 的代码，就会发现有很多此类强制转换，而这样的代码编译时会获得警告

【但是我可以看到 JDK 的代码一直在改进，并且我的 IDEA 编译时好像并没有警告。。。】

> Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 **Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法**。**当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。**

**【说明了 JDK 库也是人写出来的，是人就会犯错误，所以也不能太神话源码。】**



> 请注意，**在 Java 文献中推荐使用类型标记技术**，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。

