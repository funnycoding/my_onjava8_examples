### 构建复杂模型

> 泛型的一个重要好处是能够简单安全地创建复杂模型。
>
> 例如我们可以轻松地创建一个元组列表：

```java
// TupleList.java
// 这个是一个继承ArrayList，并且 ArrayList的类型参数是 Tuple4<A,B,C,D> 的 Tuple4 列表类

public class TupleList<A, B, C, D> extends ArrayList<Tuple4<A, B, C, D>> {
    public static void main(String[] args) {
        TupleList<Vehicle, Amphibian, String, Integer> tl = new TupleList<>();
        Tuple4<Vehicle, Amphibian, String, Integer> h = TupleTest2.h();
        tl.add(h);
	      //tl.addall(h); // 这里报错，因为 h() 生成的是一个 Tuple4 对象，而不是一个 Collection 不知道作者为什么会这么写
        tl.forEach(System.out::println);
    }
}

```

> 这将产生一个功能强大的数据结构，而无需太多代码。
>
> 下面是第二个例子：每个类都是组成块，总体包含很多块。这里模型是一个具有**过道**、**货架**和**产品**的零售商店：

```java
// Store.java
// 挺有意思的例子，多个数据结构封装
class Product {
    private final int id;
    private String description;
    private double price;

    public Product(int id, String description, double price) {
        this.id = id;
        this.description = description;
        this.price = price;
    }

    @Override
    public String toString() {
        return id + ": " + description + ", price $" + price;
    }

    public void priceChange(Double change) {
        price += change;
    }

    // 随机商品生成器
    public static Supplier<Product> generator =
            new Supplier<Product>() {
                private Random rand = new Random(47);

                @Override
                public Product get() {
                    return new Product(rand.nextInt(1000), "Test",
                            Math.round(rand.nextDouble() * 1000) + 0.99);
                }
            };
}

// 货架，其中包含商品
class Shelf extends ArrayList<Product> {
    Shelf(int nProducts) {
        // 这个 fill 方法很有意思，值得弄清楚
        Suppliers.fill(this, Product.generator, nProducts);
    }
}

// 向 Aisle 通道中添加货架
class Aisle extends ArrayList<Shelf> {
    Aisle(int nShelves, int nProducts) {
        for (int i = 0; i < nShelves; i++) {
            add(new Shelf(nProducts));
        }
    }
}

// 收银台
class CheckoutStand {
}

// 办公室
class Office {
}


public class Store extends ArrayList<Aisle> {
    // 先来个收银台列表
    private ArrayList<CheckoutStand> checkouts = new ArrayList<>();
    // 再来个办公室
    private Office office = new Office();

    public Store(int nAisles, int nShelves, int nProducts) {
        // 往走廊中添加 货架和产品
        for (int i = 0; i < nAisles; i++) {
            add(new Aisle(nShelves, nProducts));
        }
    }


    // 打印每个过道的每个货架中的每个商品
    @Override
    public String toString() {
        StringBuilder result = new StringBuilder();
        for (Aisle a : this) {
            for (Shelf s : a) {
                for (Product p : s) {
                    result.append(p);
                    result.append("\n");
                }
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        // 5个走廊，每个走廊4个货架，每个货架3个商品
        System.out.println(new Store(5, 4, 3));
    }
}
/**
前8行输出
/* Output: (First 8 Lines)
258: Test, price: $400.99
861: Test, price: $160.99
868: Test, price: $417.99
207: Test, price: $268.99
551: Test, price: $114.99
278: Test, price: $804.99
520: Test, price: $554.99
140: Test, price: $530.99
                  ...
*/
```



### 泛型擦除

> Java 中的泛型本质还是编译器做的语法糖，落地到 JVM 中 泛型类与普通类没有区别。
>
> 例如：可以说 ArrayList.class 但是没有 `ArrayList<Integer>.class` 后者与前者在 JVM 中并无区别:

```java
// ErasedTypeEquivalence.java
public class ErasedTypeEquivalence {
    public static void main(String[] args) {
        Class c1 = new ArrayList<String>().getClass();
        Class c2 = new ArrayList<Integer>().getClass();
        System.out.println(c1 == c2);
    }
}
// ture
```

![image-20200313111243563](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200313111243.png)

**【看一下编译器生成得字节码你就会发现这俩本质都是 ArrayList，类型参数消失了。】**

> `ArrayList` 和 `ArrayList` **应该**是不同的类型。**不同的类型会有不同的行为**。例如，如果尝试向 `ArrayList` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList` 中放入一个 `Integer` 所得到的行为（成功）完全不同。**然而上面的程序认为它们是相同的类型**。

> 下面的例子是一个补充：

```java
// generics/LostInformation.java
class Frob {

}

class Fnorkle {

}

class Quark<Q> {

}

class Particle<POSITION, MOMENTUM> {

}

public class LostInformation {
    public static void main(String[] args) {
        List<Frob> list = new ArrayList<>();
        Map<Frob, Fnorkle> map = new HashMap<>();
        Quark<Fnorkle> quark = new Quark<>();
        Particle<Long, Double> p = new Particle<>();

        // 打印这些类的类型参数
        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
    }
}
/**
输出
[E]
[K,V]
[Q]
[POSITION,MOMENTUM]
*/
```

> 根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...”
>
> 但是可以看到这里返回的都是类定义的类型参数名而不是实际放入的类型参数。
>
> 残酷的现实是：
>
> **在泛型代码内部，无法获取任何有关泛型参数类型的信息。**
>
> 因此，你可以知道如类型参数标识符和泛型边界这样的信息，但无法得知实际类型参数从而用来创建特定的实例。
>
> Java 泛型是使用擦除实现的。意味着当你在使用泛型时，任何具体的类型都被擦除了。你唯一知道的就是你在使用一个对象。
>
> 因此 `List<String>` 和 `List<Integer>` 在运行时是相同的类型，它们都被擦除成原生类型 `List`。
>
> 理解擦除并知道如何处理它，是学习泛型时面临的最大障碍之一。也是本章需要讨论的问题。
>
> 

#### C++的方式

**【这里因为作者本身是 C++ 大神，所以难免将 Java 中的泛型与 C++ 中的处理方式进行类比。我们可以学习一下不同语言对相同问题的不同处理思路】**



> 下面是使用模板的 C++ 示例 。 你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：



```c++
// generics/Templates.cpp
#include <iostream>
using namespace std;

template<class T> class Manipulator {
    T obj;
public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
};

class HasF {
public:
    void f() { cout << "HasF::f()" << endl; }
};

int main() {
    HasF hf;
    Manipulator<HasF> manipulator(hf);
    manipulator.manipulate();
}
/* Output:
HasF::f()
*/
```

【这个例子是C++ 的，我没有安装 CLion 就不写了，大概读一读】

> Manipulator 类存储了一个 T 类型的对象【就像 Java 中的泛型类】。manipulate() 方法会调用 具体传入类的 f() 方法。
>
> 那么这个泛型类是如何知道 T 类型中一定有 f() 这个方法的呢？
>
> C++ 编译器会在你实例化模板时进行检查。所以在 `Manipulator<Hasf>` 实例化的那一刻，编译器看到`Manipulator` 所持有的类 `Hasf` 中存在 一个 `f(`) 方法。**如果不存在，则编译器报错，保持类型的安全。**

【所以C++ 中的模板是真正的泛型，编译器可以知道模板中存放的类中的具体的方法】

> 用 C++ 编写这种方法很简单，因为当模板被实例化时，模板代码就知道模板参数的类型。
>
> Java 泛型就不同了。下面是 HasF 的 Java版本：

```java
// generics/HasF.java

public class HasF {
    public void f() {
        System.out.println("HasF.f()");
    }
}
```



> **如果我们将示例代码的其余部分用 Java 实现，则无法通过编译：**

```java
// Manipulation.java
class Manipulator<T> {
    private T obj;

    public Manipulator(T obj) {
        this.obj = obj;
    }

    // 编译器会抛出异常，找不到 f() 方法
    public void manipulate() {
        System.out.println(obj);
        //System.out.println(obj.f()); // 找不到 f 方法
    }
}


// generics/Manipulation.java
// {WillNotCompile}
public class Manipulation {
    public static void main(String[] args) {
        Hasf hf = new Hasf();
        Manipulator<Hasf> manipulator = new Manipulator<Hasf>(hf);
        manipulator.manipulate();
    }
}

```



> 可以看到因为擦除， Java 编译器无法确定 manipulate() 方法 一定能调用传入类型对象的 f() 方法。同时 编译器无法在编译时确定  `Manipulator<Hasf> manipulator = new Manipulator<Hasf>(hf);` 中的 Hasf 对象具有 f() 方法。
>
> 为了调用 f() ，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个**边界**的类型。 这里重用了 `extends` 关键字。由于有了边界，下面的代码就能通过编译：

```java
// Manipulator2.java
public class Manipulator2 <T extends Hasf> {
    private T obj;

    Manipulator2(T x) {
        obj = x;
    }
    // 因为类型参数一定继承 Hasf 所以一定具有 f()
    public void manipulate() {
        obj.f();
    }
}

```

> 边界  `<T extends HasF>` 确定了 T 必须是 HasF 类型或其子类，则编译器可以确定 该泛型类一定具有 `f()` 方法。
>
> 我们说泛型类型参数会擦除它的第一个边界（可能有多个边界，稍后会看到）我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的例子，T 擦除到了 HasF，就像在类的声明中用 HasF 替换了 T 一样。
>
> 这里感觉翻译不太好：
>
> **【类型参数 T 被擦除替换为 HasF，就像类中定义的泛型参数 T 被替换成了 具体的类型 HasF】** 大概就是那么个意思，我感觉我表达的也不太好所以就不提pr了。 还是得配合字节码自己看，非常的直观。



![image-20200313114558944](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200313114559.png)

**【可以根据字节码看到，这里将全部的 obj 都替换为了 Hasf】**

> 你可能正确地观察到了泛型在  **Manipulator2.java** 中没有做任何事，你可以很轻松地**自己去执行擦除**，生成没有泛型的类：

```java
// generics/Manipulator3.java

class Manipulator3 {
    private HasF obj;

    Manipulator3(HasF x) {
        ojb = x;
    }

    public void manipulate() {
        obj.f();
    }
}
```



> 这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加"泛化" —— 代码能夸多个类工作时才有用。

【也就是说，泛型的定义要尽量定义在高层的接口，这样可泛化的类型更多，代码更通用】

> 因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是不能因此认为使用           `<T extends HasF>`  形式就是有缺陷的。
>
> 例如，如果某个类有一个返回 T 的方法，那么泛型就有所帮助，因为使用泛型可以返回确切的类型：

```java
// ReturnGenericType.java
public class ReturnGenericType <T extends Hasf> {
    private T obj;

    public ReturnGenericType(T obj) {
        this.obj = obj;
    }

    public T get() {
        return obj;
    }

    public static void main(String[] args) {
        ReturnGenericType<Hasf> hf = new ReturnGenericType<>(new Hasf());
        Hasf hasf = hf.get();
    }
}

```

![image-20200313120850171](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200313120850.png)

> 你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
>
> 我们将在本章稍后看到有关泛型边界的更多细节。

#### 迁移兼容性

> 为了减少关于泛型擦除的困惑，你必须清楚地认识到 泛型擦除**不是语言特性**。它是 Java 实现泛型的一种**妥协。** 因为泛型不是在 Java 出现时就存在，所以有了这种妥协。它是你痛苦，因此你需尽早习惯并了解它为什么会这样。
>
> 如果 Java 1.0 就存在泛型的话，那么这个特性就不用擦除来实现，它会使用具体类型（那样的话就是真泛型了），保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。 擦除减少了泛型的泛化性，（擦除只能将类型泛化为 Object 或者根据通配符进行泛化），**泛型在 Java 中仍然有用，只是没有设想的那么有用，其原因就在于擦除。**
>
> 在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文中使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，**程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。** 例如 `List<T>` 这样的类型参数会被擦除为 List，普通的类型变量在未指定边界的情况下回被擦除为 `Object`。【也就是所有没有指定泛型边界的泛型，最终都被编译器转为了 Object】
>
> **擦除的核心动机是：你可以在泛化的客户端上使用非泛型的类库，反之亦然。**【也就是为了兼容没有泛型的集合类之类的老代码】在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写反省代码。他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码。
>
> 【为了技术债而做的妥协】
>
> 因此 Java 泛型不仅必须支持向后兼容性 —— 现有的代码和类文件仍然合法，继续保持之前的含义 —— 而且还必须支持迁移兼容性，使得类库能按照他们自己的步调变为泛型类，当某个类库为泛型类时，不会破坏依赖于它的代码和应用。在确定了这个目标后。Java设计者们和从事此问题相关工作的各个团队决策认为**擦除是唯一可行的解决方案。**擦除使得这种**向泛型的迁移**成为可能，**允许非泛型的代码和泛型代码共存。**

> 例如，假设一个应用使用了两个类库 X 和 Y ，Y 使用了类库 Z。 随着 Java 5 的出现，这个应用和这些类库的创建者可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制，为了实现迁移的兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此他们不能探测其他类库是否使用了泛型。
>
> 因此某个特定的类库使用了泛型这样的证据必须被"擦除"。
>
> 如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。 **类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳或唯一的迁移途径，还有待时间来证明。**

**【上面这段话很长，是我一个字一个字打下来的，但是总结而言，泛型擦除就是为了兼容泛型不存在之前的代码，否则的话，可能会产生割裂，所以Java选择了擦除这个较为妥协的方法，保留了泛型不存在时的类库能够在 Java 5之后正常的运行】**

#### 擦除的问题

> 擦除的主要正当理由是从泛化代码到非泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。 擦除允许你继续使用现有的非凡性客户端代码，直至客户端准备好用泛型重写这些代码、这是一个崇高的动机，因为它不会骤然破坏所有代码。**【保证了兼容性与平滑过渡的特性】**
>
> 但是擦除的代价是显著的。泛型**不能**用于**显示地引用运行时类型**的操作中（也就是之前19章 RTTI 中的内容），例如转型(**cast**) 、**instanceof** 操作和 **new** 表达式**。因为所有关于参数的类型信息都丢失**了。当你在编写泛型代码时，必须时刻提升自己，你只是看起来拥有相关参数的类型信息而已：



> 考虑如下代码段：

```java
class Foo<T> {
	T var;
}
```

> 看上去当你创建一个 Foo 实例时：

```java
Foo<Cat> f =  new Foo<>();
```

> Class Foo 中的代码应该知道现在 T 是 Cat 类型。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写整个类的代码时，必须时刻提醒自己，这里的 Cat 只是一个 Object，【我们不能调用任何 Cat 类独有的方法。】



> 另外，**擦除和迁移兼容性**意味着，**使用泛型并不是强制的**，尽管你可能希望这样：

```java
// 关于擦除和继承类的Demo
// generics/ErasureAndInheritance.java
class GenericBase<T> {
    private T element;

    public void set(T t) {
        element = t;
    }

    public T get() {
        return element;
    }
}


class Derved1<T> extends GenericBase<T> {

}

class Dervied2 extends GenericBase { // 这里编译器会提示你在使用Raw-Type 类型的 GenericBase
}

// 语法错误
// 这里编译器无法确定 GenericBase 的类型参数
// 必须提供类或接口
/*
class Derived3 extends GenericBase<?> {
}
*/


public class ErasureAndInheritance<T> {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Dervied2 dervied2 = new Dervied2();
        Object o = dervied2.get();
        dervied2.set(o); // 如果不使用注解忽视 unchecked warring的话，这里编译器会告诉你 编译器无法根据泛型来进行类型检测
    }

}
```

> Derived2 继承自 GenericBase，但是没有使用任何类型参数，编译器没有发出警告。**【事实上编译器是会告诉你你在使用 Raw Type 类型的泛型类的，可能 IDEA 更强大一些】**

![image-20200313144413908](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200313144414.png)

> 为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：

```java
@SuppressWarnings("unchecked")
```

> 这个注解放置的位置是会产生警告的方法上。可以屏蔽 "unchecked" 警告，但是当你使用时最好将其放在最具体的方法上，以免遮盖别的方法的警告。
>
> 可以推断，Derived3 产生的错误意味着编译器期望得到一个**原生基类**。
>
> 当你希望类型参数不仅仅被当做 Object 处理时，就需要付出额外的努力来管理边界，并且与在 C++ 、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出更多努力来获得更少的汇报。这**些语言的参数化类型机制相比 Java 更灵活、强大。**

**【这里作者因为用过更多语言，所以能进行横向比较，来发现 Java 的不足，所以我们需要学习至少2门不同风格的语音，可以让自己的视野更加开阔。】**

#### 边界处的动作

> 因为擦除，作者发现**泛型**最**令人困惑**的方面是**可以表示没有任何意义的事物**：

```java
// ArrayMaker.java
public class ArrayMaker<T> {
    private Class<T> kind;

    public ArrayMaker(Class<T> kind) {
        this.kind = kind;
    }
    @SuppressWarnings("unchecked")
    T[] create(int size) {
        // 创建一个传入对象的 指定长度的数组
        return (T[]) Array.newInstance(kind, size);
    }

    public static void main(String[] args) {
        ArrayMaker<String> strMaker = new ArrayMaker<>(String.class);
        // 创建一个长度为9的字符串类型的空数组
        String[] strArray = strMaker.create(9);
        System.out.println(Arrays.toString(strArray));
    }
}
/**
输出
[null,null,null,null,null,null,null,null,null]
*/
```

> 即使 Kind 被存储为  `Class<T>` ，擦除也意味着**它实际被存储为没有任何参数的** `Class`。因此，当你在使用它使，例如创建数组，`Array.newInstance()` 实际上**并未拥有**kind 所蕴含的类型信息。所以它不会产生具体的类型，**所以必须进行转型，**这会产生警告。

### 源码：

```java
/**
Creates a new array with the specified component type and length. Invoking this method is equivalent to creating an array as follows:
       int[] x = {length};
       Array.newInstance(componentType, x);
       
The number of dimensions of the new array must not exceed 255.
*/
public static Object newInstance(Class<?> componentType, int length)
        throws NegativeArraySizeException {
        return newArray(componentType, length);
    }

```

> 注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是**推荐**的方式。
>
> 但是如果创建的是集合而不是数组，则情况就不同了：

```java
// ListMaker.java
public class ListMaker<T> {
    List<T> create() {
        return new ArrayList<>();
    }

    public static void main(String[] args) {
        ListMaker<String> strMaker = new ListMaker<>();
        List<String> strings = strMaker.create();
    }
}

```

> 这里编译器不会产生任何警告。 尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayLsit<>()` 中的  `<T>`  被移除了，在运行时，类内部没有任何 `<T>` ，因此这看起来毫无意义，但是如果你将 `ArrayList` 的泛型参数去掉 改为 `new ArrayList()` ，编译器就会发出警告。

> 本例中这么做真的没有意义吗？如果创建 List 的同时向其中放入一些对象呢：

```java
// FilledList.java
public class FilledList<T> extends ArrayList<T> {
    FilledList(Supplier<T> gen, int size) {
        Suppliers.fill(this, gen, size);
    }

    public FilledList(T t, int size) {
        for (int i = 0; i < size; i++) {
            // 因为本垒继承了 ArrayList
            this.add(t);
        }
    }

    public static void main(String[] args) {
        // 第一种方式是直接添加到 FilledList 中 这里调用的 ArrayList 中的 add() 方法
        FilledList<String> strList = new FilledList<>("Hello", 4);
        System.out.println(strList);
        // Supplier version: 使用 Supplier 生成 4个元素为 47的 Int 列表
        FilledList<Integer> intList = new FilledList<>(() -> 47, 4);
        System.out.println(intList);
    }
}
/**
输出
[Hello,Hello,Hello,Hello]
[47,47,47,47]
*/
```

> 即使编译器无法得知 add() 中的 T 类型的任何信息，但是它仍然可以在编译期确保你放入 FilledList 中的对象是 T 类型。
>
> **因此，即使擦除移除了方法或类中的实际类型信息，编译器仍然可以确保方法或类中使用的类型的一致性。**
>
> 因为擦除移除了方法体中的类型信息，所以在运行时的问题就是 **边界：****即对象进入和离开方法的地点**。这些正是编**译器在编译期执行类型检查并插入转型代码的地点。**
>
> 下面这个非泛型例子：

```java
// generics/SimpleHolder.java
// SimpleHolder.java
public class SimpleHolder {
    private Object obj;

    public Object getObj() {
        return obj;
    }

    public void setObj(Object obj) {
        this.obj = obj;
    }

    public static void main(String[] args) {
        SimpleHolder sh = new SimpleHolder();
        sh.setObj("Item");
        String obj = (String) sh.getObj();
    }
}

```



> 这里面看看编译后的字节码内容：

```java
// class version 52.0 (52)
// access flags 0x21
public class generics/SimpleHolder {

  // compiled from: SimpleHolder.java

  // access flags 0x2
  private Ljava/lang/Object; obj

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 10 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lgenerics/SimpleHolder; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public getObj()Ljava/lang/Object;
   L0
    LINENUMBER 14 L0
    ALOAD 0
    GETFIELD generics/SimpleHolder.obj : Ljava/lang/Object;
    ARETURN
   L1
    LOCALVARIABLE this Lgenerics/SimpleHolder; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public setObj(Ljava/lang/Object;)V
   L0
    LINENUMBER 18 L0
    ALOAD 0
    ALOAD 1
    PUTFIELD generics/SimpleHolder.obj : Ljava/lang/Object; 
   L1
    LINENUMBER 19 L1
    RETURN
   L2
    LOCALVARIABLE this Lgenerics/SimpleHolder; L0 L2 0
    LOCALVARIABLE obj Ljava/lang/Object; L0 L2 1
    MAXSTACK = 2
    MAXLOCALS = 2

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 22 L0
    NEW generics/SimpleHolder // class SimpleHolder
    DUP
    INVOKESPECIAL generics/SimpleHolder.<init> ()V // Method "<init>":()V
    ASTORE 1
   L1
    LINENUMBER 23 L1
    ALOAD 1
    LDC "Item"
    INVOKEVIRTUAL generics/SimpleHolder.setObj (Ljava/lang/Object;)V
   L2
    LINENUMBER 24 L2
    ALOAD 1
    INVOKEVIRTUAL generics/SimpleHolder.getObj ()Ljava/lang/Object;
    CHECKCAST java/lang/String // 检查类型转换  class java/lang/String
    ASTORE 2
   L3
    LINENUMBER 25 L3
    RETURN
   L4
    LOCALVARIABLE args [Ljava/lang/String; L0 L4 0
    LOCALVARIABLE sh Lgenerics/SimpleHolder; L1 L4 1
    LOCALVARIABLE obj Ljava/lang/String; L3 L4 2
    MAXSTACK = 2
    MAXLOCALS = 3
}

```

> set() 和 get() 方法存储和产生值，转型在调用 get() 时**接受检查。**

> 现在看看使用泛型之后的例子：

```java
// GenericHolder2.java
public class GenericHolder2<T> {
    private T obj;

    public T getObj() {
        return obj;
    }

    public void setObj(T obj) {
        this.obj = obj;
    }

    public static void main(String[] args) {
        GenericHolder2<String>  strHolder = new GenericHolder2<>();
        strHolder.setObj("Item");
        String s = strHolder.getObj();
    }
}

```

```java
// class version 52.0 (52)
// access flags 0x21
// signature <T:Ljava/lang/Object;>Ljava/lang/Object;
// declaration: generics/GenericHolder2<T>
public class generics/GenericHolder2 {

  // compiled from: GenericHolder2.java

  // access flags 0x2
  // signature TT;
  // declaration: obj extends T
  private Ljava/lang/Object; obj

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 10 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lgenerics/GenericHolder2; L0 L1 0
    // signature Lgenerics/GenericHolder2<TT;>;
    // declaration: this extends generics.GenericHolder2<T>
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  // signature ()TT;
  // declaration: T getObj()
  public getObj()Ljava/lang/Object;
   L0
    LINENUMBER 14 L0
    ALOAD 0
    GETFIELD generics/GenericHolder2.obj : Ljava/lang/Object;
    ARETURN
   L1
    LOCALVARIABLE this Lgenerics/GenericHolder2; L0 L1 0
    // signature Lgenerics/GenericHolder2<TT;>;
    // declaration: this extends generics.GenericHolder2<T>
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  // signature (TT;)V
  // declaration: void setObj(T)
  public setObj(Ljava/lang/Object;)V
   L0
    LINENUMBER 18 L0
    ALOAD 0
    ALOAD 1
    PUTFIELD generics/GenericHolder2.obj : Ljava/lang/Object;
   L1
    LINENUMBER 19 L1
    RETURN
   L2
    LOCALVARIABLE this Lgenerics/GenericHolder2; L0 L2 0
    // signature Lgenerics/GenericHolder2<TT;>;
    // declaration: this extends generics.GenericHolder2<T>
    LOCALVARIABLE obj Ljava/lang/Object; L0 L2 1
    // signature TT;
    // declaration: obj extends T
    MAXSTACK = 2
    MAXLOCALS = 2

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 22 L0
    NEW generics/GenericHolder2
    DUP
    INVOKESPECIAL generics/GenericHolder2.<init> ()V
    ASTORE 1
   L1
    LINENUMBER 23 L1
    ALOAD 1
    LDC "Item"
    INVOKEVIRTUAL generics/GenericHolder2.setObj (Ljava/lang/Object;)V
   L2
    LINENUMBER 24 L2
    ALOAD 1
    INVOKEVIRTUAL generics/GenericHolder2.getObj ()Ljava/lang/Object;
    CHECKCAST java/lang/String // 由编译器自动插入对类型转换的检查
    ASTORE 2
   L3
    LINENUMBER 25 L3
    RETURN
   L4
    LOCALVARIABLE args [Ljava/lang/String; L0 L4 0
    LOCALVARIABLE strHolder Lgenerics/GenericHolder2; L1 L4 1
    // signature Lgenerics/GenericHolder2<Ljava/lang/String;>;
    // declaration: strHolder extends generics.GenericHolder2<java.lang.String> 
    LOCALVARIABLE s Ljava/lang/String; L3 L4 2
    MAXSTACK = 2
    MAXLOCALS = 3
}

```

> 所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
>
> `get()` 和 `set()` **产生了相同的字节码**，这就告诉我们**泛型的所有动作都发生在边界处**——对入参的编译器检查和对返回值的转型。**这有助于澄清对擦除的困惑**，记住：“**边界就是动作发生的地方**”。

