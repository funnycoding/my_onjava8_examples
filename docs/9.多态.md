---
layout: post
title: 《On Java8》第九章——多态
date: 2020-02-13 23:47:11
tags:
- 读书笔记
categories: 
- 《On Java8》

---




## 第九章 多态

> **多态是面向对象编程语言中，继抽象和继承之外第三个重要的特性。**

<!-- more -->	

> 多态提供了另一个维度的**接口与实现分离**，以解耦**做什么和怎么做**。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加特性时都可以“生长“的程序。
>

封装通过**合并特征和行为**来**创建新的数据类型**。隐藏实现通过将细节私有化把接口与实现分离。

这种类型的组织机制对于有面向过程变成背景的人来说更容易理解。

**而多态是消除类型之间的耦合。**在上一张中，继承允许把一个对象视为它本身的类型或是它的父类类型。这样就能把很多派生字一个基类的类型当做同一类型处理。因而一段代码就可以无差别地运行在所有不同的类型上了。

多态方法调用允许一种类型表现出于相似类型的区别，只要这些类型派生自一个基类，这种区别是当你通过基类调用时，由方法的不同行为表现出来的。

在本章中，通过一些基本简单的例子，你将逐步学习多态（也称为 动态绑定或后期绑定/运行时绑定）

### 向上转型回顾

上一章说了，可以把一个对象的类型看做它本身或是她的基类类型。**这种把一个对象引用当做它的基类引用的做法称为向上转型。**

##### 下面是个例子：

```java
// polymorphism/music/Note.java
// Notes to play on musical instruments
// 音符类型
package polymorphism.music;

public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT; // Etc.
}
```

```java
// polymorphism/music/Instrument.java
// 乐器基类 instrument 与具体子类 wind
package polymorphism.music;

class Instrument {
    public void play(Note n) {
        System.out.println("Instrument.play()");
    }
}

// polymorphism/music/Wind.java
package polymorphism.music;
// Wind objects are instruments
// because they have the same interface:
public class Wind extends Instrument {
    // Redefine interface method:
    @Override
    public void play(Note n) {
        System.out.println("Wind.play() " + n);
    }
}
```

```java
// polymorphism/music/Music.java
// Inheritance & upcasting
// {java polymorphism.music.Music}
// music 定义一个入参为基类的方法，真正使用时将子类对象引用传入可正常运行
package polymorphism.music;

public class Music {
    public static void tune(Instrument i) {
        // ...
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind flute = new Wind();
        tune(flute); // Upcasting
    }
}

// 输出
Wind.play() MIDDLE_C
```

在 mian 中你看到了 tune() 方法传入了一个 Wind 引用而没有做类型转换。 这样做是允许的—— Instrument 的接口一定存在于 Wind中，因此 Wind 继承了 Instrument。 **从 Wind 向上转型为 Instrument 可能缩小接口吗，但是不会比 Instrument 的全部接口更少。**

### 忘掉对象类型

Music.java 看起来似乎有点奇怪。为什么所有人都故意忘掉对象类型呢？当向上转型时，就会发生这种情况，而且看起来如果 tune() 接受的参数是一个 Wind 引用会更为直观。 这会带来一个重要问题：如果你那么做，就要为系统内每个 Instrument 的每种类型都编写一个 tune() 方法。假设按照这种推理，再增加 Stringed 和 Brass 两种 Instrument 基本乐器。

**代码如下**：

```java
// polymorphism/music/Music2.java
// Overloading instead of upcasting
// {java polymorphism.music.Music2}
package polymorphism.music;

class Stringed extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Stringed.play() " + n);
    }
}

class Brass extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Brass.play() " + n);
    }
}

public class Music2 {
    public static void tune(Wind i) {
        i.play(Note.MIDDLE_C);
    }

    public static void tune(Stringed i) {
        i.play(Note.MIDDLE_C);
    }

    public static void tune(Brass i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind flute = new Wind();
        Stringed violin = new Stringed();
        Brass frenchHorn = new Brass();
        tune(flute); // No upcasting
        tune(violin);
        tune(frenchHorn);
      // 这是入参为基类的方法，可以根据具体引用指向的对象调用正确的方法，输出与上面针对特定类型的入参方法一致
       System.out.println("----------");
        Music.tune(wind);
        Music.tune(stringed);
        Music.tune(brass);
    }
}
```

这样可行，但是每增加一个新类型就需要编写一个特定的方法。必须为添加的每个新 Instrument 类编写特定的方法。这意味着开始时就需要考虑更多的编程。而且以后如果添加类似 tune() 的新方法或 Instrument 的新类型时，还有大量的工作要做。 考虑到如果你忘记重载某个方法，编译器也不会提示你，这回造成类型的整个处理过程变得难以管理。

如果只写一个方法以基类作为参数，而不用管哪个具体派生类，这样会变得更好吗？

也就是说如果忘掉子类，编写的代码只与父类打交道，会不会更好呢？

这正是多态所允许的。但是大部分拥有面向过程的背景的程序员会对多态的运作方式感到一些困惑。



### 方法调用绑定

**将一个方法调用和一个方法主体关联起来称作绑定。**

若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做 **前期绑定。** 这种绑定方式是面向过程语言的默认绑定方式，例如 C 语言中就只有前期绑定这一种方法调用。

那么问题来了，编译器只知道是一个 Instrument 引用，它无法得知调用哪个具体子类的方法。

> 解决方法就是 **后期绑定**，意味着在运行时根据对象的类型进行绑定，后期绑定也被称为动态绑定/运行时绑定。 
>

当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当方法的机制。

也就是说，**编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用**。 每种语言的后期绑定机制都不同，但是可以想到，**对象中一定存在某种类型信息。**

**Java 中除了 static 和 final 方法（private也是隐式 final方法） 外，其他方法都是后期绑定**。

> 为什么将某对象指明为 final？ 
>
> 1. **防止方法被重写**
> 2. **关闭动态绑定**



但是现在这个 2 的作用**并不会对程序性能带来影响**，所以只有真的在设计上需要final的时候再使用该关键字。

### 产生正确的行为

在编译时，编译器不需要知道任何具体信息以进行正确的调用。所有对方法 draw()【基类方法】 的调用都是通过动态绑定进行的。





### 陷阱：重写私有方法

总结，私有方法是隐式final的，无法被重写。子类中定义与父类private方法名相同的方法只是在子类中定义了另外的方法，与父类的 private 方法无关。



### 陷阱：属性与静态方法

**只有普通方法的调用是多态的。如果你直接访问一个属性，该访问会在编译时解析。**

```java
// polymorphism/FieldAccess.java
// Direct field access is determined at compile time
class Super {
    public int field = 0;

    public int getField() {
        return field;
    }
}

class Sub extends Super {
    public int field = 1;

    @Override
    public int getField() {
        return field;
    }

    public int getSuperField() {
        return super.field;
    }
}

public class FieldAccess {
    public static void main(String[] args) {
        Super sup = new Sub(); // Upcast
        System.out.println("sup.field = " + sup.field + 
                          ", sup.getField() = " + sup.getField());
        Sub sub = new Sub();
        System.out.println("sub.field = " + sub.field + 
                          ", sub.getField() = " + sub.getField()
                          + ", sub.getSuperField() = " + sub.getSuperField())
    }
}
// 输出
sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
```

简单总结以上代码

爹 = 儿子。

输出 爹.爹的属性，没有多态存在，打印的还是爹的属性值。

**结论上面有了，访问属性，属性会在编译时解析。**

**当 Sub 对象向上转型为 Super 引用时，任何属性访问都被编译器解析，因此不是多态的。**

在这个例子中：

Super.filed 和 Sub.filed **被分配到了不同的存储空间**，因此 Sub 实际上**包含了两个成为 filed 的属性**：它自己的和来自 Super 父类的。然而，在引用 Sub 的 filed 时，默认的 field 属性并不是 Super 版本的 field 属性。 **为了获取父类属性，需要显示地指明 super.field.**

但是实际开发中我们一般不会遇到这种问题，因为类属性一般都是private的，另外我们一般不会在子类和父类中起属性相同的名字，造成混乱。



### **静态方法不存在多态性**：

如果一个方法是 static 的，那么它的行为就不具有多态性，静态方法只与类关联，与对象无关。



### 构造器和多态

通常，构造器不同于其他类型的方法。在涉及多态时也是如此，尽管构造器不具有多态性（事实上人们会把构造器看作是隐式声明的静态方法【但是我也就在这本书看到了这么看待构造方法的，仅作者一个人】）

但是理解构造器在复杂层次结构中运作多态还是非常重要的。这个理解可以帮助你避免一些不愉快的困扰。



### 构造器调用顺序

在之前的 【初始化和清理】 【复用】 章节已经介绍过构造器的调用顺序，从顶层父类开始向下依次调用，当时还没有介绍多态。

在派生类的构造过程中，总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。

这么做是有意义的，因为**构造器有着特殊的任务**：**检查对象是否被正确的构造**。由于属性通常被声明为 private，**你必须假定派生类只能访问自己的成员而不能访问基类成员。**因此，**必须调用所有构造器，否则就不能构造完整的对象**。这就是编译器强制每个派生类必须调用构造器的原因。如果在派生类的构造器主体中没有显示地调用基类构造器，编译器就会默认调用无惨构造器，如果无参构造器不存在，编译器会报错。（当类中没有构造器时，编译器默认自动生成无参构造器）

##### 下面的例子展示组合、继承和多态在构建顺序上的作用

```java
class Meal {
    public Meal() {
        System.out.println("Meal()");
    }
}

class Bread {
    public Bread() {
        System.out.println("Bread()");
    }
}

class Cheese {
    public Cheese() {
        System.out.println("Chesses()");
    }
}

class Lettuce {
    public Lettuce() {
        System.out.println("Lettuce()");
    }
}

class Lunch extends Meal {
    public Lunch() {
        System.out.println("Lunch()");
    }
}

class PortableLunch extends Lunch {
    public PortableLunch() {
        System.out.println("PortableLunch");
    }
}


public class Sandwich extends PortableLunch{
    private Bread bread = new Bread();
    private Cheese cheese = new Cheese();
    private Lettuce lettuce = new Lettuce();



    public Sandwich() {
        System.out.println("Sandwich()");
    }

    public static void main(String[] args) {
        Sandwich sandwich = new Sandwich();
    }
}

这里看到的结果是： 首先形而上的调用构造器 从 Sandwich -> PortableLunch -> Lunch -> Meal
然后是Sandwich 的类变量初始化
最后是SandWich自己的类的构造函数的调用
  
总体顺序:
父类构造函数->当前类函数的初始化 -> 当前类的构造函数的调用

  
  /**
  输出
Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()
*/
  
```

从创建 Sandwich 对象的输出可以看到对象的构造器调用顺序如下：

1. 基类构造器被调用。这个步骤递归地重复。这样一来类层次顶级的父类会被最先构造，然后是它的子类，以此类推，直到最底层的子类。
2. 按声明顺序初始化成员
3. 调用派生类构造器的方法体

构造器的调用顺序很重要。**当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 public 和 proteced 的成员**。 这意味着在子类中可以假定所有的子类成员都是有效的。在一个标准方法中，构造动作已经完成，对象其他部分的所有成员都已经创建好。



在构造器中必须确保所有的成员都已经构建完。**唯一能保证这点的方法就是首先调用基类的构造器**。接着，在派生类的构造器中，所有你可以访问的基类成员都已经初始化。

**另一个在构造器中能知道所有成员都是有效的理由是：**无论何时有可能的话，你应该在所有成员对象（通过组合将对象置于类中），定义处初始化它们 例如例子中的类成员对象。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的类属性都已经初始化。

**不幸的是，这不能处理所有情况。详细见下节。**



### 继承和清理

使用组合和继承创建新类时，大部分时候你**无需关心清理。**子对象通常会留给垃圾收集器处理。**如果你存在清理问题，那么必须用心地位新类创建一个 dispose() 方法【这是作者自己定义的专门用来做清理的方法，不是JDK中预置的清理方法】**。由于继承，如果有其他特殊的清理工作的话，就必须在子类中重写 dispose() 方法。 当重写 dispose() 时，记得调用基类dispose() 方法，否则基类的清理工作不会发生。

##### 看下面的例子:

```java
package com.aibook.onjava;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description
 * @date 2020/2/9 5:19 下午
 */

class Characteristic {
    private String s;

    public Characteristic(String s) {
        this.s = s;
        System.out.println("Creating Characteristic " + s);
    }

    protected void dispose() {
        System.out.println("Dispose Characteristic" + s);
    }
}

class Description {
    private String s;

    public Description(String s) {
        this.s = s;
        System.out.println("Creating Description " + s);
    }

    protected void dispose() {
        System.out.println("Dispose Description " + s);
    }

}

class LivingCreature {
    // 顶层父类的类成员先被初始化
    private Characteristic p = new Characteristic("is Alive");
    private Description d = new Description("Basic Living Creature");

    // 随后顶层父类的 构造函数被调用
    public LivingCreature() {
        System.out.println("Living Creature()");
    }

    protected void dispose() {
        System.out.println("Living Creature Dispose");
        p.dispose();
        d.dispose();
    }

}

class Animal extends LivingCreature {
    private Characteristic characteristic = new Characteristic("Has Heart");
    private Description description = new Description("Animal Not Vegetable");

    public Animal() {
        System.out.println("Animal");
    }

    @Override
    protected void dispose() {
        System.out.println("Animal Dispose()");
        characteristic.dispose();
        description.dispose();
        // 调用父类 dispose 方法
        super.dispose();
    }
}

/**
 * 两栖动物
 */
class Amphibian extends Animal {
    private Characteristic characteristic = new Characteristic("can live in water");
    private Description description = new Description("Both water and land");

    public Amphibian() {
        System.out.println("Amphibian()");
    }

    @Override
    protected void dispose() {
        System.out.println("Amphibian Dispose");
        characteristic.dispose();
        description.dispose();
        super.dispose();
    }
}


public class Frog extends Amphibian {
    // 类属性先被初始化
    private Characteristic characteristic = new Characteristic("Croaks");
    private Description description = new Description("Eats Bugs");

    public Frog() {
        System.out.println("Frog");
    }

    @Override
    protected void dispose() {
        System.out.println("Frog Dispose");
        characteristic.dispose();
        description.dispose();
        super.dispose();
    }

    public static void main(String[] args) {
        // 创建一个 Frog 对象  一路向上追溯 最顶层父类是 LivingCreature 类
        Frog frog = new Frog();
        System.out.println("Bye");
        // 开始调用 dispose
        frog.dispose();
    }

}

```

层级结构中的每个类都有 Characteristic 和 Description 两个类型的成员对象，它们必须得被销毁，**销毁的顺序应该与初始化的顺序相反，以防止一个对象依赖另一个对象。**
对于属性来说，就意味着与声明的顺序相反（因为属性是按照声明顺序初始化），对于基类（遵循 C ++ 析构函数的形式）首先进行子类的清理工作，然后才是父类的清理。
这是因为子类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能被过早的销毁。
输出显示了，Frog 对象的所有部分都是按照创建的逆序销毁的。
尽管通常不必手动清理，但万一需要时，得谨慎小心地执行。
Frog 对象拥有自己的类成员对象，它创建了这些成员对象，并且知道它们能存活多久，所以它知道何时调用 dispose() 方法。然而，一旦某个成员对象被其他一个或多个对象共享时，问题就变的复杂了。不能只是简单地调用 dispose() 。这里也就必须使用 引用计数 来跟踪仍然访问着共享对象的对象数量

##### 代码如下：

```java
package com.aibook.onjava;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description 引用计数
 * @date 2020/2/9 8:21 下午
 */

class Shared {
    // 引用计数字段
    private int refcount = 0;
    private static long counter = 0;
    private final long id = counter++;

    public Shared() {
        System.out.println("Counting " + this);
    }

    public void addRef() {
        System.out.println("开始增加 Ref,当前 Ref: " + refcount);
        refcount++;
    }

    protected void dispose() {
        if (--refcount == 0) {
            System.out.println("Disposing " + this);
        }
    }

    @Override
    public String toString() {
        return "Shared " + id;
    }
}

class Composing {
    private Shared shared;
    private static long counter = 0;
    private final long id = counter++;

    public Composing(Shared shared) {
        System.out.println("Creating " + this);
        this.shared = shared;
        this.shared.addRef();
    }

    protected void dispose() {
        System.out.println("disposing " + this);
        shared.dispose();
    }

    @Override
    public String toString() {
        return "Composing " + id;
    }
}


public class ReferenceCounting {
    public static void main(String[] args) {
        // 首先需要调用构造函数
        Shared shared = new Shared();

        Composing[] composings = {
                new Composing(shared),
                new Composing(shared),
                new Composing(shared),
                new Composing(shared),
                new Composing(shared),
        };

        for (Composing c : composings) {
            c.dispose();
        }
    }

}
/** 输出
Creating Shared 0
Creating Composing 0
Creating Composing 1
Creating Composing 2
Creating Composing 3
Creating Composing 4
disposing Composing 0
disposing Composing 1
disposing Composing 2
disposing Composing 3
disposing Composing 4
Disposing Shared 0
*/
```



### 构造器内部多态方法的行为

构造器调用的层次结构带来一种困境：**如果在构造器中调用了正在构造的对象的动态绑定方法**，会发生什么呢？【这个问题确实值得思考，我现在也没法一口就回答上来。】

在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。

如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽， 难以发现。

从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）【怎么讲？】在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造对象所属的类是从构造器所属的类派生出来的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，而该方法操纵的成员可能还没有初始化，这肯定会带来灾难。

##### 看了例子：

```java
package com.aibook.onjava;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description
 * @date 2020/2/9 9:15 下午
 */

class Glyph {
    void draw() {
        System.out.println("Glyph.draw()");
    }

    public Glyph() {
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    }
}

class RoundGlyph extends Glyph {
    private int radius = 1;

    public RoundGlyph(int radius) {
        this.radius = radius;
        System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius);
    }

    // 这两个方法都输出一下 radius ，会有什么区别吗值？
    @Override
    void draw() {
        System.out.println("RoundGlyph.draw(), radius = " + radius);
    }
}


public class PolyConstructors {
    public static void main(String[] args) {
        new RoundGlyph(5);
    }
}
/**
输出

Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5

这里我到是真没想到，为什么 父类.draw() 的调用会是子类的。这个多态我是真的不知道的。

构造子类对象的时候 父类构造函数里的多态行为

*/

  
```

**Glyph 的 draw() 被设计为可重写，在 RoundGlyph 这个方法被重写**。但是 Glyph 的构造器里调用了这个方法，结果调用了 RoundGlyph 的 draw () 方法，这看起来正是我们的目的。

输出结果表明，当 Glyph 构造器调用了 draw() 时， radius 的值不是默认初始值1 而是 0。 这可能会导致在屏幕上只画了一个点或者干脆什么都不画，于是我们只能干瞪眼，找出程序不工作的原因。【这里很关键。子类中给 radius 的默认值1 在构造函数中没有生效，因为该值还不存在，所以默认值为0 】



前一小节描述的初始化顺序并不十分完整，而这正是解决谜团的关键所在。初始化的实际过程是：

1. 在所有事发生前，分配给对象的存储空间会被初始化为二进制0.
2. 如前所述调用基类构造器。此时调用重写后的 draw() 方法。（是的，在调用 RoundGraph 构造器之前调用，由步骤1可知，radius 的值为0.
3. 按声明顺序初始化成员。
4. 最终调用子类的构造器。

这么做有个优点：所有事物至少初始化为0(或某些特殊数据类型与 0 等价的值)，而不是仅仅留作垃圾。这包括了通过组合迁入类中的对象引用，被赋予 null。 如果忘记初始化该引用，就会在运行时出现异常。观察输出结果，就会发现所有事物都是 0。

另一方面，应该震惊于输出结果。这样的bug很容易忽略

**因此编写构造器有一条良好的规范：做尽量少的事，让对象进入良好状态**。如果可能的话，**尽量不要调用类中的任何方法**，在基类的构造器中能**安全调用**的只有基类的 **final** 方法（也适用于被看做 final 的 **private** 方法）。 这些方法不能被重写，因此不会产生意想不到的结果。 你可能无法永远遵循这条规范，但应该朝着它努力。






### 协变返回类型

```java
package com.aibook.onjava;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description
 * @date 2020/2/9 10:02 下午
 */

class Grain {
    @Override
    public String toString() {
        return "Grain";
    }
}

class Wheat extends Grain {
    @Override
    public String toString() {
        return "Wheat";
    }
}


class Mill {
    Grain process() {
        return new Grain();
    }
}

class WheatMill extends Mill {
    // 这里返回子类型
    @Override
    Wheat process() {
        return new Wheat();
    }
}


public class CovariantReturn {
    public static void main(String[] args) {
        Mill mill = new Mill();
        Grain g = mill.process();
        System.out.println(g);

        mill = new WheatMill();
        g = mill.process();
        System.out.println(g);
    }
}

```

主要就是子类可以覆写父类的方法并返回子类的对象。只要返回的对象和父类是同一类型。也是合法的返回值。

### 使用继承设计

组合优先于继承。组合更加灵活且不会强制设计继承的层次结构。

```java
package com.aibook.onjava;

/**
 * @author XuYanXin
 * @program aibook-parent
 * @description
 * @date 2020/2/9 10:31 下午
 */

class Actor {
    public void act() {

    }
}

class HappyActor extends Actor {
    @Override
    public void act() {
        System.out.println("HappyActor");
    }
}

class SadActor extends Actor {
    @Override
    public void act() {
        System.out.println("SadActor");
    }
}

class Stage {
    private Actor actor = new HappyActor();

    public void change() {
        actor = new SadActor();
    }

    public void performPlay() {
        actor.act();
    }
}

public class Transmogrify {
    public static void main(String[] args) {
        Stage stage = new Stage();
        stage.performPlay();
        stage.change();
        stage.performPlay();
    }
}


```

Stage 对象包含了 Actor 引用，该引用被初始化为一个 开心演员对象，然后被指向一个Sad演员对象。 这意味着 performPlay() 会产生一个特殊行为。但是既然引用可以在运行时与其他不同的对象绑定，那么它就可以被替换为 SadActor 的引用。这样就获得了运行时的动态灵活性（状态模式）
与之相反，我们不能再运行时决定继承不同的对象，继承层次在编译时就已经完全确定。

**有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。**

### 替代 VS 扩展



### 向下转型与运行时类型信息







### 本章小结

多态意味着 【不同的形式】。**在面向对象编程中，我们持有从基类继承来的相同接口和使用该接口的不同形式：不同版本的动态绑定方法。**

在本章中，你可以看到，如果不适用数据抽象和继承，就不可能理解甚至创建多态的例子。多态是一种不能单独看待的特性（比如 switch 语句），它只能作为类关系全景中的一部分，与其他特性协同工作。

为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类与类之间的共同特性和它们的关系。尽管这需要很大的努力，但是它能带来更快的程序开发，更好的代码组织，扩展性更好的程序和更易维护的代码。【意思是要先做好设计，设定好类之间的关系在动手，这样可以事半功倍。】

但是记住，多态可能被滥用。仔细分析代码以确保多态确实能带来好处。【那么什么是滥用呢，一直以来看到的都是多用组合，少用继承。确实在开发中我使用继承的场景也不是很多，大多都是类功能的组合与注入（感谢Spring)，但是类库中一般有很深的继承结构，所以必须深入理解相关的特性】

