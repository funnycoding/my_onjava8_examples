---
layout: post
title: 《On Java8》第十三章——函数式编程(2) java.util.function 的内置函数式接口
date: 2020-02-18 01:26:52
tags:
- 读书笔记
categories: 
- 《On Java8》
---



### 构造函数引用

> 还可以**捕获构造函数的引用**，然后**通过引用调用该构造函数**。

<!-- more -->	

##### 【这个操作想想就有点意思啊。】

```java
//CtorReference.java
// 三个构造函数对应上面的三个接口
class Dog {
    String name;
    int age = -1;


    public Dog() {
        name = "default Dog Name";
    }

    public Dog(String name) {
        this.name = name;
    }

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Dog.class.getSimpleName() + "[", "]")
                .add("name='" + name + "'")
                .add("age=" + age)
                .toString();
    }
}

// 三个接口都是构造 Dog 实例的方法 对应 dog 的三个构造函数
interface MakeNoArgs {
    Dog make();
}

interface Make1Args {
    Dog make(String name);
}

interface Make2Args {
    Dog make(String nm, int age);
}


public class CtorReference {
    public static void main(String[] args) {
        // 分别将三个构造器的方法引用赋给了3个对象的接口
        // 这里我还观察到了一个现象，就是构造函数的赋值形式和静态方法是一样的
        // 书里一直有个观念 构造函数是隐式静态方法，我之前一直存怀疑态度，但是在这里
        // 至少语法上是一致的
        MakeNoArgs mna = Dog::new; //[1]
        Make1Args m1a = Dog::new; //[2]
        Make2Args m2a = Dog::new; //[2]

        Dog dn = mna.make();
        Dog d1 = m1a.make("Comet");
        Dog d2 = m2a.make("Ralph", 4);
        System.out.println(dn);
        System.out.println(d1);
        System.out.println(d2);
    }
}

```

> Dog 有三个构造函数，有三个对应构造函数方法签名的接口(make() 方法的名称可以不同）
>
> **注意对 [1]  [2] [3] 的引用，每个都使用了 Dog::new ，每种情况下都赋值给了不同的接口。**
>
> **编译器可以检测并知道这是调用哪个构造函数**
>
> ##### 编译器能识别并调用你的构造函数 （本例中是 make() 改成别的名字也完全没有问题)

### 总结：

**【构造函数的方法赋值和静态函数一样，更多详细的在代码注释中有说明。】**

---

**【从这里可以认为是一个小的分割了，因为上面都是最基本的语法的介绍，下面的内容开始设计 JDK 自带的函数式接口，也就是配合 Lambda 和 方法引用使用的 Java8 新加的内置接口，所以有的例子会比上面的复杂很多。】**

### 函数式接口

> **方法引用 和 Lambda 表达式必须被赋值**，同时编译器需要识别**类型信息**以确保类型正确。 Lambda表达式特别引入了新的要求:



```java
x -> x.toString();	
```



> 这里清楚的看到 返回值 是String类型，**那么 x 入参是什么类型呢？**
>
> **【之前我就在嘀咕这个问题了】**
>
> Lambda 表达式包含 **类型推导（编译器自动推导出类型声明，避免了需要开发者显示声明） 编译器必须能够以某种方式推导出 x 的类型**
>
> 下面是第二个代码示例：
>
> 

```java
(x,y) -> x + y;	
```

> **这里 x,y 可以是任何 支持 + 运算符连接的数据类型。**
>
> 可以是两个数值或者一个 String 加一个可以被转换为 String 的数据类型
>
> 但是，当 **Lambda 表达式被赋值**时，**编译器**必须**确定** x 和 y 的**确切类型**以生成正确的代码。
>
> **【lambda 表达式的类型推导在编译时由编译器完成，必须能够确切推导出参数的类型信息】**
>
> 该问题也**适用于方法引用**，假设要传递 `System.out :: prinln` 到你正在编写的方法，**你怎么知道传递给方法的参数的类型**。
>
> 为了解决这个问题， Java 8 引入了 `**java.util.function**` ，包含了一组**函数式接口**。**每个接口只包含一个抽象方法，称为函数式方法。**
>

**【那么问题来了，这个类型推导与集合中的泛型菱形语法一样吗？】**

**【这里我找到了另外的资料解答了我的疑惑，并且说的挺详细挺好，跟我有意义疑惑的同学可以拉倒最后的额外资料去看那篇文章】**

##### 【也就是专门为了 Lambda 和 方法引用添加的接口呗】

> 在编写接口时， 可以使用 `@FunctionalInterface` 注解强制执行 函数式方法模式

```java
// FunctionalAnnotation.java
// 加了这个注解接口就只能存在1个抽象方法
@FunctionalInterface
interface Functional {
    String goodbye(String arg);
}

// 不加注解也没事，注解只是一个强制校验 当抽象方法的数量超过一个的时候会报错，而不加注解则该接口就成为非函数式接口
interface FunctionalNoAnn {
    String goodbye(String arg);
}

/*
以下是一个使用 @FunctionalInterface注解标示为函数式接口但是存在多个抽象方法的例子，编译器会报错。

@FunctionalInterface
interface NotFunctional {
  String goodbye(String arg);
  String hello(String arg);
}
产生错误信息:
NotFunctional is not a functional interface
multiple non-overriding abstract methods
found in interface NotFunctional
 因为如果使用了 @FunctionalInterface 注解，那么接口中只能存在一个抽象函数
*/


public class FunctionalAnnotation {
    // 与接口中返回值与签名一样的未绑定方法
    public String classGoodBye(String arg) {
        return "Good bye" + arg;
    }

    public static void main(String[] args) {
        FunctionalAnnotation fa = new FunctionalAnnotation();
        // 方法引用赋值
        Functional f = fa::classGoodBye;
        FunctionalNoAnn fna = fa::classGoodBye;
        // 对象的实例赋值给接口的引用，因为没有实现
        //Functional fac = fa; // 编译器报错

        // 使用 Lambda形式实现 Function接口的函数 这里编译器会自动推导出返回值为 String类型
        Functional fl = a -> "GoodBye Lambda," + a;
        Functional fnal = a -> "GoodBye Lambda With No Annotation," + a;
    }
}

```



> 函数式接口标记注解 `@FunctionaInterface` 是**可选**的，如果接口中的抽象函数大于一个时编译器会报错。
>
> 定义 f 和 fna 时， Functional 和 FunctionaNoAnn 定义的是接口，然而被赋值的是方法 `classGoodbye()。`
>
> 首先这只是一个方法，而不是类；其次，它甚至不是事先了该接口的类中的方法。

> Java 8 在这里添加了一点小魔法：如果 **将方法引用**或 **Lambda 表达式赋值给函数式接口（类型需要匹配）**，**Java 会将你的赋值与目标接口进行适配，编译器会自动包装方法引用 或 Lambda 表达式到实现目标接口的类的实例。**
>
> 尽管 FunctionalAnnotation 确实适合 Functional 模型，因为方法签名和返回值都可以匹配上，但是 Java 不允许我们将 FunctionalAnnotation 像 fac 那样直接赋值给 Functional ，**因为该类没有明确地实现 Functional 接口。**
>
> 令人惊奇的是， **Java 8 允许我们以简便的语法为接口赋值函数。**

**【这个例子其实挺简单的，就是说明被@FunctionalInterface 修饰的接口只能存在一个抽象函数，否则编译器会报错。至于上面说的 方法赋值给接口，之前已经生成了对应类的实例，所以是正常的。】**

> `java.util.function` 包的目的是创建一组完整的目标接口。让我们在一般情况下不需要自定义自己的接口。
>
> 这主要是因为基本类型会产生一小部分接口。如果你了解命名模式，就可以见名知意，知道特定接口的作用。
>
> 下面是基本命名准则：
>
> 1. 如果**只是处理对象而非基本类**
>
>    **型**，名称为 Function，Consumer，Predicate等。参数类型通过泛型添加。
>
> 2. 如果接受的参数是基本类型，则由名称的第一部分表示。如 LongConsumer，DoubleFunction,IntPredicate等，但基本 Supplier 类型除外。
>
> 3. 如果返回值是基本类型，则用 To 表示， 如 ToLongFunction《T》
>
> 4. **如果返回值与参数类型一致，则是一个运算符**：单个参数使用 UnaryOperator ，两个参数使用 BinaryOperator 
>
> 5. 如果接受两个参数且返回值为布尔值，则是一个谓词（Predicate）
>
> 6. 如果接收的两个参数类型不同，则名称中有一个 Bi。
>
> **【总结，函数式接口是为了更好地见名知意，让不同的接口有不同的用途，其实方法赋值的话很多都是可以通用的。】**

##### 

> 下表描述了 java.util.function 中的目标类型（包括例外情况）

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218002713.png)![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218002727.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218002748.png)

##### 【可以看到，很多都是数字来回操作，不太明白这个意义和具体用处以及例子，这块需要自己去多找找了】

> 此表提供了常规方案，通过上表你应该能或多或少自行推导出更多行的函数式接口

**【我有点懵逼，推导不出来啊】**

 **Update**：只要定义一个入参与返回值与函数接口中方法一致的就可以定义新的通用的函数式接口，标准非常宽松

> 可以看出，创建 `java.util.function` 时，设计者们做了选择：
>
> 例如 为什么没有 `IntComparator`，`LongComparator`，和`DoublerComparator`呢？
>
> 有 `BooleanSupplier` 却没有其他表示 Boolean 的接口。 
>
> 有通用的 `BiConsumer` 却没有 用于 `int`,`long`,和`double` 的 BiConsumer 的变体

**【至于这些选择是怎样考虑的，作者没说，我更想知道选择背后的决策】**

> 你还可以看到基本类型给 Java 添加了很多复杂性，为了缓和效率问题，该语言的第一版就包含了基本类型。现在，在语言的生命周期中，我们仍然受到语言设计选择不佳的影响。

【这里关于Java8新增的内置函数的具体使用建议看最底下的额外参考资料，有更详细的说明，因为这块也是我昨天学习的时候比较疑惑的点，就是这些**内置函数接口我到底要怎么在实际开发中去使用**】



> 下面列举了 Lambda 表达式所有的 Function变体的示例：



```java
// FunctionVariants.java
// 一个使用内置函数式接口进行各种基础操作的例子
class Foo {
}

class Bar {
    // 持有一个Foo对象引用
    Foo f;

    public Bar(Foo f) {
        this.f = f;
    }
}

class IBaz {
    int i;
    public IBaz(int i) {
        this.i = i;
    }
}

class LBaz {
    long l;

    public LBaz(long l) {
        this.l = l;
    }
}

class DBaz {
    double d;

    public DBaz(double d) {
        this.d = d;
    }
}


public class FunctionVariants {
    // 使用内置接口，这里 Bar/ IBaz / LBaz / DBaz 与对应接口的函数方法签名和返回值一致
    static Function<Foo, Bar> f1 = f -> new Bar(f); // 传入一个 f 返回一个 Bar 符合 Function 的 apply() 函数
    static IntFunction<IBaz> f2 = i -> new IBaz(i); // 返回和入参相同类型的方法 apply()
    static LongFunction<LBaz> f3 = l -> new LBaz(l);
    static DoubleFunction<DBaz> f4 = d -> new DBaz(d);

    static ToIntFunction<IBaz> f5 = ib -> ib.i; // 返回 int
    static ToLongFunction<LBaz> f6 = lb -> lb.l; // 返回 long
    static ToDoubleFunction<DBaz> f7 = db -> db.d; // 返回 double

    static IntToLongFunction f8 = i -> i; // 入参 int 出参 long 入参类型比出参小，不用进行数据类型强转
    static IntToDoubleFunction f9 = i -> i;  // 入参 int 出参 double 入参类型比出参小，不用进行数据类型强转
    static LongToIntFunction f10 = l -> (int) l; // Long 转 int ，因为出参类型比入参小，需要在方法中进行强转
    static LongToDoubleFunction f11 = l -> l;  // Long 转 double ，不用进行数据类型强转
    static DoubleToIntFunction f12 = d -> (int) d; // double 转 int ，向下转换，需要强转
    static DoubleToLongFunction f13 = d -> (long) d; // double 转 long，强转

    public static void main(String[] args) {
        // Function 的 apply() 函数就是 根据入参生成出参两种类型变量。 这里就是根据 Foo对象构造 Bar对象
        Bar b = f1.apply(new Foo());
        // 对象的构建，根据对应的入参
        IBaz ib = f2.apply(11);
        LBaz lb = f3.apply(11);
        DBaz dBaz = f4.apply(11);

        // 获取 对象中的 int
        int i = f5.applyAsInt(ib);
        // 获取对象中的 long
        long l = f6.applyAsLong(lb);
        // 获取对象中的 double
        double d = f7.applyAsDouble(dBaz);

        // int 转 long
        l = f8.applyAsLong(12);
        // int 转 double
        d = f9.applyAsDouble(12);
        // long 转 int
        i = f10.applyAsInt(12);

        // long 转 double
        d = f11.applyAsDouble(12);
        // double 转 int
        i = f12.applyAsInt(13.0);
        // double 转 long
        l = f13.applyAsLong(13.0);
    }
}
```



![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218011958.png)



> **这些 Lambda 表达式尝试生成适合函数签名的最简代码。**
>
> 在某些情况下有必要进行强**制类型转换**，否则编译器会报错。
>
> 主方法中的每个测试都显示了 Function 接口中不同类型的 apply() 方法。**每个都产生一个与其关联的 Lambda 表达式的调用**

**【实际上这个例子就是内置函数接口的一个使用样例，就是看着有点繁琐】**

> 方法调用有自己的小魔法：

```java
// MethodConversion.java
class In1 {}
class In2 {}


public class MethodConversion {
    static void accept(In1 i1, In2 in2) {
        System.out.println("accept()");
    }

    static void someOtherName(In1 i1, In2 in2) {
        System.out.println("Some Other Name");
    }

    public static void main(String[] args) {
        // 去看看 BiConsumer 的源码就会发现，这是一个 有2个类型参数的泛型类
        // 接口抽象函数 accept() 入参是 2个类型参数的类 这里对应 静态方法 accept() 和 someOtherName()
        BiConsumer<In1, In2> bic;
        // 调用 accept
        bic = MethodConversion::accept;
        bic.accept(new In1(), new In2());
        
        // 调用 someOtherName()
        bic  = MethodConversion::someOtherName;
        bic.accept(new In1(), new In2());
    }
}

/**
输出，可以看到对应的 accept 和 someOtherName都被调用了，因为分别进行了方法绑定，绑定到 BiConsumer的 accpt() 函数上
accept()
someOtherName()
*/

```



**【第一次的时候确实很懵逼，隔天再看其实就很清晰了，就是对应的内置函数的使用】**

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218012919.png)

> 这里可以看到，只要参类型、返回类型与接口中的抽象方法能对应，方法名可以使用不同的名称 比如 someOtherName() 。
>
> ##### 因此在使用函数接口时，名称无关紧要——只要参数类型和返回类型相同。
>
> Java 会将你的方法映射到接口方法，要调用方法，可以调用接口的函数式方法名（在本例中是accpt() ） 而不是你的方法名。

##### 【也就是调用过的时候用接口中的名字就好了，自己起的名字不需要用】

> 下面看看所有基于函数式、应用于方法引用（即那些不涉及基本类型的函数）
>
> 下面创建一个最简单的**函数式签名**：



```java
// functional/ClassFunctionals.java
// 内置函数接口的比较多的使用例子，但是没有本质性的区别
// 这里我加了2个输出，可以看到方法绑定赋值之后调用接口内的方法实际调用的就是未绑定方法赋值过去引用所指向的方法，也就是你自己实现的这个

class AA {
}

class BB {
}

class CC {
}


public class ClassFunctionals {
    static AA f1() {
        return new AA();
    }

    static int f2(AA a1, AA a2) {
        return 1;
    }

       static void f3(AA aa) {
        System.out.println("f3被调用了");
    }

    static void f4(AA aa, BB bb) {

    }

    static CC f5(AA aa) {
        System.out.println("f5被调用了，入参AA，返回值CC");
        return new CC();
    }


    static CC f6(AA aa, BB bb) {
        return new CC();
    }

    static boolean f7(AA aa) {
        return true;
    }

    static boolean f8(AA aa, BB bb) {
        return true;
    }

    static AA f9(AA aa) {
        return new AA();
    }

    static AA f10(AA aa1, AA aa2) {
        return new AA();
    }
    // 这10个方法基本是这几个类作为参数来回换

    public static void main(String[] args) {
        Supplier<AA> s = ClassFunctionals::f1;
        s.get(); // x相当于调用 AA的 f1函数，创建一个 AA 对象
        Comparator<AA> comparator = ClassFunctionals::f2;
        comparator.compare(new AA(), new AA());

        Consumer<AA> cons = ClassFunctionals::f3;
        cons.accept(new AA());

        BiConsumer<AA, BB> bicons = ClassFunctionals::f4;
        bicons.accept(new AA(), new BB());

        Function<AA, CC> f = ClassFunctionals::f5;
        CC apply = f.apply(new AA());

        BiFunction<AA, BB, CC> bif = ClassFunctionals::f6;
        bif.apply(new AA(), new BB());

        Predicate<AA> p = ClassFunctionals::f7;
        boolean result = p.test(new AA());

        BiPredicate<AA, BB> bip = ClassFunctionals::f8;
        result = bip.test(new AA(), new BB());

        UnaryOperator<AA> uo = ClassFunctionals::f9;
        AA aa = uo.apply(new AA());
        BinaryOperator<AA> bo = ClassFunctionals::f10;
        aa = bo.apply(new AA(), new AA());

    }
}
/**
输出
f3被调用了
f5被调用了，入参AA，返回值CC
*/

```





> 请注意，每个方法的名称都是随意的，一旦将方法引用赋值给函数接口，我们就可以使用与该接口关联的函数方法，其具体方法体就是未绑定方法的实现。
>
> 在例子中具体对应的就是 `get()`、`compare()`、`accept()`、`apply()`和`test()`。

##### 

### 多参数函数接口

> ·`java.util.functional`中的接口是有限的。比如有了 `BiFunction`，但它不能变化，如果需要三个参数的函数接口怎么办？
>
> 可以查看 Java 库源代码并自行创建：



```java
// TriFunction.java
// 自己创建一个三个参数的函数式接口
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}

// functional/TriFunctionTest.java

public class TriFunctionTest {
		
  	// 对应函数式接口的方法
    static int testMethod(int i, long l, double d) {
        return 99;
    }

    public static void main(String[] args) {
        // 将方法引用赋值给接口
        TriFunction<Integer, Long, Double, Integer> tf = TriFunctionTest::testMethod;
      	// Lambda 实现接口
        tf = (i, l, d) -> 12;
      	// 我又加了个匿名内部类的实现做对比
         TriFunction<Integer, Long, Double, Integer> triFunction = new TriFunction<Integer, Long, Double, Integer>() {
            @Override
            public Integer apply(Integer integer, Long aLong, Double aDouble) {
                return 99;
            }
        };

    }
}
```

### 缺少基本类型的函数



> 重温 `BiConsumer` ，创建缺少 int, long 和 double 的各种排列

**【对 BiConsumer 这个接口是干啥的，我还是没有建立起直观的印象，那么看源码吧】**

**![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218142425.png)**

**【可以看到，这个接口有一个 accept方法，是一个无返回值，两个参数的方法，就是对这两个翻出进行处理，至于咋处理就由你来定义了，只要方法符合这个返回值和入参就可以赋值给这个接口，也就可以说你那个类实现了这个接口】**

```java
// BiConsumerPermutations.java
// 分别输出 int,double / double ,int / int /long
public class BiConsumerPermutations {
    static BiConsumer<Integer, Double> bicid = (i, d)
            -> System.out.format("%d,%f %n", i, d);
    static BiConsumer<Double, Integer> bicdi = (d, i)
            -> System.out.format("%d,%f %n", i, d);
    static BiConsumer<Integer, Long> bicil = (i, l) ->
            System.out.format("%d,%d %n", i, l);

    public static void main(String[] args) {
        bicid.accept(47, 11.34);
        bicdi.accept(22.45, 92);
        bicil.accept(1, 11l);
    }
}
```



> 这里使用 `System.out.format()` 来显示。 它类似于 System.out.println() 但提供了更多的显示选项。
>
> `%f` 表示将 n 作为浮点数输出， 
>
> `%d` 表示 n 是一个整数值。
>
> 其中可以包含空格， `%n` 表示换行，使用 `\n` 也可以，但是 `%n` **自动跨平台**。
>
> 上面例子使用了包装类型，装箱和拆箱用于在基本类型之间的相互转换。也可以使用包装类型，如 Function，而不是预定义的基本类型，代码如下：

```java
// FunctionWithWrapped.java
// 当使用 Function 的时候，涉及到对象的装箱和拆箱，这时候选择使用对应的专门类型可以省略这个步骤，提高效率
public class FunctionWithWrapped {
    public static double returnD(int i) {
        return i;
    }

    public static int returnI(double d) {
        return (int) d;
    }


    public static void main(String[] args) {
        // 这里使用 Function接口的话，实现的时候需要进行显示的类型强转
        Function<Integer, Double> fid = i -> (double) i;
        // 使用专门的转换类就不需要
        IntToDoubleFunction fid2 = i -> i;

        // 这里我加了个 使用 double 转 int的内置函数接口，把 returnI 也用上了
        DoubleToIntFunction d = FunctionWithWrapped::returnI;
        double v = returnD(10);
    }
}
```



> 如果这里不使用强制转换则编译器会抛出异常信息 `"Integer cannot be converted to Double"`。而使用 IntToDoubleFunction 就没此类问题

##### 

> 为什么 IntTODoubleFunction不需要呢？看源码：

```java
@FunctionalInterface
public interface IntToDoubleFunction {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    double applyAsDouble(int value);
}

```

> 这里显示的指明了返回值是double ，精度比入参 int 高，所以不需要强转。
>
> 

【**而 Function 这个 `R apply(T)` ，你并不知道哪个精度更高，所以编译器需要让你显示的进行转换。**】





> 之所以我们可以**简单**地编写 `Function< Integer,Double>` 并返回合适的结果，很明显是为了性能。
>
> **使用基本类型可以防止传递参数和返回结果过程中的自动装箱和拆箱。**
>
> 似乎考虑到使用频率，某些函数类型并没有预定义。

### 总结

如果简单编写，可以使用Function，但是涉及到性能的话建议使用专门的转换接口。

或者自己编写接口也可以，明白规则之后编写函数式接口非常简单。


