---
layout: post
title: 《On Java8》第二十一章——数组(2)
date: 2020-03-10 00:22:03
tags:
- 读书笔记
categories: 
- 《On Java8》


---



### 多维数组

> 创建**多维**的基本类型数组，需要**大括号**来界定数组中的**向量**：
>
> <!-- more -->	

```java
// arrays/MultidimensionalPrimitiveArray.java

public class MultidimensionalPrimitiveArray {
    public static void main(String[] args) {
        int[][] a = {
                {1, 2, 3},
                {4, 5, 6}
        };
        // 打印多维数组
        System.out.println(Arrays.deepToString(a));
    }
}
/**
输出
[[1, 2, 3], [4, 5, 6]]
*/
```

> 每个嵌套的大括号都代表了数组的一个维度。
>
> **`Arrays.deepToString()`** 将多维数组转化为字符串。
>
> 也可以使用 `new` 分配数组。这是一个使用 `new` 表达式分配的三维数组：

```java
// arrays/ThreeDWithNew.java
public class ThreeDWithNew {
    public static void main(String[] args) {
        // 固定长度的三维数组
        int[][][] a = new int[2][2][4];
        System.out.println(Arrays.deepToString(a));
    }
}
/**
输出
[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]
*/
```

> 这里数组的元素初始化为了默认值 0，如果保存的是对象则会自动初始化为 null、
>
> 组成矩阵的数组中的每一个向量都可以是任意长度（不规则数组）：

```java
// RaggedArray.java
public class RaggedArray {
    static int val = 1;
    public static void main(String[] args) {
        SplittableRandom rand = new SplittableRandom(47);
        // 初始化一个动态长度的三维数组
        int i1 = rand.nextInt(7);
        System.out.println("i1: " + i1);
        int[][][] a = new int[i1][][];
        for (int i = 0; i < a.length; i++) {
            int i2 = rand.nextInt(5);
            System.out.println("i2: " + i2);
            a[i] = new int[i2][];
            for (int j = 0; j < a[i].length; j++) {
                int i3 = rand.nextInt(5);
                System.out.println("i3: " + i3);
                a[i][j] = new int[i3];
                Arrays.setAll(a[i][j], n -> val++); // 填充这个数组的内容
            }
        }
        System.out.println(Arrays.deepToString(a)); // 打印这个数组
    }
}
/**
输出
i1: 3
i2: 2
i3: 1
i3: 0
i2: 2
i3: 4
i3: 1
i2: 3
i3: 3
i3: 3
i3: 0
[[[1], []], [[2, 3, 4, 5], [6]], [[7, 8, 9], [10, 11, 12], []]]
*/

```

**【这里超过二维的数组刚开始还是需要反映一下，把这里边的数据结构想明白，再继续往下做。】**

> 第一个 new 创建了一个数组，这个数组首元素长度随机,其余的没有确定。
>
> 第二个 new 在 for 循环中填充了第二个元素，第三个 new 为数组的最后一个索引填充元素。
>
> - Java 8 增加了 Arrays.setAll() 方法，其使用生成器来生成插入数组中的值。 这里第二个参数符合函数式接口 IntUnaryOperator，只使用一个非 默认的方法 **applyAsInt**(int操作数)。 Arrays.setAll() 传递当前数组索引作为操作数，因此一个选项是提供 n -> n 的lambda 表达式来显示数组的索引。这里我们忽略索引，只插入递增计数器的值。 

```java
// Arrays.java
    public static void setAll(int[] array, IntUnaryOperator generator) {
        Objects.requireNonNull(generator);
        for (int i = 0; i < array.length; i++)
            array[i] = generator.applyAsInt(i);
    }

```



> 包装类型数组也可以定义为不规则数组：

```java
// arrays/MultidimensionalObjectArrays.java
public class MultidimensionalObjectArryas {
    public static void main(String[] args) {
        BerylliumSphere[][] spheres = {
                {new BerylliumSphere(), new BerylliumSphere()},
                {new BerylliumSphere(), new BerylliumSphere(),
                        new BerylliumSphere(), new BerylliumSphere()},
                {new BerylliumSphere(), new BerylliumSphere(),
                        new BerylliumSphere(), new BerylliumSphere(),
                        new BerylliumSphere(), new BerylliumSphere(),
                        new BerylliumSphere(), new BerylliumSphere()},
        };
        System.out.println(Arrays.deepToString(spheres));
    }
}
/**
输出
[[Sphere 0, Sphere 1], [Sphere 2, Sphere 3, Sphere 4,
Sphere 5], [Sphere 6, Sphere 7, Sphere 8, Sphere 9,
Sphere 10, Sphere 11, Sphere 12, Sphere 13]]
*/
```



> 数组初始化时使用自动装箱技术：

```java
// arrays/AutoboxingArrays.java
public class AutoboxingArrays {
    public static void main(String[] args) {
        Integer[][] a = {
                {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
                {21, 22, 23, 24, 25, 26, 27, 28, 29, 30},
                {51, 52, 53, 54, 55, 56, 57, 58, 59, 60},
                {71, 72, 73, 74, 75, 76, 77, 78, 79, 80},
        };
        System.out.println(Arrays.deepToString(a));
    }
}
/**
输出
[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [21, 22, 23, 24, 25,
26, 27, 28, 29, 30], [51, 52, 53, 54, 55, 56, 57, 58,
59, 60], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]]
*/
```



**【上面两个例子都很简单，就不详细说了，一个验证了对象类型数组的非对称数组的创建，一个说明了数组的初始化中包含了自动装箱技术。】**



> 以下是逐个构建对象类型的数组：

```java
//AssemblingMultidimensionalArrays.java
public class AssemblingMultidimensionalArrays {
    public static void main(String[] args) {
        Integer[][] a;
        a = new Integer[3][];

        for (int i = 0; i < a.length; i++) {
            a[i] = new Integer[3];
            for (int j = 0; j < a[i].length; j++) {
                a[i][j] = i * j; // 自动装箱
            }
        }
        System.out.println(Arrays.deepToString(a));
    }
}
/**
输出
[[0, 0, 0], [0, 1, 2], [0, 2, 4]]
*/
```



> Arrays.deepToString() 方法同时适用于 基础类型数组和对象数组：

```java
// MultiDimWrapperArray.java
public class MultiDimWrapperArray {
    public static void main(String[] args) {
        Integer[][] a1 = { // 自动装箱
                {1, 2, 3},
                {4, 5, 6}
        };

        Double[][][] a2 = { // Autoboxing
                {{1.1, 2.2}, {3.3, 4.4}},
                {{5.5, 6.6}, {7.7, 8.8}},
                {{9.9, 1.2}, {2.3, 3.4}},
        };
        String[][] a3 = {
                {"The", "Quick", "Sly", "Fox"},
                {"Jumped", "Over"},
                {"The", "Lazy", "Brown", "Dog", "&", "friend"},
        };
        System.out.println(
                "a1: " + Arrays.deepToString(a1));
        System.out.println(
                "a2: " + Arrays.deepToString(a2));
        System.out.println(
                "a3: " + Arrays.deepToString(a3));
    }
}
/**
输出
a1: [[1, 2, 3], [4, 5, 6]]
a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]
a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, &, friend]]
*/
```



### 泛型数组

> 一般来说，数组和泛型并不能很好的结合。你不能实例化带有参数类型的数组：

```java
Peel<Banana>[] peels = new Peel<Banana>[10]; // 不能这样做
```



> **因为泛型中的类型擦除会最终删除类型信息，但是数组必须知道所保存对象的确切类型。**
>
> 但是可以参数化数组本身的类型：

```java
// arrays/ParameterizedArrayType.java
class ClassParameter<T> {
    public T[] f(T[] arg) {
        return arg;
    }
}

class MethodParameter {
    public static <T> T[] f(T[] arg) {
        return arg;
    }
}

public class ParameterizedArrayType {
    public static void main(String[] args) {
        Integer[] ints = { 1, 2, 3, 4, 5 };
        Double[] doubles = { 1.1, 2.2, 3.3, 4.4, 5.5 };

        Integer[] ints2 = new ClassParameter<Integer>().f(ints);
        Double[] doubles2 = new ClassParameter<Double>().f(doubles);

        ints2 = MethodParameter.f(ints);

        doubles2 = MethodParameter.f(doubles);
    }
}

```

> 使用泛型方法比泛型类更简单，通常使用静态的泛型方法作为工具方法是更好的选择。
>
> 不能创建泛型类型的数组，这种说法不完全正确。
>
> 编译器不会让你实例化泛型的数组，但是编译器允许创建对此类数组的引用：

```java
List<String>[] ls;
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307183649.png)

> 虽然不能创建包含泛型的实际数组对象，但是可以创建一个非泛型的数组并对其进行强制类型转换：

```java
// ArrayOfGeneric.java
public class ArrayOfGeneric {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        List<String>[] ls;
        List[] la = new List[10];

        ls = (List<String>[]) la;//  忽略未检查异常的注解起作用了，否则编译器会在这里有一个警告

        ls[0] = new ArrayList<>();
        ls[0].add("aaa");
        System.out.println(Arrays.deepToString(ls));
        //这里编译器会抛出异常，ArrayList 类型参数为 Integer 的对象无法转换为 ArrayList 类型为 String 的对象
        //ls[1] = new ArrayList<Integer>();

        // 将ls 的引用指向 Object 类型的数组是可以的
        // 编译和运行都不会出错
        Object[] objects = ls;

        objects[1] = new ArrayList<>();
        System.out.println(Arrays.deepToString(objects));

        // 也可以直接创建泛型数组，只是需要一个忽略警告的注解

        List<BerylliumSphere>[] sphers = new List[10];

        Arrays.setAll(sphers, n -> new ArrayList<>());
        System.out.println(Arrays.deepToString(sphers));
    }
}
/**
输出
[[aaa], null, null, null, null, null, null, null, null, null]
[[aaa], [], null, null, null, null, null, null, null, null]
[[], [], [], [], [], [], [], [], [], []]
*/
```

![image-20200307192110644](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307192110.png)

【这个例子其实比较反人类，因为我想不出来有啥用数组装 List 的场景... 但是拿这个例子来说明泛型和数组还是挺好的】

> 编译器会对持有 List[] 的引用做编译时的类型检查。但是这里数组是协变的，所以 List[] 也是一个 Object[]。 这时将 ArrayList 装进数组在编译或者运行时都不会出错。
>
> 如果不进行向上转型，那么可以创建一个 **泛型数组** ，提供基本的编译时类型检查。 然而使用 CollectionFramework 是更好的选择。
>
> 一般来说，泛型在类或方法的边界上是有效的。在内部，泛型擦除常常**使泛型不可使用**：

```java
// arrays/ArrayOfGenericType.java

public class ArrayOfGenericType<T> {
    T[] array; // OK

    @SuppressWarnings("unchecked")
    public ArrayOfGenericType(int size) {
        //array = new T[size]; // 这里编译器报错，告诉你需要将 T 更换为更具体的类型，因为泛型擦除时类型参数的本质都是 Object。
        array = (T[]) new Object[size]; // Ok
    }

    @SuppressWarnings("unchecked")
    public <U> U[] makeArry() {
        //return new U[10]; // 提示跟上面一样，需要更换为更具体的类型，而不能使用泛型类型来创建数组；
        return  (U[]) new Object[10]; // 这样就可以了
    }
}

```

> 泛型擦除再次从中作梗。这个例子中如果试图以泛型类型来创建数组的话，编译器会报错：

![image-20200307195148773](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307195148.png)

> 因为它们是未知类型。你可以创建一个 Object 数组然后进行强制类型转换。 但是如果没有 **`@SuppressWarnings`** 注释，你会得到一个 未经检查的警告，因为数组实际上不真正支持对类型参数的动态检查。
>
> **比如创建一个 String[] 那么编译器会强制检查放入数组的都是字符串，而如果创建一个 Object[]，则可以放入任何类型的对象。**

### Arrays的 fill 方法

> JDK中的数组工具类 Arrays 中有一个将单个值复制到整个数组的 fill() 方法，或者针对 Object 数组将单个引用复制到整个数组。
>
> 可以为我们做测试时轻松生成充满测试数据的数组：

![image-20200307195701978](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307195702.png)

**【可以看到各种重载的 fill() 方法，支持基本类型与 Object。】**

```java
// FillingArrays.java
public class FillingArrays {
    public static void main(String[] args) {
        int size = 6;
        // 每个类型都创建一个空的数组
        boolean[] a1 = new boolean[size];
        byte[] a2 = new byte[size];
        char[] a3 = new char[size];
        short[] a4 = new short[size];
        int[] a5 = new int[size];
        long[] a6 = new long[size];
        float[] a7 = new float[size];
        double[] a8 = new double[size];
        String[] a9 = new String[size];

        Arrays.fill(a1, true);
        show(a1);
        Arrays.fill(a2, (byte)11);
        show("a2", a2);
        Arrays.fill(a3, 'x');
        show("a3", a3);
        Arrays.fill(a4, (short)17);
        show("a4", a4);
        Arrays.fill(a5, 19);
        show("a5", a5);
        Arrays.fill(a6, 23);
        show("a6", a6);
        Arrays.fill(a7, 29);
        show("a7", a7);
        Arrays.fill(a8, 47);
        show("a8", a8);
        Arrays.fill(a9, "Hello");
        show("a9", a9);
        // Manipulating ranges:
        Arrays.fill(a9, 3, 5, "World");
        show("a9", a9);
    }
}
/**
[true, true, true, true, true, true]
a2: [11, 11, 11, 11, 11, 11]
a3: [x, x, x, x, x, x]
a4: [17, 17, 17, 17, 17, 17]
a5: [19, 19, 19, 19, 19, 19]
a6: [23, 23, 23, 23, 23, 23]
a7: [29.0, 29.0, 29.0, 29.0, 29.0, 29.0]
a8: [47.0, 47.0, 47.0, 47.0, 47.0, 47.0]
a9: [Hello, Hello, Hello, Hello, Hello, Hello]
a9: [Hello, Hello, Hello, World, World, Hello]
*/
```



**【关于这种API的使用，把例子过一遍就行了，基本没什么值得回味的，很简单明白】**

### Arrays的 setAll 方法

> 在 Java 8中，**`RaggedArray.java`** 引入了并在 **ArrayOfGenerics.java.Array.setAll()** 中重用 。 它使用一个生成器并生成不同的值，可以选择基于数组的索引元素（访问当前索引，生成器可以读取数值并对其进行修改）。

```java
// Arrays setAll 的几个重载方法:
    public static <T> void setAll(T[] array, IntFunction<? extends T> generator) {
        Objects.requireNonNull(generator);
        for (int i = 0; i < array.length; i++)
            array[i] = generator.apply(i);
    }


    public static void setAll(int[] array, IntUnaryOperator generator) {
        Objects.requireNonNull(generator);
        for (int i = 0; i < array.length; i++)
            array[i] = generator.applyAsInt(i);
    }
    
        public static void setAll(long[] array, IntToLongFunction generator) {
        Objects.requireNonNull(generator);
        for (int i = 0; i < array.length; i++)
            array[i] = generator.applyAsLong(i);
    }
    
        public static void setAll(double[] array, IntToDoubleFunction generator) {
        Objects.requireNonNull(generator);
        for (int i = 0; i < array.length; i++)
            array[i] = generator.applyAsDouble(i);
    }

```

> 可以看到除了 int、long、double 有特殊版本，其他都由泛型版本处理。
>
> 这里生成器不是 Supplier 是因为它们不带参数，并且必须将 int 数组索引作为参数：

![image-20200307201558504](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307201558.png)



![image-20200307201620112](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200307201620.png)

```java
// SimpleSetAll.java

class Bob {
    final int id;

    Bob(int n) {
        id = n;
    }

    @Override
    public String toString() {
        return "Bob: " + id;
    }
}

public class SimpleSetAll {
    public static final int SZ = 8;
    static int val = 1;

    static char[] chars = "abcdefghijklmnopqrstuvwxyz"
            .toCharArray();

    static char getChar(int n) {
        return chars[n];
    }

    public static void main(String[] args) {
        // 初始化三个长度为 SZ 的数组
        int[] ia = new int[SZ];
        long[] la = new long[SZ];
        double[] da = new double[SZ];
        Arrays.setAll(ia, n -> n); // [1]
        Arrays.setAll(la, n -> n);
        Arrays.setAll(da, n -> n);

        System.out.println(Arrays.toString(ia));
        System.out.println(Arrays.toString(la));
        System.out.println(Arrays.toString(da));

        Arrays.setAll(ia, n -> val++); // [2] 这里是从1开始的 并且是连续的
        Arrays.setAll(la, n -> val++);
        Arrays.setAll(da, n -> val++);

        System.out.println(Arrays.toString(ia));
        System.out.println(Arrays.toString(la));
        System.out.println(Arrays.toString(da));
        Bob[] ba = new Bob[SZ];
        Arrays.setAll(ba, Bob::new); // [3]
        show(ba);

        Character[] ca = new Character[SZ];
        Arrays.setAll(ca, SimpleSetAll::getChar); // [4]
        show(ca);
    }
}
/**
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]
[1, 2, 3, 4, 5, 6, 7, 8]
[9, 10, 11, 12, 13, 14, 15, 16]
[17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0]
[Bob: 0, Bob: 1, Bob: 2, Bob: 3, Bob: 4, Bob: 5, Bob: 6, Bob: 7]
[a, b, c, d, e, f, g, h]
*/
```

> [1] 这里只是将数组索引作为值插入数组。这将自动化转为 long 和 double 版本。
>
> [2] 这个函数只需要接受索引就能产生正确结果。这里使用的是自增的 val。
>
> [3]  这里方法引用有效是因为 Bob 的构造器接收一个 int 参数。 只要传递的函数接收一个 int 且能产生正确的结果，就认为它完成了工作。
>
> [4] 为了处理 `int`,`long`,`double` 之外的基础类型，需要使用基础类型的包装类型，然后使用 `setAll()` 的泛型版本。 getChar() 生成基础类型，这里是自动装箱到 `Character`。 

### 