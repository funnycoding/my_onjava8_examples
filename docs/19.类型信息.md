---
layout: post
title: 《On Java8》第十九章——RTTI
date: 2020年02月28日16:09:46
tags:
- 读书笔记
categories: 
- 《On Java8》

---

> **RTTI （Runtime Type Information 运行时类型信息） 能在程序运行时发现和使用类型信息**，把我们只能在编译期进行面向对象类型操作的禁锢中解脱了出来。并且让我们可以使用某些非常强大的程序。
>
> <!-- more -->	
>
> 对 RTTI 的需要，揭示了面向对象设计中许多有趣并且复杂的特性，同时也带来了如何组织程序的基本问题。
>
> 本章将讨论 Java 是如何在运行时 识别对象和类的信息的。
>
> 主要有两种方式：
>
> 1. **传统 RTTI** ：假定在编译时已经知道所有类型。
> 2. **反射机制**：允许我们在运行时发现和使用类的信息。
>

### 为什么需要 RTTI

![多态例子Shape的类层次结构图](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200304112251.png)

> 这是之前多态中我们已经非常熟悉的例子，它使用了多态的类层次结构，基类 Shape 是泛化的类型，从它派生出三个具体类：`Circle` 、 `Square` 和 `Triangle`
>
> 面向对象编程的一个基本目的是：只与基类打交道。这样可以写出更加通用的程序。并且当添加新类的时候不会影响原来的代码，【符合开闭原则】
>
> 在这个例子中 Shape 接口动态绑定了 draw() 方法，这样做的目的就是让客户端程序员可以使用泛化的 Shape 引用来调用 draw() 。 由于draw() 是动态绑定的方法所以当父类引用指向不同子类对象时，调用 draw() 可以取得不同的效果。 这就是多态。

```java
// 最顶层的抽象基类，定义一个通用 draw 方法。打印自己本身，并将 toString 设置为抽象方法让子类自己实现。
// typeinfo/Shapes.java
abstract class Shape {
    void draw() {
        System.out.println(this + ".draw()");
    }

    @Override
    public abstract String toString();
}


class Circle extends Shape {
    @Override
    public String toString() {
        return "Circle";
    }
}

class Square extends Shape {
    @Override
    public String toString() {
        return "Square";
    }
}

class Triangle extends Shape {
    @Override
    public String toString() {
        return "Triangle";
    }
}


public class Shapes {
    public static void main(String[] args) {
        Stream<Shape> shapeStream = Stream.of(new Circle(), new Square(), new Triangle());
        shapeStream.forEach(System.out::println);
    }
}
/**
输出
Circle.draw()
Square.draw()
Triangle.draw()
*/

```

> 基类中包含 draw() 方法，它通过传递 this 参数给 System.out.println()，简洁地使用 toString() 打印类标识符（这里将toString() 声明为 abstract 是为了让继承类强制实现该方法，并防止对 Shape 的实例化）
>
> 如果某个对象在字符串表达式中，toString() 方法就会被自动调用，以生成该对象的 String。每个派生类都要覆盖 toString 方法，这样 draw() 在不同情况下就会打印出不同的消息（多态）
>
> 这时把 Shape 对象放入 `Stream<Shape>`中就会进行向上转型（隐式），但在向上转型时，对象的具体类型也丢失了。 对 stream 而言，它们只是 Shape 对象。
>
> 严格来说， `Stream<Shape>` 实际上把所有放入其中的对象都当做 Object 对象来持有，只是取元素时会自动将其类型转型为 Shape。 这也是 RTTI 最基本的使用形式，因为**在 Java 中，所有类型转换的正确性检查都是在运行时确定的。**
>
> **这也是 RTTI 的含义所在：在运行时识别一个对象的类型。**
>
> 另外在这个例子中，类型转换并不彻底：Object 被转型为 Shape ,而不是其具体子类类型 Circlke、Square 或者 Traingle。 这是因为目前我们只能确保这个 `Stream<Shape>` 里保存的都是 Shape对象。
>
> - 编译器，steam 和 Java 泛型系统确保放入 stream 的都是 Shape 对象（Shape 子类也视为 Shape）
> - 运行时，自动类型转换确保了从 stream 中取出的对象都是 Shape类型。
>
> 接下来就是多态机制的事了，Shape 对象实际执行什么样的代码，是由引用所指向的具体对象（Circle、Square或者Traingle ）决定的。
>
> 这也符合我们编写代码的一般需求，通常我们希望大部分的代码尽可能少了解对象的具体类型吗，而是只与对象家族中的一个通用表示打交道（本例中为基类 Shape) 。 这样代码更容易写、读和维护； 
>
> **设计也更容易实现，更易于理解和修改。所以多态是面向对象的基本目标。**
>
> 但是有时你会碰到一些问题，在这些问题你如果能知道某个泛化引用的具体类型，就可以把问题轻松解决。
>
> 例如假设我们允许用户将某些几何形状高亮显示，现在希望找到屏幕上所有高亮显示的三角形；或者需要旋转所有图形，但是跳过圆形。
> 这时我们就希望知道 `Stream<Shape>` 里边的具体形状是什么类型，Java也满足了我们这种需求，**使用 RTTI 我们可以查询 Shape 引用所指向的对象的具体类型，然后进行对应的操作。**



### Class 对象

> 要理解 `RTTI` 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。 这项工作是由称为 `Class` 对象的特殊对象完成的，它包含了与类有关的信息。
> 实际上，`Class` 对象就是用来创建该类所有 "常规" 对象的。 Java 使用 Class 对象来实现 RTTI ，几遍是类型转换这样的操作都是用 Class 对象实现的。不仅如此，Class 类还提供了很多使用 RTTI 的其他方式。
>
> **类是程序的一部分，每个类都有一个 Class 对象。** 换言之，**每当我们编写且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名 .class 文件中）。为了生成这个类的对象 Java 虚拟机 会先调用 类加载器 子系统把这个类加载到内存中。**
> **类加载器子系统可能包含一条类加载器链，但有且只有一个 原生类加载器 ， 它是 JVM 实现的一部分。** 原生类加载器加载的是 可信类（包括 Java API 类）。它们通常从本地盘加载。 在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求（例如以某种特殊的方式加载类，以支持 Web 服务器应用，或者通过网络下载类） ，也可以挂载额外的类加载器。
> **所有类都是第一次使用时动态加载到 JVM 中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类**
>
> **其实构造器也是类的静态方法，虽然构造器前面没有 static 关键字。 所以 使用 new 操作符创建类的新对象，这个操作也算作对类的静态成员引用。**
>
> 因此 **Java 程序在它开始运行之前并没有被完全加载**，很多部分是在需要时才会加载。这与许多传统的编程语言不通，动态加载使得 Java 具有一些静态语言（如 C++）很难或者根本不可能实现的特性。
> 类加载器首先会检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名 查找 .class 文件（如果有附加的类加载器，这时候可能会在数据库或者通过其他方式获得字节码）。
> 这个类的字节码呗加载后，JVM 会对其进行验证，确保它没有损坏，并且不包含不良的 Java 代码。（这是 Java 安全防范的一种措施）。
> **一旦某个类的 Class 对象被载入内存，它就可以用来创建这个类的所有对象。**

【这一段的信息量比较大 讲了 Java 类加载器的相关知识】

```java
// typeinfo/SweetShop.java
// 检查类加载器工作方式
class Cookie {
    static {
        System.out.println("Loading Cookie");
    }
}

class Gum {
    static {
        System.out.println("Loading Gum");
    }
}

class Candy {
    static {
        System.out.println("Loading Candy");
    }
}


public class SweetShop {
    public static void main(String[] args) {
        System.out.println("进入 main() 方法了");
        new Candy();
        new Candy(); // 可以看到静态代码块只在第一次类加载的时候被执行

        System.out.println("创建 Candy 对象之后");
        try {
            // 这里要正确的加载只能带上包名 后面作者再次使用的时候也加上了包名，我倾向于这是作者的失误
            Class.forName("typeinfo.Gum");
        } catch (ClassNotFoundException e) {
            System.out.println("Couldn't find Gum");
        }
        System.out.println("After Class.forName(\"Gum\")");

        new Cookie();
        System.out.println("After Create Cookie");

    }
}
/**
输出
进入 main() 方法了
Loading Candy
创建 Candy 对象之后
Loading Gum
After Class.forName("Gum")
Loading Cookie
After Create Cookie
*/

```

> 可以看到 上面的 `Candy`、`Gum` 和 `Cookie` 都有一个 `static{...}` 静态初始化块，这些静态代码块在类第一次被加载的时候就会执行。而且只会执行一次。
> 从输出中可以看到，**`Class` 对象仅在需要的时候才会被加载**，**`static` 初始化 是在类加载时进行的。**



```java
Class.forName("Gum");
```

> 所有 `Class` 对象都属于 `Class` 类，而且它跟其他普通对象一样，我们可以获取和操控它的引用（这也是类加载器的工作）。 `forName()` 是 `Class` 类的一个静态方法，我们可以使用 `forName()` 根据目标类的类名(String) 得到该类的 `Class` 对象。 上面的代码忽略了 `forName()` 的返回值，因为那个调用是为了得到 调用方法产生的副作用。
> 从结果可以看出，`forName()` 执行的副作用是如果 `Gum` 类没有被加载就加载它，而在加载的过程中，`Gum` 的 `static` 静态代码块被执行了。
> 
> 还需要注意的是，如果 `Class.forName()` 找不到要加载的类，就会抛出 `ClassNotFOundException`。 上面的例子只是简单的报告了问题，但是在严密的程序里，就要考虑在异常处理程序中把问题解决掉。
> 无论何时，只要你想在运行时使用类型信息，就必须先得到 Class 对象的引用。 
> `Class.forName()`就是实现这个功能的一个便捷途径，因为使用该方法你不需要先持有这个类型的对象。但是如果你已经拥有了目标类的对象，那就可以通过调用 `getClass()` 方法来获取 `Class` 引用了。
> 这个方法来自根类 `Object`，它将返回表示该对象实际类型的 `Class` 对象的引用。 
> `Class` 包含很多有用的方法：




```java
// typeinfo/toys/ToyTest.java
// 测试 Class 类
interface HasBatteries {
}

interface Waterproof {
}

interface Shoots {
}

class Toy {
    Toy() {
    }

    Toy(int i) {
    }
}

class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots {
    public FancyToy() {
        super(1);
    }
}


public class ToyTest {
    static void printInfo(Class clazz) {
        // 打印类名，以及是否是接口类型
        System.out.println("ClassName: " + clazz.getName() + "," + " is interface?[" + clazz.isInterface() + "]");
        // 打印简单类型
        System.out.println("Simple Nmae : " + clazz.getSimpleName());
        // 打印规范类名
        System.out.println("Canonical name: " + clazz.getCanonicalName());
    }

    public static void main(String[] args) {
        Class clazz = null;
        try {
            System.out.println("开始使用Class.forName 加载 FancyToy");
            clazz = Class.forName("typeinfo.toys.FancyToy");
        } catch (ClassNotFoundException e) {
            System.out.println("Can't find FancyToy");
            System.exit(1);
        }
        System.out.println("--- 开始打印 FancyToy 的Class 信息 ---");
        printInfo(clazz);
        System.out.println("--- FancyToy的Class 信息打印完毕 ---");
        System.out.println("---- 开始遍历 FancyTot的所有父类接口的类型信息 ----");
        for (Class face : clazz.getInterfaces()) { // 获取到一个类的所有接口信息
            printInfo(face);
        }
        System.out.println("---- FancyTot的所有父类接口的类型信息 遍历打印完毕 ----");

        System.out.println("开始获取FancyToy的父类信息");
        Class superclass = clazz.getSuperclass();
        Object obj = null;

        try {
            System.out.println("开始用父类的Class对象构造一个对象的实例");
            obj = superclass.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            System.out.println("Can't Access");
            System.exit(1);
        }
        System.out.println("开始打印父类对象的Class信息");
        printInfo(obj.getClass());
    }
}

/**
输出
开始使用Class.forName 加载 FancyToy
--- 开始打印 FancyToy 的Class 信息 ---
ClassName: typeinfo.toys.FancyToy, is interface?[false]
Simple Nmae : FancyToy
Canonical name: typeinfo.toys.FancyToy
--- FancyToy的Class 信息打印完毕 ---
---- 开始遍历 FancyTot的所有父类接口的类型信息 ----
ClassName: typeinfo.toys.HasBatteries, is interface?[true]
Simple Nmae : HasBatteries
Canonical name: typeinfo.toys.HasBatteries
ClassName: typeinfo.toys.Waterproof, is interface?[true]
Simple Nmae : Waterproof
Canonical name: typeinfo.toys.Waterproof
ClassName: typeinfo.toys.Shoots, is interface?[true]
Simple Nmae : Shoots
Canonical name: typeinfo.toys.Shoots
---- FancyTot的所有父类接口的类型信息 遍历打印完毕 ----
开始获取FancyToy的父类信息
开始用父类的Class对象构造一个对象的实例
开始打印父类对象的Class信息
ClassName: typeinfo.toys.Toy, is interface?[false]
Simple Nmae : Toy
Canonical name: typeinfo.toys.Toy
----
ClassName: typeinfo.toys.Toy, is interface?[false]
Simple Nmae : Toy
Canonical name: typeinfo.toys.Toy
*/

我在这里添加了很多输出语句，为了更好的标识各个输出之间的关系。
```

> `FancyToy` 继承自 `Toy` 并实现了`HasBatteries`、 `Waterproof` 和 `Shoots` 接口。在 `mainI` 方法中，我们创建了一个 `Class` 引用，然后在 `try` 语句里用 `forName()` 方法创建了一个 `FancyToy` 的类对象并赋值给该引用，需要注意的是，传递给 `forName()` 的字符串必须使用类的全限定名（包含包名）
>
> `printInfo()` 函数使用 `getName()` 来产生完整类名，使用 getSimpleName() 产生不带包名的类名，`getCanonicalName()` 也是产生完整的类名（除内部类和数组外，对大部分类产生的结果与 getName() 相同）。 `isInterface()` 用于判断某个 Class 对象代表的是否为一个接口。因此，通过 Class 对象，你可以得到关于该类型的所有信息。
> 在主方法中调用 `Class.getInterface()` 方法返回的是存放 `Class` 对象的数组，里面的 Class 对象表示的是那个类实现的接口。
> 另外你还可以调用 `getSuperclass()` 方法来得到父类的 `Class` 对象，再用父类的 Class 对象调用该方法，重复多次，就可以得到完整的类继承结构。
>
> `Class` 对象的 `newInstance()` 方法是实现 **虚拟构造器** 的一种途径，虚拟**构造器可以让你在不知道一个类的确切类型的时候，创建这个类的对象。**
> 在前面的例子中， `up`  只是一个 `Class` 对象的引用，在编译期并不知道这个引用会指向哪个 Class 对象。**当你创建新的实例时，会得到一个 Object 引用，但是这个引用指向的是 Toy 对象。**
> 当然由于得到的是 Object 引用，目前你只能给它发送 Object 对象能够接受的调用。而如果你想请求具体对象才有的方法，你就得先获取该对象更多的类型信息，并执行某种转型。 另外，**使用 `newInstance()` 来创建的类，必须带有无参构造器。** 在本章的稍后部分，你将会看到如何通过 Java 的反射 API，用任意构造器来动态地创建类的对象。



#### 类字面常量

> Java 还提供了另一种方法来生成类对象的引用：**类字面常量**。 对上述程序来说，就像这样： `FancyToy.class`。
>
> **这样做不仅更简单，而且更安全。**因为它在**编译时就会受到检查**（因此不必放在 try 语句块中）并且它根除了对 `forName()` 方法的调用，所以效率更高。
>
> 类字面常量不仅可以用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段 TYPE。 TYPE 字段是一个引用，指向对应的基本数据类型的Class 对象：

| ...等价于...  |  ...等价于...  |
| :-----------: | :------------: |
| boolean.class |  Boolean.TYPE  |
|  char.class   | Character.TYPE |
|  byte.class   |   Byte.TYPE    |
|  short.class  |   Short.TYPE   |
|   int.class   |  Integer.TYPE  |
|  long.class   |   Long.TYPE    |
|  float.class  |   Float.TYPE   |
| double.class  |  Double.TYPE   |
|  void.class   |   Void.TYPE    |

> 我的建议是使用 .class 的形式，以保持与普通类的一致性。
>
> 注意，有一点很有趣，**当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。**
>
> 为了使用类而做的准备工作实际包含三个步骤：
>
> 1. **加载**。由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。
> 2. **链接**。 在链接阶段将验证类中的字节码，为 static 字段分配存储空间，并且有需要的话，将解析这个类创建的对其他类的所有引用。
> 3. **初始化**。如果该类具有超类，则先初始化超类，执行 static 初始化器和 static 初始化块。
>
> **直到第一次引用一个 static 方法（构造器是隐式static）或者非 常量的 static 字段，才会进行类的初始化。**



```java
// typeinfo/ClassInitialization.java
// 关于类的初始化
class Initable {
    // 打印常量静态字段的时候并没有导致静态代码块的调用
    static final int STATIC_FINAL = 47;
    // 这里虽然是一个静态的final int 值，但是涉及到别的类 rand 字段的初始化 所以打印整个变量的时候 Initable 类被加载
    static final int STATIC_FINAL_2 = ClassInitialization.rand.nextInt(1000);

    static {
        System.out.println("Initable 的静态代码块被调用了");
    }
}

class Initable2 {
    static int staticNonFinal = 147;

    static {
        System.out.println("Initable2的静态代码块被调用了");
    }
}

class Initable3 {
    static int staticNonFinal = 74;

    static {
        System.out.println("Initable3 的静态代码块被调用了");
    }
}

public class ClassInitialization {
    public static Random rand = new Random(47);

    public static void main(String[] args) throws ClassNotFoundException {
        // 通过类的字面量来获取 Class 对象并不会导致 Initable 类被加载，静态代码块不会被调换用
        Class initableClass = Initable.class;

        // 使用字面量常量获得 Class 对象并没有触发类的初始化
        System.out.println("通过类字面量获取 Initable Class 对象之后");

        // 打印类的静态常量也不会触发类的加载
        System.out.println("打印 Initable 类的 STATIC_FINAL 字段：" + Initable.STATIC_FINAL);

        // 打印 STATIC_FINAL2 字段，Initable 类被加载
        System.out.println("打印 Initable 类的 STATIC_FINAL2 字段：" + Initable.STATIC_FINAL_2);

        // 打印 Initable2的 静态变量，类被加载
        System.out.println("打印 Initable2 类的 staticNonFinal 字段：" + Initable2.staticNonFinal);

        // 使用 forName 获取类对象，类被加载
        Class initable3 = Class.forName("typeinfo.Initable3");

        System.out.println("After Initializing initbale3 Ref");

        System.out.println(Initable3.staticNonFinal);
    }
}


/**
通过类字面量获取 Initable Class 对象之后
打印 Initable 类的 STATIC_FINAL 字段：47
Initable 的静态代码块被调用了
打印 Initable 类的 STATIC_FINAL2 字段：258
Initable2的静态代码块被调用了
打印 Initable2 类的 staticNonFinal 字段：147
Initable3 的静态代码块被调用了
After Initializing initbale3 Ref
74
*/
```

> 初始化有效地实现了尽可能的"惰性"，从对 `initable` 引用的创建中可以看到，仅使用 `.class` 语法来获得对垒的对象的引用不会引发初始化。 与此相反，通过 `forName()` 来产生 `Class`引用会立即对类进行初始化 比如 `initable3`
>
> 如果一个 `static final` 值是编译期常量（如 `Initable.STATIC_FINAL 1`),那么这个值不需要对 Initable 类进行初始化就可以被读取。
>
> 但是，如果只是将一个字段设置成为 `static` 和 `final`，还不足以确保这种行为。例如对 `Initable.STATIC_FINAL2` 的访问将强制进行类的初始化吗，因为它不是一个**编译期常量**。
>
> 如果一个 `static` 字段不是 `final` 的，那么对它访问时，总是要求它在被读取之前，要先进行链接（为这个字段分配存储空间） 和初始化（初始化该空间） 就像在对 `Initable2.staticNonFinal` 的访问中看到的那样。



#### 泛化的 Class 引用

> `Class` 引用总是指向某个 `Class` 对象，而 `Class` 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。 它还包含该类的 `static` 成员，因此 Class 引用表明了它所指向对象的确切类型，而该对象便是 `Class` 类的一个实例。
>
> 但是， `Java` 设计者看准机会，将它的类型变得更具体了一些。 Java引入泛型语法之后，**我们可以使用泛型对 `Class` 引用所指向的 `Class` 对象的类型进行限定。**
>
> 在下面的例子中，两种语法都是正确的：

```java
// typeinfo/GenericClassReferences.java

public class GenericClassReferences {
    public static void main(String[] args) {
        Class intClass = int.class;
        Class<Integer> genericIntClass = int.class;
        genericIntClass = Integer.class; // 同一个东西
        intClass = double.class;
        // genericIntClass = double.class; // 非法 因为泛型限定了 Class 对象只能包含 Integer 的Class 对象
    }
}
```

> 普通的类引用不会产生警告信息。你可以看到 使用泛型的类引用可以重新赋值指向任何其他的 Class 对象，但是使用泛型限定的类引用只能指向其声明的类型。**通过使用泛型语法，我们可以让编译器强制执行额外的类型检查。**
>
> 如果我们希望泛型更加通用呢？ 乍一看下面的操作好像可以：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200228200330.png)

```java
Class<Number> geenericNumberClass = int.class; // 不行
```

> 我们认为这种泛型应该是起作用的，因为 Integer 继承自 Number。但是事实却是不行，编译器会告诉我们类型参数不匹配。因为 Integer 的 Class 对象并不是 Number Class 对象的子类。（会在泛型章节详细讨论）
>
> 为了在使用 Class 引用时放松限制，我们使用了通配符，它是 Java 泛型中的一部分。 通配符就是 `?` ，表示"任何事物"，因此我们可以在上例的普通 Class 引用中添加通配符，并产生相同的结果：

```java
// typeinfo/WildcardClassReferences.java

public class WildcardClassReferences {
    public static void main(String[] args) {
        Class<?> intClass = int.class;
        intClass = double.class;
    }
}
```

> **虽然 `Class<?>` 与 `Class` 等价**，但是使用泛型类型的 Class 却能接受任何类型**这代表你是故意为之**，并非是碰巧或者疏忽才使用了一个非具体类型的Class 对象。
>
> 创建限定某子类的 `Class` 引用需要通配符 与 `extends` 关键字配合使用。这与仅仅声明 `Class<Number>` 不同：

```java
// typeinfo/BoundedClassReferences.java
public class BoundedClassReferences {
    public static void main(String[] args) {
        // 可以指向任何任何 Number 的子类的Class对象
        Class<? extends Number> bounded = int.class;
        bounded = double.class;
        bounded = Number.class;

    }
}
```

> 向 `Class` 引用添加泛型语法是为了提供编译期的类型检查，因此如果你往Class 里添加了错误的类型，编译器就会提醒你类型错误。而使用非泛型的 Class 对象，就要到运行时才能发现错误。
>
> 下面的示例使用了泛型语法，它保存了一个类引用，稍后又使用 `newInstance()` 方法产生类对象

```java
// DynamicSupplier.java
class CountedInteger {
    private static long counter;
    private final long id = counter++;

    public CountedInteger() {
    }

    @Override
    public String toString() {
        return Long.toString(id);
    }
}

public class DynamicSupplier<T> implements Supplier<T> {

    private Class<T> type;

    public DynamicSupplier(Class<T> type) {
        this.type = type;
    }

    @Override
    public T get() {
        try {
            return type.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        // 这里 Class的类型参数是 CountedInteger
        Stream.generate(new DynamicSupplier<>(CountedInteger.class))
                .skip(10)  // 跳过前10个对象 0 -9 
                .limit(5)
                .forEach(System.out::println);
    }
}

/**
输出
10
11
12
13
14
*/

```

> 注意，这个类必须假设与它一起工作的任何类型都有一个无参构造器，否则在程序运行时会抛出异常【因为 `newInstance`() 调用的是无惨构造器】。
>
> 编译期该程序不会产生任何警告信息。
>
> 当你将泛型语法用于 `Class` 对象时，`newInstanceI()` 将返回该对象的确切类型，而不仅仅只是在 `ToyTest.java` 中看到的基类 `Object`。然而，这再某种程度上有些受限：



```java
// typeinfo/toys/GenericToyTest.java
// 测试 Class 类
// {java typeinfo.toys.GenericToyTest}
public class GenericToyTest {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException {
        // 通过类字面量获取 Class 对象
        Class<FancyToy> ftClass = FancyToy.class;

        // 通过泛型的 Class 对象生成具体的类
        FancyToy fancyToy = ftClass.newInstance();
        Class<? super FancyToy> superclass = ftClass.getSuperclass();
        // This won't compile: 下面的语句不能编译 无法通过 Class<FancyToy> 生成 Class<Toy>
        // 因为 Class<Toy> 不是 Class<FancyToy> 的父类
        // 具体还是跟泛型的擦除有关
        // Class<Toy> up2 = ftClass.getSuperclass();

        // 只能构造 Object对象 而不是 Toy 对象 然后对Object进行类型转换
        Toy object = (Toy) superclass.newInstance();
    }
}

```

> 如果你手头持有的是超类，那编译器将只允许你声明超类引用为某各类，它是FancyToy 的超类。 就像在表达式 `Class<? super FancyToy>` 中所看到的那样，而不会接收 `Class<Toy>` 这样的声明。
>
> 这看上去显得有些怪，因为 `getSuperClass()` 方法返回的是基类（不是接口），并且编译器在编译期就知道它是什么类型（本例中的 `Toy.class`)，而不仅仅是**模糊的 "某个类"**。不管怎样，正是由于这种含糊型，`up.newInstance` 的返回值不是精确类型，而只是 `Obejct`。
>
> **【学到后面的泛型章节就知道这是泛型的类型擦除了。】**



#### cast() 方法

> Java 中还有用于 `Class` 引用的**类型转换**语法 即 `cast()` 方法：

```java
// typeinfo/ClassCasts.java
class Building {
}

class House extends Building {
}

public class ClassCasts {
    public static void main(String[] args) {
        Building b = new House();

        Class<House> houseType = House.class;

        // 下面两种方式进行类型转换效果相同
        House h = houseType.cast(b);
        h = (House) b;
    }
}
```

```java
// Class.java 源码
   public T cast(Object obj) {
        if (obj != null && !isInstance(obj))
            throw new ClassCastException(cannotCastMsg(obj));
        return (T) obj;
    }

```

**【可以看到 cast() 比直接使用类型强转多了对异常的处理其他都是一样的】**

> `cast()` 方法接受参数对象，并将其类型转换为 `Class` 引用的类型，但是如果观察上面的代码，你会发现，与实现 了相同功能的  `h = (House) b;`  相比，调用 cast() 方法进行类型转换好像做了很多额外的工作。
>
> `cast()` 在无法使用普通类型转换的情况下回显得非常有用，比如在你编写反省代码时，如果你保存了 Class 引用，并希望以后通过这个引用来执行转型，你就需要用到 `cast()` 。
>
> 但事实却是这种情况非常少见，作者发现整个 Java 类库中只有一处使用了 cast() （在 `com.sun.mirror.util.DeclarationFilter` 中) 

### 