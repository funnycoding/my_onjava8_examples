---
layout: post
title: 《On Java8》第十四章——流式编程(1) —— 流创建 
date: 2020年02月20
tags:
- 读书笔记
categories: 
- 《On Java8》
---

## 《On Java8》第十四章 流式编程（1）— 流创建

> 集合优化了对象的存储，而**流和对象的处理有关。**
>
> **流**是一系列**与**特定**存储无关**的元素。**流中并不存在存储的概念。**
>
> **使用流**，我们**无需迭代集合中的元素就可以提取和操作它们**。这些**管道**通常被组合在一起，在流上形成一条操作管道。
>
> 大多数情况下，将对象存储在集合中是为了处理他们。因此焦点从集合转移到了流上——因为**流可以直接操作集合中的对象**。
>
> **流的一个核心好处是，它使得程序更加短小并更易理解。**
>
> 当 Lambda 表达式和方法引用与流一起使用的时候会让人感觉自成一体。
>
> 流使得 Java 8 更具有吸引力。

<!-- more -->	



> 举个栗子，如果要随机展示 5 - 20 之间不重复的整数并排序。首先应该是创建一个**有序的集**合，围绕这个集合进行后续的操作。
>
> 但是使用流式编程，你就可以简单陈述你想做什么：

```java
// streams/Randoms.java
public class Randoms {
    public static void main(String[] args) {
        // 创建随机数，给个种子
        new Random(47)
                .ints(5, 20) // 生成  包含(5,20)的随机数  的流
                .distinct() // 去重
                .limit(7) // 限制数量 7个
                .sorted() // 排序
                .forEach(System.out::println);  // 输出

    }
}
// 输出
6
10
13
16
17
18
19
```

> 分析一下这个例子，首先使用带种子的 Random 对象保证运行时的相同输出。
>
> int() 方法产生一个流 并且 int() 方法有多重方式的重载—两个参数限定了数值产生的边界，这将生成一个整数流。
>
> 有了流我们就可以使用中间流操作（intermediate stream operation)  。**distinct() — 去重** 
>
> **limit() 获取流中前7个元素**
>
> **sorted() 排序**
>
> foreach() 根据入参函数对流中的每个对象执行操作，这里我们传入的是System.out::println 所以每个对象都被打印到控制台中。
>
> 同时注意，在这个例子中我们没有声明任何变量— **流可以在不使用赋值或可变数据的情况下对有状态的系统建模。**
>
> 声明式编程（Declaretive Programming）是一种：声明要做什么，而非怎么做的编程风格。 
>
> 而命令式的编程风格会更加难以理解【也就是我们平时使用的编程风格】

```java
// ImperativeRandoms.java
public class ImperativeRandoms {
    public static void main(String[] args) {
        Random rand = new Random(47);
        SortedSet<Object> rints = new TreeSet<>();
        while (rints.size() < 7) {
            int r = rand.nextInt(20);
            if (r < 5) {
                continue;
            }
            rints.add(r);
        }
        System.out.println(rints);
    }
}

// 输出
[7, 8, 9, 11, 13, 15, 18]
```

> 对比一下声明式编程和命令式编程，命令式编程定义了3个变量，并且 nextInt() 方法不能设置下限，所以我们需要额外增加判断来避免添加小于5的值。
>
> **注意**，**你必须明白程序的真正意图**，而在 Randoms.java 中，代码只是告诉了你它正在做什么。这种语义清晰性也是 Java 8 的流式编程更受推崇的重要原因。
>
> 在  ImperativeRandoms.java 中显示的编写 while 循环 被称为 **外部迭代**，而在 Randoms.java 中，流式编程采用**内部迭代**，这是流式编程的核心机制之一。
>
> 这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。
>
> 通过放弃对迭代过程的控制，我们将控制权交给了并行化机制。
>
> 同时，流是懒加载的，这代表着它只在绝对必要时才计算。你可以将流看作"延迟列表"。由于计算延迟，流使我们能够表示非常大（甚至无限的序列） 而不需要考虑内存问题。

### 小结

序言给出流很重要的一些特点：

- 流与具体的存储无关，也就是说和 List Map Set 之类的没有耦合。
- 流的核心是操作集合中的对象
- 流不需要迭代集合中的元素就可以操作这些对象，是不是意味着效率会大幅度提高？
- 流存在管道的概念。
- 流是内部迭代的，这是流编程的核心机制之一。
- 流与Lambda/方法引用一起使用会显得更和谐。
- 流是内部迭代且并行的，可以利用多核处理器。
- 流是懒加载且计算延迟的，可以表示非常大甚至无限的序列。
- 声明式编程：只告诉你想要的结果(What)，机器自己摸索过程(How) 对应 **内部迭代**
- 命令式编程：详细的命令机器怎样（How) 处理一件事情以达到你想要的效果 对应**外部迭代**

### 问题：

- 管道的概念是否与Linux中的管道一致？
- 为什么懒加载+计算延迟就可以表示无限大的序列？物理内存不是终究是有限的吗？

### 流支持

> 难题：怎样将全新的概念引入已经被大量第三方类库使用的老的库中。
>
> 比如在 **Random** 中添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。 

**【也就是增量更新，遵守开闭原则，不修改原有代码，只增加新的方法】**

> 问题是接口部分怎么改造呢？特别是涉及集合类的接口部分。如果你想把一个集合转换为流，**直接向原有接口中添加新方法会破坏所有老的接口的实现类。**

**【因为接口如果新增加了方法，那么实现类就需要添加对应的实现，就会影响到所有使用该类库的开发者】**

> Java 8 采用的解决方法：接口中增加 default 默认方法。这样不会影响到实现接口的类。
>
> 通过这种方案，设计者们可以将流式方法平滑地嵌入到现有的类中。
>
> 内置的 Stream 方法几乎已经满足了我们平常的所有需求。
>
> **Stream 操作的类型由三种：**
>
> - 创建流
> - 修改流元素(中间操作 Intermediate Operations)
> - 消费流元素（终端操作, Terminal Operations）
>   - 消费流元素通常意味着收集流元素（通常是到集合中）。

### 小结

- Java 8的各个特性果然是互相联系互相支持的，为了平滑地增加 Stream 方法同时不影响已有接口的实现，于是有了 default 关键字，有了接口默认方法
- Stream的操作类型，上面已经有了，就不重复了。



### 流创建

> 使用 Stream.of() 可以很容易地将一组元素转化称为流。

 【**这里使用的 Bubble 是在后面才创建的 但是这个例子中要使用**】

```java
public class Bubble {
    public final int i;

    public Bubble(int n) {
        i = n;
    }

    @Override
    public String toString() {
        return "Bubble(" + i + ")";
    }

    private static int count = 0;

    public static Bubble bubbler() {
        return new Bubble(count++);
    }
}

```



```java




// StreamOf.java
public class StreamOf {
    public static void main(String[] args) {

        // 这里有三个将传入元素转为流的例子
        
        Stream.of(new Bubble(1),
                new Bubble(2),
                new Bubble(3))
                .forEach(System.out::println);

        Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie! ")
                .forEach(System.out::print);

        System.out.println();

        Stream.of(3.14159, 2.718, 1.618)
                .forEach(System.out::println);
    }
}
/**
输出：
Bubble(1)
Bubble(2)
Bubble(3)
It's a wonderful day for pie! 3.14159
2.718
1.618
*/
```

【**既然用到了新的类，而且这么重要，那么一定要去看一下源码：**】

```java
// 指出顺序和并行聚合操作一系列元素的类 里面包括了各种重要的操作
// 该接口的方法很多，而且都是核心方法，所以这里只列出例子中用到的
public interface Stream<T> extends BaseStream<T, Stream<T>> {
  
  // 这两个方法可以看到是对应不同情况，一个是返回单个对象的Stream 一个是返回载有多个元素的Stream。
  
    @SafeVarargs
    @SuppressWarnings("varargs") // Creating a stream from an array is safe
    public static<T> Stream<T> of(T... values) {
        return Arrays.stream(values);
    }
  
   public static<T> Stream<T> of(T t) {
        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);
    }
}
```

> 除此之外，每个集合都可以通过 `stream()` 方法来产生一个流：

```java
// streams/CollectionToStream.java
public class CollectionToStream {
    public static void main(String[] args) {

        List<Bubble> bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        // 将 List 转为流，然后将 bubble 中的 i 求和 这里 i 分别是 1/2/3
        System.out.println(bubbles.stream()
                .mapToInt(bubble -> bubble.i)
                .sum());

        Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
        w.stream()
                .map(x -> x + " ")
                .forEach(System.out::print);
        System.out.println();

        HashMap<String, Double> m = new HashMap<>();
        m.put("pi", 3.1415926);
        m.put("e", 2.718);
        m.put("phi", 1.618);

        m.entrySet()
                .stream()
                .map( e -> e.getKey() + ": " + e.getValue())// 每个键值对中间插一个 ": "
                .forEach(System.out::println);
    }
}
/**
输出
6
a pie! It's for wonderful day
phi: 1.618
e: 2.718
pi: 3.14159
*/
```

【这里可以看到，每个集合都可以调用 `stream()`方法，因为刚才也说了，为了平滑嵌入流式编程，在之前的接口中增加 默认函数就可以，所以可以看到这里的 方法来自于集合框架顶层接口 Collection 中的 `stream()`】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200220203038.png)

> 创建 `List<Bubble>` 对象之后，调用 `stream()`获取流， `map()` 会**获取流中的所有元素**，并且对流中元素应用操作从而产生新的元素，并将其传递到后续的流中。
>
> 通常 `map()` 会获取对象并产生新的对象，但是这里产生了特殊的用于数值类型的流。例如 `mapToInt()`方法将一个对象流 (Object Stream) 转换成为包含整形数字的 `IntStream`。
>
> 同样，针对 `Float` 和 `Double` 也有类似名字的操作。
>
> 我们通过调用字符串的 `split()`操作，根据空格进行切分获取 w。
>
> 为了从 Map 集合中产生流数据，首先调用 `entrySet()` 产生一个对象流，每个对象都包含一个 `key` 和与其关联的 `value`, 然后分别调用 `getKey()` 和 `getValue()`获取值

**【至于为啥Map需要获取 EntrySet 然后才调用 stream ，因为该函数只在 Collection 接口中存在，Map里是没有的。】**

#### 随机数流

> `Random` 类被一组生成流的方法增强了：

```java
// RandomGenerators.java
public class RandomGenerators {
    // 打印流中前4个元素
    public static <T> void show(Stream<T> stream) {
        stream.limit(4)
                .forEach(System.out::println);
        System.out.println("------------");
    }

    public static void main(String[] args) {
        Random rand = new Random(47);
        show(rand.ints().boxed());
        show(rand.longs().boxed());
        show(rand.doubles().boxed());
        // 增加上下限范围限制
        show(rand.ints(10,20).boxed());
        show(rand.longs(50,100).boxed());
        show(rand.doubles(20,30).boxed());

        // 控制流大小：
        show(rand.ints(2).boxed());
        show(rand.longs(2).boxed());
        show(rand.doubles(2).boxed());

        // 控制流的大小和界限
        show(rand.ints(3, 3, 9).boxed());
        show(rand.longs(3, 12, 22).boxed());
        show(rand.doubles(3, 11.5, 12.3).boxed());
    }
}
/**
输出
什么都没有限制的
-1172028779
1717241110
-2014573909
229403722
------------
2955289354441303771
3476817843704654257
-8917117694134521474
4941259272818818752
------------
0.2613610344283964
0.0508673570556899
0.8037155449603999
0.7620665811558285
------------
限制流上下限的
16
10
11
12
------------
65
99
54
58
------------
29.86777681078574
24.83968447804611
20.09247112332014
24.046793846338723
------------
限制流元素个数的

1169976606
1947946283
------------
2970202997824602425
-2325326920272830366
------------
0.7024254510631527
0.6648552384607359
------------
限制流元素个数和上下限的

6
7
7
------------
17
12
20
------------
12.27872414236691
11.732085449736195
12.196509449817267
------------
```

> 这里 `show(String<T> stream); ` 接受一个 Stream，取其前4个元素并打印。
>
> 类型参数 `T` 可以是任何类型，但是 Random 类只能生成 基本类型 int,long,double的流，所以代码中使用了 `boxed()` 函数，将基本类型转为 包装类型，使 `show()`能接受流。

```java
// IntPipeline.java
		@Override
    public final Stream<Integer> boxed() {
        return mapToObj(Integer::valueOf);
    }
```

> 我们可以使用 Random 为任意对象创建集合 Supplie。
>
> 下面是一个文本文件提供字符串对象的例子：
>
> Cheese.data 文件的内容:

```
// streams/Cheese.dat
Not much of a cheese shop really, is it?
Finest in the district, sir.
And what leads you to that conclusion?
Well, it's so clean.
It's certainly uncontaminated by cheese.
```

> 我们通过 File 类将 Cheese.dat 文件的所有行读取到 `List<String>`中：

```java
// RandomWords.java
public class RandomWords implements Supplier<String> {

    List<String> words = new ArrayList<>();
    Random rand = new Random(47);

    RandomWords(String fname) throws IOException {
        // 读取传入文件路径的所有内容
        List<String> lines = Files.readAllLines(Paths.get(fname));

        // 略过第一行
        for (String line : lines.subList(1, lines.size())) {
            for (String word : line.split("[ .?,]+")) {
                words.add(word.toLowerCase());
            }
        }
    }


    @Override
    public String get() {
        return words.get(rand.nextInt(words.size()));
    }

    @Override
    public String toString() {
        return words.stream().collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        System.out.println(Stream.generate(new RandomWords("Cheese.dat")) // 这里我是必须使用绝对路径的，如果使用文件名会找不到文件
                .limit(10)
                .collect(Collectors.joining(" ")));
    }
}
/**
  输出
  it shop sir the much cheese by conclusion district is
  */
```



> 这里 `split()`使用正则来分割，每一行都通过空格或者被方括号包裹的任意标点符号进行分割。
>
> `[ .?,]+`
>
> 在结束方括号后面的 `+` 代表 `+` 前面的东西可以出现一次或者多次。
>
> `toString（）` 和 主方法中你看到了 `collect()` 收集操作，它根据参数来组合流中的所有元素。
>
> `Collector.joining()` 会得到一个 String 类型的返回值，每个元素都根据 `joining()` 的参数来进行分割。 还有许多不同的 `Collector` 用于产生不同的结果。
>
> `Stream.generator()` 可以把任意的 `Supplier<T>` 用于生成 `T` 类型的流

```java
// Stream.java
		/**
		返回无限顺序无序流，其中每个元素由提供的Supplier生成。 这适用于生成恒定流，随机元素流等。
		*/
    public static<T> Stream<T> generate(Supplier<T> s) {
        Objects.requireNonNull(s);
        return StreamSupport.stream(
                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
    }
```

**【如果是第一次接触大量的Stream的 API，一定是会比较懵逼的，可以再去单独找找专门讲解的文章。】**

#### int 类型的范围

> `IntStream` 类提供了 `range()` 方法用于生成整形序列的流。编写循环时使用这个会更方便：

```java
// Ranges.java
// 使用三种方法对 11-19 求和
public class Ranges {
    public static void main(String[] args) {
        // 传统方法生成整数序列
        int result = 0;
        for (int i = 10; i < 20; i++) {
            result += i;
        }
        System.out.println(result);

        // for-in 循环
        result = 0;
        for (int i : IntStream.range(10, 20).toArray()) {
            result += i;
        }
        System.out.println(result);

        // 使用流
        System.out.println(IntStream.range(10,20).sum());
    }
}

/**
输出
145
145
145
*/
```

> 第一种方式是传统的 for 循环
>
> 第二种使用 range 创建流并转为数组同时使用 for-in 语法遍历
>
> 第三种使用 `sum()`在流中直接进行求和操作。
>
> 实用小功能 `repeat()` 可以用来替换简单的 `for`循环：

```java
//Repeat.java
public class Repeat {
    public static void repeat(int n, Runnable action) {
        IntStream.range(0,n).forEach(i -> action.run());
    }
  	
  // 作为对比的传统循环
   public static void repeat2(int n, Runnable action) {
        for (int i = 0; i < n; i++) {
            action.run();
        }
    }
}

```

```java
public class Looping {
    static void hi() {
        System.out.println("Hi!");
    }

    public static void main(String[] args) {
        Repeat.repeat(3,()-> System.out.println("Looping!~"));
        Repeat.repeat(2,Looping::hi);

    }
}
/*
输出
Looping!
Looping!
Looping!
Hi!
Hi!
*/
```

> 原则上，在代码中包含并解释 `repeat()`并不值得。诚然它是一个相当透明的工具，但是结果取决于你的团队和公司的运作方式

**【我并不能理解这句话作者在说啥。。。】**

#### generator()

> 参照 `RandomWords.java` 中的 `Stream.generate()` 搭配 `Supplier<T>` 使用的例子：

```java
// Generator.java
public class Generator implements Supplier<String> {
    Random rand = new Random(47);
    char[] letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    int i = 0;

    // 这个 get 是在什么时候被调用的呢？
    public String get() {
        System.out.println("get 被调用了" + i);
        i++;
        return "" + letters[rand.nextInt(letters.length)];
    }

    public static void main(String[] args) {
        String word = Stream.generate(new Generator())
                .limit(30)
                .collect(Collectors.joining());
        System.out.println(word);
    }
}

/**
输出
YNZBRNYGCFOWZNTCQRGSEGZMMJMROE
*/
```

【这里我的问题是 `get()` 是什么时候被调用的呢？ 还是对内置的函数接口不太熟】

【而且使用方法引用最大的问题就是增加输出语句就不好增加了，可调试性减弱。】

> 使用 `Random.nextInt()` 方法来挑选字母表中的大写字母。
>
> `Random.nextInt()`的参数代表可以接受的最大随机数范围，**所以使用数组的边界是经过深思熟虑的。**
>
> **要创建包含相同对象的流，只需要传递一个生成那些对象的 `lambda` 到 `generate()` 中：**

```java
// Duplicator.java
public class Duplicator {
    public static void main(String[] args) {
        Stream.generate(()->"duplicate")
                .limit(3)
                .forEach(System.out::println);
    }
}
/**
输出
duplicate
duplicate
duplicate
*/
```

**【这个例子很好懂，生成一个流，并打印其中前三个元素】**

> 如下是在本章之前例子中使用过的 `Bubble` 类。注意它包含了自己的静态生成器（Static generator) 方法。

```java
// streams/Bubble.java
// 这个类在之前使用的时候已经放在代码里了。
import java.util.function.*;
public class Bubble {
    public final int i;

    public Bubble(int n) {
        i = n;
    }

    @Override
    public String toString() {
        return "Bubble(" + i + ")";
    }

    private static int count = 0;
    public static Bubble bubbler() {
        return new Bubble(count++);
    }
}
```

> 由于 `bubbler()` 与 `Supplier<Bubble>`是接口兼容的，我们可以将其方法引用直接传递给 `Stream.generator()`:

【这里说 `bubbler()` 与 `Supplier<Bubble>`是接口兼容的 是因为 Supplier 的get 方法是返回类泛型参数的无参方法吧】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200221140151.png)



```java
// streams/Bubbles.java
import java.util.stream.*;
public class Bubbles {
  // 生成5个 Bubble 对象，并调用其 toString 方法，打印 Bubble + i
    public static void main(String[] args) {
        Stream.generate(Bubble::bubbler)
              .limit(5)
              .forEach(System.out::println);
    }
}

/**输出
Bubble(0)
Bubble(1)
Bubble(2)
Bubble(3)
Bubble(4)
*/
```

> 这是创建单独工厂类（Separate Factory class） 的另一种方式。
>
> 在很多方面它更加整洁，但是这是一个对哦与代码组织和不同品味的问题—你总是可创建一个完全不同的工厂类。

**【也就是这样创建对象作者认为比较有品味，但是工厂类的实现是很多种的。】**

#### iterator()

```java
// Stream.java

		public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {
        Objects.requireNonNull(f);
        final Iterator<T> iterator = new Iterator<T>() {
            @SuppressWarnings("unchecked")
            T t = (T) Streams.NONE;

            @Override
            public boolean hasNext() {
                return true;
            }

            @Override
            public T next() {
                return t = (t == Streams.NONE) ? seed : f.apply(t);
            }
        };
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
                iterator,
                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);
    }

```



> `Stream.iterate()` 以种子（第一个参数）开头，并将其传给第方法(第二个参数)。
>
> 方法的结果将添加到流，并存储作为第一个参数用于下次调用 `iterate()`，以此类推我们可以利用 `iterate()` 生成一个 斐波那契额数列

```java
// Fibonacci.java
public class Fibonacci {
    int x = 1;
    Stream<Integer> numbers() {
        return Stream.iterate(0, i -> {
            int result = x + i;
            x = i;
            return result;
        });
    }

    public static void main(String[] args) {
        new Fibonacci().numbers()
                .skip(20) // 跳过前20个
                .limit(10) // 然后取前10个
                .forEach(System.out::println);
    }
}
/**
输出
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
*/
```

> **斐波那契额数列将数列中最后两个元素进行求和产生下一个元素**。
>
> `iterate()` 只能记忆结果，因此我们需要变量 `x` 追踪另一个元素。
>
> 在主方法中，我们使用了 `skip()`操作m它根据参数丢弃指定数量的元素。

```java
// ReferencePipeline.java
// skip() 函数的源码

	@Override
    public final Stream<P_OUT> skip(long n) {
        if (n < 0)
            throw new IllegalArgumentException(Long.toString(n));
        if (n == 0)
            return this;
        else
            return SliceOps.makeRef(this, n, -1);
    }
```



#### 流的建造者模式

> 在建造者设计模式（也叫构造器设计模式）中，首先创建一个 `builder`对象，传递给它多个构造器信息，最后执行构造。 **Stream**库提供了这样的 `Builder`。
>
> 这里，我们重新审视文件读取并将其转换为单词流的过程。

```java
// FileToWordsBuilder.java
public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream.builder();

    public FileToWordsBuilder(String filePath) throws IOException {
        Files.lines(Paths.get(filePath))
                .skip(1) // 跳过开头行
                .forEach(line -> {
                    for (String w : line.split("[ .?,]+")) { // 这里的正则是以空格开头的
                        builder.add(w);
                    }
                });
    }

    // 构造一个Stream
    Stream<String> stream() {
        return builder.build();
    }

    public static void main(String[] args) throws IOException {
        new FileToWordsBuilder("/Users/xuyanxin/Documents/xu-self-project/aibook/aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat")
                .stream()
                .limit(7)
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}

/**
输出
Not much of a cheese shop really
*/
```

> **注意**，构造器会添加文件中的所有单词（除了第一行，它是包含文件路径信息的注释），但是其并没有调用 `builder()`。只要你不调用 `stream()` 方法，就可以继续向 `builder` 对象中添加单词。
>
> 在该类的更完整形式中，**你可以添加一个标志位** 用于查看 `builder`是否被调用，并且可能的话增加一个可以添加更多单词的方法。
>
> 在 `Stream.Builder` 调用 `builder()`方法后继续尝试添加单词会产生一个异常。

```java
// 完整版 FileToWordsBuilder.java 我添加了上面书上说的两个实验

// FileToWordsBuilder.java
public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream.builder();

    // 当 Stream 真正被构件时该标志位被设置为 true.
    boolean isStreamBuild = false;

    public FileToWordsBuilder(String filePath) throws IOException {
        Files.lines(Paths.get(filePath))
                .skip(1) // 跳过开头行
                .forEach(line -> {
                    for (String w : line.split("[ .?,]+")) { // 这里的正则是以空格开头的
                        builder.add(w);
                    }
                });
    }

    // 手动向 Builder中添加单词的方法
    public void addToBuilder(String words) {
        builder.add(words);
    }



    // 构造一个Stream
    Stream<String> stream() {
        isStreamBuild = true;
        return builder.build();
    }

    public static void main(String[] args) throws IOException {
        FileToWordsBuilder fileToWordsBuilder = new FileToWordsBuilder("Cheese.dat");
        fileToWordsBuilder.addToBuilder("手动添加一个单词");
        Stream<String> stream = fileToWordsBuilder
                .stream();
        fileToWordsBuilder.addToBuilder("当Builder 已经被构建时再调用 add()会导致异常");
        stream
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
Exception in thread "main" java.lang.IllegalStateException
	at java.util.stream.Streams$StreamBuilderImpl.accept(Streams.java:373)
	at java.util.stream.Streams$StreamBuilderImpl.add(Streams.java:378)
	at com.aibook.onjava.streams.FileToWordsBuilder.addToBuilderAfterBuild(FileToWordsBuilder.java:39)
	at com.aibook.onjava.streams.FileToWordsBuilder.main(FileToWordsBuilder.java:55)
	*/

```

#### Arrays

> `Arrays` 类中含有一个名为 `stream()`的静态方法，用于把数组转换称为流。
>
> 我们可以重写 `interfaces/Machine.java` 中的主方法用于创建一个流，并将 `execute()` 应用于每一个元素:

```java


public class Machine2 {
    public static void main(String[] args) {
        Arrays.stream(new Operations[]{
                () -> Operations.show("Bing"),
                () -> Operations.show("Crack"),
                () -> Operations.show("Twist"),
                () -> Operations.show("Pop"),
        }).forEach(Operations::execute);
    }
}

/**
输出
Bing
Crack
Twist
Pop
*/
// 这里 Operations 的代码是第十章的，一并放这:
public interface Operations {
    void execute();


    static void runOps(Operations... ops) {
        for (Operations o : ops) {
            o.execute();
        }
    }

    static void show(String msg) {
        System.out.println(msg);
    }

}
```

> `new Operations[]` 动态创建了 `Operation` 对象的的数组
>
> `stream` 同样可以产生 IntStream,LongStream和 DoubleStream

【也就是说存在基础类型的包装器类的流】

```java
// ArrayStreams.java

public class ArrayStreams {
    public static void main(String[] args) {
        Arrays.stream(new double[] {3.14159,2.718,1.618})
                .forEach( n -> System.out.format("%f ",n));
        System.out.println();

        Arrays.stream(new int[]{1,3,5})
                .forEach(n->System.out.format("%d",n));
        System.out.println();

        Arrays.stream(new long[] { 11, 22, 44, 66 })
                .forEach(n -> System.out.format("%d ", n));
        System.out.println();

        // 选择一个子域 [3,6]
        Arrays.stream(new int[]  { 1, 3, 5, 7, 15, 28, 37 },3,6)
                .forEach(n -> System.out.format("%d ",n));

    }
}

/**
输出
3.141590 2.718000 1.618000 
135
11 22 44 66 
7 15 28 
*/
```

**【最后一个Stream增加了range范围，这里是闭合区间。】**



#### 正则表达式

> Javae 的正则会在 字符串一张详细介绍。
>
> Java 8在 `java.util.regex.Pattern` 中增加了一个新的方法 `splitStream()`。 这个方法可以根据传入的公式将字符序列转化为流。
>
> **但是有一个限制，输入只能是 CharSequence，因此不能讲流作为 `splitAsStream()` 的参数**

> 再次查看将文件处理为单词刘的过程。这一次，我们使用流将文件分割为单独的字符串，接着使用正则表达式将字符串转为单词流。

```java
// FileToWordsRegexp.java

public class FileToWordsRegexp {
    private String all;

    // 读取文件内容
    public FileToWordsRegexp(String filePath) throws Exception {
        all = Files.lines(Paths.get(filePath))
                .skip(1) // First (comment) line
                .collect(Collectors.joining(" "));
    }
		// 将字符串转化为流
    public Stream<String> stream() {
        return Pattern.compile("[ .,?]+").splitAsStream(all);
    }

    public static void main(String[] args) throws Exception {
        FileToWordsRegexp fw = new FileToWordsRegexp(
                "/Users/xuyanxin/Documents/xu-self-project/aibook/aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat");
        fw.stream()
                .limit(7)
                .map(w -> w + " ")
                .forEach(System.out::print);
      
      // 再次调用 stream,往String中添加后2个单词
        fw.stream()
                .skip(7)
                .limit(2)
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
输出
Not much of a cheese shop really is it
*/
```

> 在构造器中我们读取了文件中的所有内容。（跳过第一行）
>
> 现在，当你调用 stream() 的时候，可以像往常一样获取一个流，但是现在可以多次调用 stream()  在已存储的字符串中创建一个新的流。
>
> 但是这里有个限制：整个文件必须存储在内存中【因为读取到了String里】，在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：
>
> 1. 流"不需要存储"。流需要一些内部存储，但是只是序列的一小部分，和持有整个序列不同。
> 2. 流是懒加载计算的。
>
> 幸运的是稍后就会知道如何解决这个问题。



### 小结：

本章主要讲了各种情况下对流的创建。

首先 Collection 支持了返回流的接口默认方法，Arrays 也支持了 int ,double ,long 的流的创建，Random 随机数类支持了返回流的形式。

还使用了Stream中的 建造者模式 Builder。

以及接触了 Stream中的 一些基本的Api 比如 `range()`,`Stream.generator()`,

`Stream.iterate()` ,`Stream.skip()`，一些基础的流的操作。





### 参考：

[命令式编程（Imperative） vs声明式编程（ Declarative）](https://zhuanlan.zhihu.com/p/34445114)

[Java Stream API 进阶篇](https://www.cnblogs.com/CarpenterLee/p/6550212.html)  —对各个Stream的API 的分析很清晰。



