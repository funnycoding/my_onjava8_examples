---
layout: post
title: 《On Java8》第十四章——流式编程(2) —— 中间操作
date: 2020年02月21
tags:
- 读书笔记
categories: 
- 《On Java8》
---

## 《On Java8》第十四章 流式编程（2）— 中间操作



### 中间操作

> 中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接其他操作。

<!-- more -->	

#### 跟踪和调试

> `peek()` 操作的目的是帮助调试，它允许你无修改地查看流中的元素：

```java
// Peeking.java
public class Peeking {
    public static void main(String[] args) throws Exception {
        FileToWords.stream("Cheese.dat")
                .skip(21)
                .limit(4)
                .map(w -> w + " ")
                .peek(System.out::print)
                .map(String::toUpperCase)
                .peek(System.out::print)
                .map(String::toLowerCase)
                .forEach(System.out::print);
    }
}

/**
输出
Well WELL well it IT it s S s so SO so
*/

// FileToWords 之前没有定义，为了方便一起放出来
public class FileToWords {
  public static Stream<String> stream(String filePath)
  throws Exception {
    return Files.lines(Paths.get(filePath))
      .skip(1) // First (comment) line
      .flatMap(line ->
        Pattern.compile("\\W+").splitAsStream(line));
  }
}

```

> `FileToWords`稍后定义，它的功能就是 产生字符串对象流。
>
> 之后在其**通过管道时**调用 `peek()` 进行处理
>
> 因为 `peek()` 符合无返回值的 Consumer 函数式接口，所以我们只能观察，无法使用不同的元素来替换流中的对象。

【`peek()` 的源码】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200221164015.png)

```java
//Stream.java
Stream<T> peek(Consumer<? super T> action);


// ReferencePipeline.java
    @Override
    public final Stream<P_OUT> peek(Consumer<? super P_OUT> action) {
        Objects.requireNonNull(action);
        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
                                     0) {
            @Override
            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        action.accept(u);
                        downstream.accept(u);
                    }
                };
            }
        };
    }
```

**问题：【所以就是在 peek() 中的操作不会改变流中的元素？】**

**带着问题继续往下学**

#### 流元素排序

> 在 Randoms.java 中，使用了 `sorted()`默认比较器，并明白了它的实现。
>
> 其实它还有另一种实现形式：传入一个 **Comparator** 参数：

```java
// SortedComparator.java
public class SortedComparator {
    public static void main(String[] args) throws Exception {
        FileToWords
                .stream("/Users/xuyanxin/Documents/xu-self-project/aibook/aibook-book/src/main/java/com/aibook/onjava/streams/Cheese.dat")
                .skip(10)
                .limit(10)
                .sorted(Comparator.reverseOrder())
                .map(w -> w + " ")
                .forEach(System.out::print);
    }
}
/**
输出
you what to the that sir leads in district And 
*/
```

> `sorted()` 内置了默认比较器，这里使用的是反转自然排序。
>
> 你也可以将 Lambda 函数作为参数传递给 `sorted()`

```java
// Comparator.java
		
		// 可以看到这里是调用的集合里实现的反转自身的函数
    default Comparator<T> reversed() {
        return Collections.reverseOrder(this);
    }

```

#### 移除元素

> - `distinct()` 在 Randoms.java 类中的  `distinct()` 可用于移除流中的重复元素。**相比于创建一个 Set 集合，该方法的工作流要少的多。**【那么具体少在哪里呢？，为什么少呢？】
> - `filter(Predicate)`：过滤操作会保留与传递进去的过滤器函数结果为 `true`的元素。
>
> 下面例子中，`isPrime()` 作为过滤器函数，用于检测是否是质数：

```java
// Prime.java
public class Prime {
  	// 判断是否为质数
    public static boolean isPrime(long n) {
        return LongStream.rangeClosed(2, (long) Math.sqrt(n))
                .noneMatch(i -> n % i == 0);
    }
		
  	// 生成 LongStream，filter中传入 isPrime() 算法排除非质数元素
    public LongStream numbers() {
        return LongStream.iterate(2, i -> i + 1)
                .filter(Prime::isPrime);
    }

    public static void main(String[] args) {
        new Prime()
                .numbers()
                .limit(10)
                .forEach(n -> System.out.format("%d ", n));

        System.out.println();

        new Prime().numbers()
                .skip(90)
                .limit(10)
                .forEach(n -> System.out.format("%d ", n));
    }
}
/**
输出
2 3 5 7 11 13 17 19 23 29
467 479 487 491 499 503 509 521 523 541
*/
```

> 解析一下这里使用到的 Api：
>
> `rangeClosed()` 里第一个参数是上限值。如果不能整除，即余数不等于0，则 `noneMatch()` 操作返回 `true`，如果出现任何等于0的操作，则结果返回 `false` 。 `noneMatch()` 操作一旦失败就会退出。

**【涉及到的API的源码：】**

```java
// LongStream.java
    
		//以1为增量返回从startInclusive（包括）到endInclusive（包括）的顺序有序LongStream。
    public static LongStream rangeClosed(long startInclusive, final long endInclusive) {
        if (startInclusive > endInclusive) {
            return empty();
        } else if (endInclusive - startInclusive + 1 <= 0) {
            // Size of range > Long.MAX_VALUE
            // Split the range in two and concatenate
            // Note: if the range is [Long.MIN_VALUE, Long.MAX_VALUE] then
            // the lower range, [Long.MIN_VALUE, 0), and upper range,
            // [0, Long.MAX_VALUE], will both be further split in two
            long m = startInclusive + Long.divideUnsigned(endInclusive - startInclusive, 2) + 1;
            return concat(range(startInclusive, m), rangeClosed(m, endInclusive));
        } else {
            return StreamSupport.longStream(
                    new Streams.RangeLongSpliterator(startInclusive, endInclusive, true), false);
        }
    }
	
// Math.java

/**
返回正确取整的double值的平方根。 特别案例：
如果参数为NaN或小于零，则结果为NaN。
如果参数为正无穷大，则结果为正无穷大。
如果自变量为正零或负零，则结果与自变量相同。
*/
 public static double sqrt(double a) {
        return StrictMath.sqrt(a); // default impl. delegates to StrictMath
                                   // Note that hardware sqrt instructions
                                   // frequently can be directly used by JITs
                                   // and should be much faster than doing
                                   // Math.sqrt in software.
    }
```



#### 应用函数到元素

> - `map(Function)`：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。
> - `mapToInt(ToIntFunction)`：操作同上，但是结果是 **IntStream**
> - `mapToLong(ToLongFunction)`：操作同上，但是结果是 **LongStream**
> - `mapToDouble(ToDoubleFunction)`：操作同上，但是结果是 **DoubleStream**
>
> **例子中使用 `map()` 映射多种函数到一个字符串流中。**

```java
// FunctionMap.java 
public class FunctionMap {
    static String[] elements = {"12", "", "23", "45"};

    // 将字符串转为字符串流
    static Stream<String> testStream() {
        return Arrays.stream(elements);
    }

    // 遍历 Function
    static void test(String descr, Function<String, String> func) {
        System.out.println("----(" + descr + " )----");
        testStream()
                .map(func)
                .forEach(System.out::println);
    }

    public static void main(String[] args) {
        // 给每个元素增加括号
        test("add brackets", s -> "[" + s + "]");

        // 给所有元素加一，如果元素不是 Int类型则直接返回
        test("Increment", s -> {
            try {
                return Integer.parseInt(s) + 1 + "";
            } catch (NumberFormatException e) {
                return s;
            }
        });

        // 将包含2的元素中的2替换为9
        test("Replace", s -> s.replace("2", "9"));


        // 如果字符串长度大于0 返回第一位的元素，否则返回原字符串
        test("Take last digit",
                s -> s.length() > 0 ? s.charAt(s.length() - 1) + "" : s);
    }
}

```

> `map()` 将一个字符串映射到另一个字符串，但是我们完全可以产生和接收类型完全不同的例子，从而改变流的数据类型：

**【其实map就是一个对元素的遍历操作，这里不查资料只看书我看不懂这个对map的描述，写的不好。】**

```java
// FunctionMap2.java
class Numberd {
    final int n;

    public Numberd(int n) {
        this.n = n;
    }

    @Override
    public String toString() {
        return "Numberd(" + n + ")";
    }
}

public class FunctionMap2 {
    public static void main(String[] args) {
        // 这里将 Stream<Integer> 流转为了 Stream<Numberd>流
        Stream.of(1,5,7,9,11,13)
                .map(Numberd::new)
                .forEach(System.out::println);
    }
}

```



> 例子中将获取到的证书通过构造器 Numberd:new 转化为了 `Numberd`类型。
>
> 如果使用 Function 返回的结果是数值类型的一种。**必须使用 `mapTo数值类型`进行替代：**

```java
// FunctionMap3.java
public class FunctionMap3 {
    public static void main(String[] args) {
        Stream.of("5","7","9")
                .mapToInt(Integer::parseInt)
                .forEach(n -> System.out.format("%d ",n));

        System.out.println();
        Stream.of("17", "19", "23")
                .mapToLong(Long::parseLong)
                .forEach(n -> System.out.format("%d ", n));

        System.out.println();
        Stream.of("17", "1.9", ".23")
                .mapToDouble(Double::parseDouble)
                .forEach(n -> System.out.format("%f ", n));
    }
}
/**
输出
5 7 9
17 19 23
17.000000 1.900000 0.230000
*/
```

> 遗憾的是，Java 设计者并没有尽最大努力去消除基本类型。**【怎么理解啊？】**

#### 在 map() 中组合流

> 假设现在有一个元素流，并打算对其中元素使用 `map()` 函数。但是这个函数产生的是一个流，于是原本的元素流变成了元素流的流。
>
> 【也就是`Stream<Element>` 变成了 `Stream<Stream<Elemen>>`?】
>
> `flatMap()`做了两件事：**将产生流的函数应用在每个元素上**（与 `map()`所做的相同），**然后将每个流都变化为元**素，所以最后仅产生元素。
>
> `flatMap(Function)` ： 当 `Function` 产生流时使用。
>
> `flatMapToInt(Function)`：当 `Function`产生 `IntStream`时使用
>
> `flatMapToLong(Function)`：当 `Function` 产生 `LongStream` 时使用。
>
> `flatMapToDouble(Function)`：当 `Function` 产生 `DoubleStream` 时使用。
>
> 看例子：

```java
// StreamOfStreams.java

public class StreamOfStreams {
    public static void main(String[] args) {
        Stream.of(1,2,3)
                .map( i -> Stream.of("Gonzo","K","B"))
                .map(e -> e.getClass().getName())
                .forEach(System.out::println);
    }
}

/**
输出
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
*/
```

> 这里我们并没有得到期待中的字符串流，而是 Head 流。
>
> 可以使用 `flatMap()`解决这个问题：

```java

// FlatMap.class
public class FlatMap {
    public static void main(String[] args) {
        Stream.of(1,2,3)
                .flatMap( i -> Stream.of("G","B","K"))
                .forEach(System.out::println);
    }
}
/**
输出
G
B
K
G
B
K
G
B
K

*/
```

> 从映射返回的每个流都会自动扁平为组成它的字符串。

 【也就是将流对象转为了流中保存的元素】

> 另一个从整数流,然后使用每一个整数去创建更多的随机数：



```java
public class StreamOfRandoms {
    static Random rand = new Random(47);
    
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5)
                .flatMapToInt(i -> IntStream.concat(
                        rand.ints(0, 100)
                                .limit(i), IntStream.of(-1)))
                .forEach(n -> System.out.format("%d ", n));
    }
}

/**
输出
58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9 -1
*/
```

> 这里使用了 `concat()` 函数，它以参数顺序组合两个流。
>
> 如此，在每个随机的 Integer 流的末尾添加一个 -1 作为分隔标记。 
>
> 可以看出最终流确实是从一组扁平流中创建的。
>
> 因为 `rand.ints()`产生的是一个 `IntStream`，所以必须使用 `flatMap()`、`concat()`和 `of()`的特定整数形式。



> 再来一个将文件划分为单词流的任务。
>
> 使用 FileToWordsRegexp.java ，它的问题是需要将整个文件读入行列表中—这显然需要存储该列表，而我们真正的需求是创建一个**不需要中间存储层的单词流。**
>
> 使用 `flatMap()`来解决这个问题

```java
// FileToWords.java
public class FileToWords {
    public static Stream<String> stream(String filePath) throws IOException {
      return Files.lines(Paths.get(filePath))
              .skip(1)
              .flatMap(line -> Pattern.compile("\\W+").splitAsStream(line));
    }
}

```

> stream() 现在是一个静态方法，因为它可以自己完成整个流创建过程。
>
> `\\W+`是一个正则表达式，表示**非单词字符** ， `+` 表示可以出现一次或者多次。
>
> **小写形式的 `\\w`表示单词字符**



> 之前的问题是 `Pattern.compile().splitAsStream()` 产生的结果是一个流，这意味着当我们只是想要简单的字符串的时候回，在传入的行流（stream of lines) 上调用 `map()` 会产生一个 String 流的流。 
>
> 使用 `flatMap()` 可以将元素流的流扁平化为元素流。
>
> 或者使用 `String.split()` 生成一个数组，然后被 `Arrays.stream()` 转化为流

```java
.flatMap(line -> Arrays.stream(line.split("\\W+")))
```

> 有了真正的而非存储于 FilesToWordsRegexp.java 中基于集合存储的流，就导致每次使用都必须重头创建一个流，**因为流不能被复用。**

```java
// streams/FileToWordsTest.java
public class FileToWordsTest {
    public static void main(String[] args) throws Exception {
       ileToWords.stream("Cheese.dat")
                .limit(7)
                .forEach(s -> System.out.format("%s ", s));
        System.out.println();
        FileToWords.stream("Cheese.dat")
                .skip(7)
                .limit(2)
                .forEach(s -> System.out.format("%s ", s));
    }
}

/**
输出
Not much of a cheese shop really 
is it 
*/
```

### 本章小结：

本章主要讲了对流中元素进行的中间操作：

- `peek()` 帮助调试，peek 的源码之前也贴了，接收一个没用返回值的 lambda 表达式，可以做一些输出，外部处理，同时 peek 的返回值还是流，因为其是中间操作，所以可以对流继续进行别的操作。

- `sorted()` 流元素排序，对流的元素按自然顺序排序，也可以传入 Compartor 比较，Java 有内置比较器，也可以传入一个 Lambda 表达式定义你自己的函数。 `sorted()`排序比数组排序强的地方就是 你可以先对 Stream 进行一系列的操作如 `map()`、`filter()`、`limit()`、`skip()`、`distinc()`、然后进行 `sorted()` 排序能帮助程序明显缩短执行时间

- `distinct()`这个语法让我有强烈的 SQL 既视感，消除流中的重复元素。其原理依据于 Object 的 `equals()`(来源其方法注释)

- `filter(Predicate)`：和 distinct 类似，是过滤操作。传入一个 Lambda 函数，保留下函数结果为 true 的元素。

- `map()`将输入的元素映射为输出元素，也就是可以对元素进行修改，map 生成的是 1:1 的映射，每个输入的元素都按照规则转为另一个元素。

  ```java
  // 将List中的元素都转为大写
  List<String> output = wordList.stream().
  map(String::toUpperCase).
  collect(Collectors.toList());
  ```

- `flatMap()`将包含流的流扁平化，`map()` 处理一对一的映射关系， flatMap() 处理一对多的映射关系

  这里有一个 关于**流管道** 的动画感觉非常传神，搬运到这里。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/fuse.svg)



### 参考

[Java Stream 详解](https://colobu.com/2016/03/02/Java-Stream)

[Java 8 peek() 方法的一些疑惑](https://segmentfault.com/q/1010000004681887)

[Stream 幕后原理](https://www.ibm.com/developerworks/cn/java/j-java-streams-3-brian-goetz/index.html)

[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）](https://www.cnblogs.com/figure9/p/java-8-lambdas-insideout-language-features.html)



