**【之前的部分已经把基本的泛型语法都讲完了，作者用了挺多例子从不同的方面来介绍泛型的特性和本质。到这一部分，说的基本都是作者的经验之谈，以及泛型可能引发的问题】**

### 问题

> 本节将阐述在使用 Java 泛型时会出现的各类问题。



#### 任何基本类型都不能作为类型参数

> 泛型类型参数不能是基本类型，只能是其对应的包装类型。

【这个问题其实挺简单的，看一眼就能明白，编译器在泛型上又做了拆装箱的转换】

```java
// generics/ListOfInt.java
// Autoboxing compensates for the inability
// to use primitives in generics
// 通过 IntStream 生成一个整数流 然后通过 Boxed 转为 Stream<Integer> 
public class ListOfInt {
    public static void main(String[] args) {
        List<Integer> li = IntStream.range(38, 48)
                .boxed()
                .collect(Collectors.toList());
        System.out.print(li);
    }
}
/**
输出
[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
*/
```



> 这种方式工作的很好，自动装箱隐藏了转换过程。
>
> 但是如果有性能问题，就需要使用专门为基本类型适配的特殊版本的集合。一个开源版本的实现是：
>
> `org.apache.commons.collections.primitives`。
>
> 下面是**另一种方式**，它可以创建持有 `Byte` 的 `Set` 集合：

```java
// generics/ByteSet.java
public class ByteSet {
    Byte[] possibles = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
    // But you can't do this:
    //Set<Byte> mySet2 = new HashSet<>(Arrays.<Byte>asList(1, 2, 3, 4, 5, 6, 7, 8, 9));
}
```

> 自动装箱机制解决了一部分问题，但是没有解决所有问题。

【这里 mySet2 与 mySet 之间的区别就是 mySet2 在构造函数中指名了 asList的返回值。】

![image-20200315200306062](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200315200306.png)

哦不，我想我弄错了重点，【**重点是 asList 的入参这里给了一个 int 数组，而不是显示指定为 Byte 的数组。**】

> 下面的例子中，`FillArray` 接口包含一些通用方法，这些方法使用 `Supplier` 来用对象填充数组（因为该方法是静态的，所以泛型机制无法工作） 
>
> `Supplier` 实现来自**数组**那一章，并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：

```java
// Fill an array using a generator:
// generics/PrimitiveGenericTest.java
interface FillArray {
    static <T> T[] fill(T[] a, Supplier<T> gen) {
        Arrays.setAll(a, n -> gen.get());
        return a;
    }

    static int[] fill(int[] a, IntSupplier gen) {
        Arrays.setAll(a, n -> gen.getAsInt());
        return a;
    }

    static long[] fill(long[] a, LongSupplier gen) {
        Arrays.setAll(a, n -> gen.getAsLong());
        return a;
    }

    static double[] fill(double[] a, DoubleSupplier gen) {
        Arrays.setAll(a, n -> gen.getAsDouble());
        return a;
    }
}

public class PrimitiveGenericTest {
    public static void main(String[] args) {
        // 这里我把 Rand.String 改为 StringGen了，不然老解决包的冲突很烦人
        String[] strings = FillArray.fill(new String[5], new Rand.StringGen(9));
        System.out.println(Arrays.toString(strings));

        int[] integers = FillArray.fill(new int[9], new Rand.Pint());
        System.out.println(Arrays.toString(integers));
    }

}
/**
输出
[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
*/
```

> **自动装箱不适用于数组**，因此必须创建 `FillArray.fill()` 的重载版本，或创建产生 `Wrapped` 输出的生成器。 `FillArray` 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充好的数组。

#### 实现参数化接口

> 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。
>
> 下面是产生这种冲突的情况：

![image-20200315205752647](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200315205752.png)

```java
// generics/MultipleInterfaceVariants.java
// {WillNotCompile}
package generics;

interface Payable<T> {}

class Employee implements Payable<Employee> {}

class Hourly extends Employee implements Payable<Hourly> {}
```

> Hourly Bun编译，因为擦除会将 `Payable<Employe>` 和 `Payable<Hourly>` 擦除为 相同的类：`Payable`。
>
> 这样，**上面的代码就意味着在重复两次实现相同的接口**。有趣的是，如果从 Payable 的两种用法中都移除泛型参数（就像 编译器在擦除阶段所做的那样） 这段代码就可以编译。

```java
public class MultipleIntegerfaceVariants {
    interface Payble<T>{}

    class Employee implements Payble {

    }
		// 这样是 OK的
    class Hourly extends Employee implements Payble {

    }
}

```



> 在使用某些更基本的 **Java** 接口例如 `Comparable<T>` 时，这个问题可能会让人十分恼火。

#### 转型和警告

> 使用带有泛型类型参数的转型 或 instanceof 不会有任何效果。
>
> 下面的集合在内部将各个值存储为 Object，并在获取这些值的时候，再将它们转型回 T:

```java
// generics/GenericCast.java
class FixedSizeStack<T> {
    private final int size;
    private Object[] storage;
    private int index = 0;

    FixedSizeStack(int size) {
        this.size = size;
        storage = new Object[size];
    }

    public void push(T item) {
        if (index < size) {
            storage[index++] = item;
        }
    }

    // 这是一个栈结构
    @SuppressWarnings("unchecked")
    public T pop() {
        System.out.println("index: " + index);
        return index == 0 ? null : (T) storage[--index];
    }

    @SuppressWarnings("unchecked")
    Stream<T> stream() {
        return (Stream<T>) Arrays.stream(storage);
    }
}


public class GenericCast<T> {
    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");

    public static void main(String[] args) {
        FixedSizeStack<String> strings = new FixedSizeStack<>(letters.length);
        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
                .forEach(strings::push);
        System.out.println(strings.pop());
        strings.stream()
                .map(s -> s+" ")
                .forEach(System.out::print);
    }
}

```

> 如果没有 @SuppressWarning 注解，编译器将对 pop() 产生 "uncheckedcast" 警告。由于擦除的原因，编译器无法知道这个转型是否安全，并且 pop() 方法实际上并没有执行任何转型。这是因为，**T 被擦除到它的第一个边界，默认情况下是 `Object`。**【没有明显标明边界的边界都是 Object】
>
> **因此 `pop()` 实际上只是将 `Object` 转型为 `Object`。**
>
> 优势泛型没有消除对类型转换的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：

```java
// generics/NeedCasting.java
public class NeedCasting {
    @SuppressWarnings("unchecked")
    public void f(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(args[0]));

        List<Widget> shapens = (List<Widget>) in.readObject(); // 这里虽然使用泛型但是仍然会警告 未检查的类型转换
    }
}

```

> **readObject() 无法知道正在读取的是什么，因此返回的必须是转型的对象。**
>
> 但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
>
> ```
> NeedCasting.java uses unchecked or unsafe operations.
> Recompile with -Xlint:unchecked for details.
> 
> And if you follow the instructions and recompile with  -
> Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
> 
> NeedCasting.java:10: warning: [unchecked] unchecked cast
>     List<Widget> shapes = (List<Widget>)in.readObject();
>     required: List<Widget>
>     found: Object
> 1 warning复
> ```
>
> **你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，既通过泛型类来转型：**

```java
// generics/ClassCasting.java
public class ClassCasting {
    public void f(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(args[0]));
        // 下面的无法被编译 这里使用类型转换不能带有泛型
        //List<Widget> lw1 = List<>.class.cast(in.readObject());
        List<Widget> lw2 = List.class.cast(in.readObject());
    }
}

```

但是，不能转型到实际类型（ `List` ）。也就是说，不能声明：

```
List<Widget>.class.cast(in.readobject()) 
```

甚至当你添加一个像下面这样的另一个转型时：

```
(List<Widget>)List.class.cast(in.readobject())
```

仍旧会得到一个警告。

![image-20200315220629355](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200315220629.png)

#### 重载

> 下面的程序无法编译，即使看起来是合理的：

```java
// generics/UseList.java
public class UseList<W,T> {
    // 擦除导致这两个方法的签名重合
    void f(List<T> v) {}
    void f(List<W> v) {}
}

```

> 因为**擦除**，所以**重载方法产生了的类型签名**。
>
> 因而，当**擦除后的参数不能产生唯一的参数列表时**，你必须提供不同的方法名：

```java
// generics/UseList2.java

import java.util.*;

public class UseList2<W, T> {
    void f1(List<T> v) {}
    void f2(List<W> v) {}
}
```

> 幸运的是，编译器可以检测到因泛型擦除导致的方法签名重复问题。

#### 基类劫持接口

> 假设你有一个实现了 `Comparable` 接口的 `Pet` 类：

```java
// generics/ComparablePet.java
public class ComparablePet implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet o) {
        return 0;
    }
}

```



> 尝试缩小 **ComparablePet** 子类的**比较类型**是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较

```java
// generics/HijackedInterface.java
// {WillNotCompile}
// 这里编译器会告诉你 Comparable 不能持有多种不同给的参数
class Cat extends ComparablePet implements Comparable<Cat> {
    // error: Comparable cannot be inherited with
    // different arguments: <Cat> and <ComparablePet>
    // class Cat
    // ^
    // 1 error
    public int compareTo(Cat arg) {
        return 0;
    }
}

```

> 不幸的是**，这不能工作**。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：【因为泛型擦除的缘故，如果其他类修改了 **Comparable** 的类型参数，泛型类型冲突 】

```java
// generics/RestrictedComparablePets.java
// 这里这个类名不知道作者想表达啥。。。 跟 Hamster 对不上
public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet o) {
        return super.compareTo(o);
    }
}

// Or just: 不指明泛型参数
class Gecko extends ComparablePet {
    public int compareTo(ComparablePet arg) {
        return 0;
    }
}
```

> **Hamster** 显示了重新实现 **ComparableSet** 中相同的接口是可能的，**只要接口完全相同，包`括参数类型`**。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。（另一个一样的道路）

### 自限定的类型

> 在 Java 泛型中，有一个似乎**经常性出现的惯用法**，它相当令人费解：

```java
class SelfBounded<T extends SelfBounded<T>> { // ...
```

> 这里的泛型类型被限定为是该类的子类。
>
> **`SelfBounded`** 类接受泛型参数 **`T`**，而 **`T`** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。

#### 古怪的循环泛型

#### 自限定

#### 参数协变



### 动态类型安全

> 因为泛型需要兼容 Java 5之前的代码，所以旧的未实现泛型的代码可能会破坏你的集合。
>
> Java 5 的 java.util.Collections 中有一组便利工具，可以解决在这种情况下的类型检查问题:
>
> 它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望**动态检查的集合当作第一个参数接受**，**并将你希望强制要求的类型作为第二个参数接受。**
>
> 受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，**如果使用受检查的集合，就可以发现谁在试图插入不良对象。**【将异常提前到了编译期】 让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：

```java
// generics/CheckedList.java
// Using Collection.checkedList()
// 使用集合工具检查 List 类型
public class CheckedList {
    // 这里是一个没有使用泛型的 List 集合，所以什么对象都可以放进去
    // 这里看名字应该是一个只存储 Dog 对象的集合，然而这里我们放了一个 Cat() 进去
    @SuppressWarnings("unchecked")
    static void oldStyleMethod(List probablyDogs) {
        probablyDogs.add(new Cat());
    }

    public static void main(String[] args) {
        ArrayList<Dog> dogs1 = new ArrayList<>();
        oldStyleMethod(dogs1); // 在这个泛型参数类型为 Dog 的 ArrayList 中，放入了一个 Cat() 对象
        // 一个带类型检查的List
        List<Dog> dogs2 = Collections.checkedList(new ArrayList<>(), Dog.class);

        try {
            oldStyleMethod(dogs2); // 往带类型检查的 List 中 放入与类型不符的对象就会抛出运行时异常
        } catch (Exception e) {
            System.out.println("Excepted :" + e);
        }
        System.out.println("父类类型检查例子：");
        // Derived types work fine: 当类型检查为父类时，向集合中添加子类的对象不会引起异常
        List<Pet> pets = Collections.checkedList(
                new ArrayList<>(), Pet.class);
        pets.add(new Dog());
        pets.add(new Cat());

    }
}
/**
输出
Excepted :java.lang.ClassCastException: Attempt to insert class pets.Cat element into collection with element type class pets.Dog
父类类型检查
*/
```

> 运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，**将子类对象放置到将要检查基类型的受检查容器中是没有问题的。**

### 泛型异常

> 由于擦除的原因 **`catch`** 语句不能捕获泛型类型的异常，因为在**编译期** 和**运行时** 都必须知道异常的确切类型。【所以异常不存在泛型。】
>
> 泛型类也不能直接或间接继承自 **`Throwable`**（这将进一步组织你去定义不能捕获的泛型异常）。
>
> **但是类型参数可能会在一个方法的 throws 子句中用到，这使得你可以编写随着 受检异常类型变化的泛型代码。**

```java
// generics/ThrowGenericException.java

interface Processor<T, E extends Exception> {
    // 可以使用 throws 抛出 泛型类型的异常
    void process(List<T> resultCollection) throws E;
}

// Processor 的代理类，运行 Processor的方法
class ProcessRunner<T, E extends Exception> extends ArrayList<Processor<T, E>> {
    List<T> processAll() throws E {
        List<T> resultCollector = new ArrayList<>();
        // 调用每个 Processor 的 process 方法
        for (Processor<T, E> processor : this) {
            processor.process(resultCollector);
        }
        return resultCollector;
    }
}

// 自己定义的异常类
class Failure1 extends Exception {
}

// Processor 的具体实现类
class Processor1 implements Processor<String, Failure1> {

    static int count = 3;

    @Override
    public void process(List<String> resultCollection) throws Failure1 {
        if (count-- > 1) {
            resultCollection.add("Hep!");
        } else {
            resultCollection.add("Ho!");
        }
        // 但是感觉这个循环进不去啊
        if (count < 0) {
            throw new Failure1();
        }

    }
}


// 第二个自定义异常
class Failure2 extends Exception {
}

class Processor2 implements Processor<Integer, Failure2> {
    static int count = 2;

    @Override
    public void process(List<Integer> resultCollection) throws Failure2 {
        if (count-- == 0) {
            resultCollection.add(47);
        } else {
            resultCollection.add(11);
        }
        // 这时会抛出异常
        if (count < 0) {
            throw new Failure2();
        }
    }
}


public class ThrowGenericException {
    public static void main(String[] args) {
        ProcessRunner<String, Failure1> runner = new ProcessRunner<>();
        for (int i = 0; i < 3; i++) {
            runner.add(new Processor1());
        }

        try {
            System.out.println(runner.processAll());
        } catch (Failure1 failure1) {
            System.out.println(failure1);
        }

        ProcessRunner<Integer, Failure2> runner2 =
                new ProcessRunner<>();
        for (int i = 0; i < 3; i++) {
            runner2.add(new Processor2());
        }
        try {
            System.out.println(runner2.processAll());
        } catch (Failure2 e) {
            System.out.println(e);
        }
    }
}
/**
输出
[Hep!, Hep!, Ho!]
generics.Failure2
*/
```

> **Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `ListresultCollector` 中（这被称为***收集参数***）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。 **如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。**

### 混型



> 混型的基本概念是混合多个类的能力【但是实际上我是第一次见这个概念】 以产生**一个可以表示混型中所有类型的类。**
>
> 混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果在混型类中修改某些东西，作为一种意外的好处，**这些修改将会应用于所有的类型之上。**
>
> **混型有些 面向切面编程的味道，切面经常被建议用来解决混型问题。**



#### C++ 中的混型

> C ++ 使用多重继承最大的理由就是为了使用混型。
>
> 但是对于混型更优雅的的方式是使用参数化类型，因为混型就是继承自其类型的参数的类。
>
> C ++ 由于能够记住模板参数的类，所以可以很容易地创建混型。
>
> 下面这个例子有两个混型类型：一个让你在每个对象中混入一个时间戳这样的属性，另一个可以混入序列号（看起来确实有点切面的感觉，写入一段切面代码，所有业务类都可以执行这段代码）

```c++
// generics/Mixins.cpp

#include <string>
#include <ctime>
#include <iostream>
using namespace std;

template<class T> class TimeStamped : public T {
    long timeStamp;
public:
    TimeStamped() { timeStamp = time(0); }
    long getStamp() { return timeStamp; }
};

template<class T> class SerialNumbered : public T {
    long serialNumber;
    static long counter;
public:
    SerialNumbered() { serialNumber = counter++; }
    long getSerialNumber() { return serialNumber; }
};

// Define and initialize the static storage:
template<class T> long SerialNumbered<T>::counter = 1;

class Basic {
    string value;
public:
    void set(string val) { value = val; }
    string get() { return value; }
};

int main() {
    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
    mixin1.set("test string 1");
    mixin2.set("test string 2");
    cout << mixin1.get() << " " << mixin1.getStamp() <<
      " " << mixin1.getSerialNumber() << endl;
    cout << mixin2.get() << " " << mixin2.getStamp() <<
      " " << mixin2.getSerialNumber() << endl;
}
/* Output:
test string 1 1452987605 1
test string 2 1452987605 2
*/
```

> 在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以**将现有类映射到新的子类上**。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
>
> ```c++
> TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
> 
> ```

> **Java 因为泛型擦除不允许这样做。因此 反省类不能直接继承自一个泛型参数。**
>
> 作者觉得 Java 这种泛型看起来有处理一件事的希望，但是当你真正处理的时候 你发现自己无法做到。（泛型的局限性）



#### 与接口混合

> 使用接口产生混型效果是一种更常见的解决方案：

```java
// generics/Mixins.java
// 返回时间戳功能
interface TimeStamped {
    long getStamp();
}

class TimeStampedImp implements TimeStamped {
    private final long timeStamp;

    public TimeStampedImp() {
        this.timeStamp = new Date().getTime();
    }

    @Override
    public long getStamp() {
        return timeStamp;
    }
}

// 返回序列号功能
interface SerialNumber {
    long getSerialNumber();
}

class SerialNumberImp implements SerialNumber {
    private static long counter = 1;
    private final long serialNumber = counter++;

    @Override
    public long getSerialNumber() {
        return serialNumber;
    }
}

interface Basic {
    void set(String val);

    String get();
}

class BasicImp implements Basic {
    private String value;

    @Override
    public void set(String val) {
        value = val;
    }

    @Override
    public String get() {
        return value;
    }
}


// 同时实现2种接口，并初始化接口的对应实现类并调用接口的功能就实现了功能的整合。
class Mixin extends BasicImp implements TimeStamped, SerialNumber {
    private TimeStamped timeStamped = new TimeStampedImp();
    private SerialNumber serialNumber = new SerialNumberImp();

    @Override
    public long getStamp() {
        return timeStamped.getStamp();
    }

    @Override
    public long getSerialNumber() {
        return serialNumber.getSerialNumber();
    }
}


public class Mixins {
    public static void main(String[] args) {
        Mixin mixin1 = new Mixin();
        Mixin mixin2 = new Mixin();
        mixin1.set("Test String 1");
        mixin2.set("Test String 2");
        System.out.println(mixin1.get() + " " + mixin1.getStamp() + " " + mixin1.getSerialNumber());
        System.out.println(mixin2.get() + " " + mixin2.getStamp() + " " + mixin2.getSerialNumber());

    }
}
/**
输出
Test String 1 1584345573657 1
Test String 2 1584345573657 2
*/
```

> Mixin 类基本上在使用 **委托**，因此每个混型都要求在 Mixin 中有一个具体的对象。而你必须在 Mixin 中编写必须的方法，将方法调用转发给恰当的对象。
>
> 这个示例非常简单，当使用更复杂的混型时，代码数量会急速增加。



#### 使用装饰器模式

> **混型**使用方式与 **装饰器** 设计模式看起来关系很近 。**装饰器经常满足于各种可能的组合，而直接子类化会产生过多的类。**
> **装饰器模式使用分层对象来动态透明地向单个对象中添加责任**。 **装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口**。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。 **这使得对装饰器的使用是透明的** —— 无论对象是否被装饰，都可以拥有一个向对象发送的公共消息集。
> 装饰类也可以添加新方法，但是如你所见这将是受限的。 装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次类型） 来实现的，而**混型是基于继承**的。
> **因此可以将基于参数化类型的混型当做一种泛型装饰器机制。**这种机制不需要装饰器设计模式的集成结构，可以将之前的例子改写为 **装饰器**：

```java
// generics/decorator/Decoration.java
// 用装饰器模式重写混型继承类
// 后面的代码既视感很强，就是 Java 的 旧的 I/O 类就是这样的，构造一个对象需要套好几个对象来进行功能的叠加。
class Basic {
    private String value;

    public String get() {
        return value;
    }

    public void set(String value) {
        this.value = value;
    }
}

class Decorator extends Basic {
    protected Basic basic;

    public Decorator(Basic basic) {
        this.basic = basic;
    }

    // 这样重写跟 super.get() 有啥区别？ 不都是调用父类的方法么？ 哦 区别是 这里的 Basic 可以动态改变
    @Override
    public String get() {
        return basic.get();
    }

    @Override
    public void set(String value) {
        basic.set(value);
    }
}

class TimeStamped extends Decorator {
    private final long timeStamp;

    public TimeStamped(Basic basic) {
        super(basic);
        this.timeStamp = new Date().getTime();
    }

    // 这里又多了一个独有的方法
    public long getStamp() {
        return timeStamp;
    }
}

// Decorator 相当于一个基础功能，然后不同的子功能再去继承 Decorator 包装类
class SerialNumbered extends Decorator {
    private static long counter = 1;
    private final long serialNumber = counter++;

    public SerialNumbered(Basic basic) {
        super(basic);
    }

    public long getSerialNumber() {
        return serialNumber;
    }
}

public class Decoration {
    public static void main(String[] args) {
        TimeStamped t = new TimeStamped(new Basic());
        TimeStamped t2 = new TimeStamped(new SerialNumbered(new Basic()));
        //- t2.getSerialNumber(); // Not available 因为 TimeStamp 类中没有获取序列号的方法
        SerialNumbered s = new SerialNumbered(new Basic());
        SerialNumbered s2 = new SerialNumbered(
                new TimeStamped(new Basic()));
        //- s2.getStamp(); // Not available 同理，获取序列号的对象也没有获取时间戳的方法
    }

}

```

> 产生泛型的类包含所有感兴趣的方法，但是由于使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以有多个功能对象，**但是最后一层才是实际的对象，也就是只有最后的方法是可见的。**
>
> 而混型的类型是所有被混合到一起的类型。
>
> 对于装饰器来说明显的缺陷是只能工作于装饰中的最后一层。而混型则更自然。
>
> **因此装饰器只是对由混型提出的问题一种具现的解决方案。**

#### 与动态代理混合

> 可以使用动态代理来创建比装饰器更贴近混型模型的机制。通过使用动态代理，所产生的的类的动态类型将会是已经混入的组合类型。由于动态代理的限制，**每个被混入的类都必须是某个接口的实现**：

```java
// generics/DynamicProxyMixin.java
// 使用动态代理来完成混型功能增强，代码比较复杂，值得研究学习
class MixinProxy implements InvocationHandler {
    Map<String, Object> delegatesByMethod;

    @SuppressWarnings("unchecked")
    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
        delegatesByMethod = new HashMap<>();
        // 这里意思是变参函数可以直接使用 for-in 语法遍历？
        for (Tuple2<Object, Class<?>> pair : pairs) {
            // 获取 a2 对象的方发表
            for (Method method : pair.a2.getMethods()) {
                String methodName = method.getName();
                // 将a2中的方法存入 HashMap 中
                if (!delegatesByMethod.containsKey(methodName)) {
                    delegatesByMethod.put(methodName, pair.a1);
                }
            }
        }
    }

    // 这个方法没看太懂，是调用代理类的方法吗
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String methodName = method.getName();
        Object delegate = delegatesByMethod.get(methodName);
        return method.invoke(delegate, args);
    }


    @SuppressWarnings("unchecked")
    public static Object newInstance(Tuple2... pairs) {
        Class[] interfaces = new Class[pairs.length];

        for (int i = 0; i < pairs.length; i++) {
            interfaces[i] = (Class) pairs[i].a2;
        }
        // 获取代理接口的类加载器
        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
        // 获取代理类实例对象
        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
    }
}

public class DynamicProxyMixin {
    public static void main(String[] args) {
        Object mixin = MixinProxy.newInstance(
                tuple(new BasicImp(), Basic.class),
                tuple(new TimeStampedImp(), TimeStamped.class),
                tuple(new SerialNumberedImp(), SerialNumbered.class));

        Basic b = (Basic) mixin;
        TimeStamped t = (TimeStamped) mixin;
        SerialNumbered s = (SerialNumbered) mixin;

        b.set("Hello:");

        // 获取 Basic 中持有的 value
        System.out.println(b.get());
        // 获取时间戳
        System.out.println(t.getStamp());
        // 或许序列号 从 1 开始自增
        System.out.println(s.getSerialNumbered());
    }
}

```

> 只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 中的实现方式。因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。
> 但是，使用动态代理明显接近于真正的混型，为了让 Java 支持混型，人们做了大量工作朝着这个目标努力。包括创建了 Jam 语言，专门为了支持混型。

### 潜在类型机制

> 在本章的开头介绍过这样的思想，即要编写能够尽可能**广泛地应用的代码**。为了实现这一点，**我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处**。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“**泛化**”的代码。
>
> Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。**如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。**
>
> 还是正如你所见到的，**当要在泛型类型上执行操作（即调用 Object 方法之外的方法）时，就会产生问题**。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
>
> 某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
>
> 泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
>
> **潜在类型机制是一种代码组织和复用机制。**有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
>
> 支持潜在类型机制的语言包括 Python（可以从 [www.Python.org](http://www.python.org/) 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。

#### python 中的潜在类型

#### C++ 中的潜在类型

#### GO 中的潜在类型

#### java 中的潜在类型



### 对缺乏潜在类型机制的补偿

#### 反射

#### 将一个方法用于序列



### Java 8中的辅助潜在类型

#### 使用 Suppliers 类的通用方法



### 总结：类型转换真的如此之糟吗？


