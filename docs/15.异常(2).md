---
layout: post
title: 《On Java8》第十五章——异常(2)
date: 2020-02-25
tags:
- 读书笔记
categories: 
- 《On Java8》
---



### Java 标准异常

> Throwable 被 Java 用来标识任何可以作为异常被抛出的类。

<!-- more -->	

> Throwable 分为两种类型：
>
> - Error 编译时错误和系统错误（一般不用关心，发生这种错误时系统一般就崩了。）
> - Exception：可以被抛出的基本类型。在 Java类库、用户方法、以及运行时故障都有可能抛出 Exception 类型的异常。



#### 特例：RuntimeException

> 运行时异常，自动被 JVM 抛出。不必显示处理运行时异常，手动进行捕获。
>
> 但是还是可以手动抛出运行时异常。
>
> RuntimeException 代表：
>
> - 无法预料到的错误。比如从你的控制范围之外传递进来的空指针
> - 编程错误，比如数组越界，没有对索引进行限制。
>
> 使用运行时异常很有好处，为调试带来便利。
>
> 如果不捕获运行时异常，那么 RuntimeException 会穿越所有执行路径直达 main() 方法：

```java
// NeverCaught.java

public class NeverCaught {
    static void f() {
        throw new RuntimeException("f() 抛出的 RuntimeException");
    }

    // 调用f并抛出运行时异常
    static void g() {
        f();
    }

    public static void main(String[] args) {
        g();
    }
}
/**
输出
Exception in thread "main" java.lang.RuntimeException: f() 抛出的 RuntimeException
	at com.aibook.onjava.exceptions.NeverCaught.f(NeverCaught.java:12)
	at com.aibook.onjava.exceptions.NeverCaught.g(NeverCaught.java:17)
	at com.aibook.onjava.exceptions.NeverCaught.main(NeverCaught.java:21)
	*/
```

> 可以看到 运行时异常没有被捕获则直接到达 main() 方法 并调用 printStackTrace() 打印调用栈信息。
>
> 并且 运行时异常编译器不要求显示处理。



### 使用 finally 进行清理

> 无论 try 块中异常是否被抛出都被执行的代码块被 finally 包裹。

```java
try {
// The guarded region: Dangerous activities
// that might throw A, B, or C
} catch(A a1) {
// Handler for situation A
} catch(B b1) {
// Handler for situation B
} catch(C c1) {
// Handler for situation C
} finally {
// 无论 try 是否被执行，或者 执行哪个 catch，这里的代码都会被执行
}
```



```java
// FinallyWorks.java
class ThreeException extends Exception {
}


public class FinallyWorks {
    static int count = 0;

    public static void main(String[] args) {
        while (true) {
            try {
            if (count++ == 0) {
                    throw new ThreeException();
                }
                System.out.println("没有发生异常");
            } catch (ThreeException e) {
                System.out.println("ThreeException");
            } finally {
                System.out.println("finnaly 方法块中的代码被执行");
                if (count == 2) {
                    break;
                }
            }
        }
    }
}

/**
输出
ThreeException
finnaly 方法块中的代码被执行
没有发生异常
finnaly 方法块中的代码被执行
*/

```

> 可以看到 finally 子句总被执行。
>
> 当 Java 中的异常允许我们回到异常抛出的地方的时候，可以将 try 放在循环里，就建立了一个 “程序继续执行之前必须达到的条件”
>
> 还可以加入一个 静态类型的计数器获得别的装置，使循环在放弃前能增加一定的重试次数。

【网络请求、读取文件经常会出现错误，这时一般会编写关于重试的代码，就是使用的这个思路】



#### finally 用来做什么

> finally 一般用于资源的清理，比如各种耗费较大的流的关闭。网络连接或文件的关闭。

```java
// exceptions/Switch.java
public class Switch {
    private boolean state = false;
    public boolean read() { return state; }
    public void on() {
        state = true;
        System.out.println(this);
    }
    public void off() {
        state = false;
        System.out.println(this);
    }
    @Override
    public String toString() {
        return state ? "on" : "off";
    }
}
// exceptions/OnOffException1.java
public class OnOffException1 extends Exception {}
// exceptions/OnOffException2.java
public class OnOffException2 extends Exception {}
// exceptions/OnOffSwitch.java
// Why use finally?
public class OnOffSwitch {
    private static Switch sw = new Switch();
    public static void f()
            throws OnOffException1, OnOffException2 {}
    public static void main(String[] args) {
        try {
            sw.on();
            // Code that can throw exceptions...
            f();
            sw.off();
        } catch(OnOffException1 e) {
            System.out.println("OnOffException1");
            sw.off();
        } catch(OnOffException2 e) {
            System.out.println("OnOffException2");
            sw.off();
        }
    }
}
/**
输出
on
off
*/
```

> 这里有4个类，不过代码都很简单。
>
> 主要说明，如果某个状态在 `main()` 方法运行结束后必须是 off 的话，就得在所以可能捕获到异常的地方添加 `sw.off()` 方法，是一种非常冗余的编码方式。
>
> 使用 finally 在一处编码就可以。

```java
// exceptions/WithFinally.java
// Finally Guarantees cleanup
public class WithFinally {
    static Switch sw = new Switch();
    public static void main(String[] args) {
        try {
            sw.on();
            // Code that can throw exceptions...
            OnOffSwitch.f();
        } catch(OnOffException1 e) {
            System.out.println("OnOffException1");
        } catch(OnOffException2 e) {
            System.out.println("OnOffException2");
        } finally {
            sw.off();
        }
    }
}
/**
输出
on
off
*/
```

> 甚至z哎异常没有被当前异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层异常处理程序之前执行 finally 子句：

```java
// AlwaysFinally.java

class FourException extends Exception {

}

public class AlwaysFinally {
    public static void main(String[] args) {
        System.out.println("Entering first try block");
        try {
            System.out.println("进入第二个 try块");
            try {
                throw new FourException();
            } finally {
                System.out.println("第二个 try 块里的 finally");
            }
        } catch (FourException e) {
            System.out.println("捕获异常的第一个 block");
        }finally {
            System.out.println("第一个 try 块的 finally");
        }
    }
}
/**
输出
Entering first try block
进入第二个 try块
第二个 try 块里的 finally
捕获异常的第一个 block
第一个 try 块的 finally
*/
```

> 可以看到 两个 try 块中的 finally 都被执行了。
>
> **当涉及到 break 和 continue 语句的时候， finally 子句也会得到执行。**



#### 在 return 中使用 finally

> 因为 finally 一定会被执行，所以一个方法内可以有多个 return 的地方，扔能保证重要的清理工作会被执行：

```java
// MultiReturns.java
    
public class MultiReturns {
    public static void f(int i) {
        System.out.println("初始化需要被清理的");
        try {
            System.out.println("Point1");
            if (i == 1) {
                return;
            }
            System.out.println("Point2");
            if (i == 2) {
                return;
            }
            System.out.println("Point3");
            if (i == 3) {
                return;
            }
        } finally {
            System.out.println("Finally");
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i <= 4; i++) {
            f(i);

        }
    }
}
/**
输出
初始化需要被清理的
Point1
Point2
Point3
Finally
初始化需要被清理的
Point1
Finally
初始化需要被清理的
Point1
Point2
Finally
初始化需要被清理的
Point1
Point2
Point3
Finally
初始化需要被清理的
Point1
Point2
Point3
Finally
*/
```



> 可以看到 finally 子句永远被执行。



#### 缺憾：异常丢失

> 如果用某些特殊的方式使用 finally 子句，会造成异常被忽略

```java
// 演示异常怎样被丢失的
// VeryImportantException.java
class VeryImportantException extends Exception {
    @Override
    public String toString() {
        return "重要的异常";
    }
}

// 不重要的异常
class HoHumException extends Exception {
    @Override
    public String toString() {
        return "不重要的异常";
    }
}

public class LostMessage {
    void f() throws VeryImportantException {
        throw new VeryImportantException();
    }

    void dispose() throws HoHumException {
        throw new HoHumException();
    }

    public static void main(String[] args) {
        try {
            LostMessage lm = new LostMessage();
            try {
                lm.f();
            } finally {
                lm.dispose();
            }
        } catch (VeryImportantException | HoHumException e) {
            System.out.println(e);
        }
    }
}
/**
输出
不重要的异常
*/
```



可以看到 lm.f() 抛出的 重要的异常不见了，它被 finally 子句里的 不重要的异常被取代。

```java
    public static void main(String[] args) {
        try {
            LostMessage lm = new LostMessage();
            try {
                lm.f();
            } catch (VeryImportantException e) {
                e.printStackTrace();
            } finally {
                try {
                    lm.dispose();
                } catch (HoHumException e) {
                    e.printStackTrace();
                }
            }
        } catch (Exception e) {
            System.out.println();
        }
    }
```

如果每个 catch 都紧跟着 可能抛出异常的 try 的话，异常是能被正常的抛出的。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225214751.png)



> 一种更简单的丢失异常的方式是从 finally 子句中返回：

```java
// ExceptionSilencer.java
public class ExceptionSilencer {
    public static void main(String[] args) {
        try {
            throw new RuntimeException();
        }finally {
            // 在 finally 中使用 return 会导致异常消失
            return;
        }
    }
}
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225215348.png)

运行之后不会打印任何异常。

### 异常限制

> 当覆盖方法的时候，只能抛出在基类方法的异常类型列表中的异常。
>
> 这个限制很有用，因为这意味着当基类使用的代码应用到子类对象时，一样能够工作。

【也就是子类不能抛出超过基类的异常，否则当父类引用指向子类对象 然后调用父类被子类重写的方法时就会抛出父类没有定义过的异常】

> 下面例子演示了在编译时对于异常的限制：

```java
// Overridden methods can throw only the exceptions
// specified in their base-class versions, or exceptions
// derived from the base-class exceptions
// StormyInning.java
class BaseballException extends Exception {
}

class Foul extends BaseballException {

}

class Strike extends BaseballException {

}

abstract class Inning {
    Inning() throws BaseballException {

    }

    public void event() throws BaseballException {
        // 实际不会抛出任何异常
    }

    public abstract void atBat() throws Strike, Foul;

    public void walk() { // 抛出运行时异常

    }
}

class PopFoul extends Foul {
}

class StormException extends Exception {
}

class RainedOut extends StormException {

}

interface Storm {
    void event() throws RainedOut;

    void rainHard() throws RainedOut;
}


public class StormyInning extends Inning implements Storm {
    // OK to add new exceptions for constructors, but you
// must deal with the base constructor exceptions:


    StormyInning() throws BaseballException, RainedOut {
    }

    public StormyInning(String s)
            throws BaseballException {
    }

    // Regular methods must conform to base class:
//- void walk() throws PopFoul {} //Compile error
// Interface CANNOT add exceptions to existing
// methods from the base class:
//- public void event() throws RainedOut {}
// If the method doesn't already exist in the
// base class, the exception is OK:

    @Override
    public void event() {
    }
    // 这样写会导致编译异常，因为父类中只抛出了 BaseballException

    @Override
    public void atBat() throws PopFoul {
        throw new PopFoul();
    }

    @Override
    public void rainHard() throws RainedOut {

    }

    public static void main(String[] args) {
        try {
            StormyInning si = new StormyInning();
            si.atBat();
        } catch (PopFoul e) {
            System.out.println("Pop foul");
        } catch (Foul e) {
            System.out.println("Foul");
        } catch (RainedOut rainedOut) {
            System.out.println("Rain out");
        } catch (BaseballException e) {
            System.out.println("Generic Baseball Exception");
        }

        // Strike not thrown in derived version.
        try {
// What happens if you upcast?
            Inning i = new StormyInning();
            i.atBat();
// You must catch the exceptions from the
// base-class version of the method:
        } catch (Strike e) {
            System.out.println("Strike");
        } catch (Foul e) {
            System.out.println("Foul");
        } catch (RainedOut e) {
            System.out.println("Rained out");
        } catch (BaseballException e) {
            System.out.println("Generic baseball exception");
        }
    }
}

```



### 构造器



### Try-With-Resources 用法

#### 揭示细节

### 异常匹配



### 其他可选方式

#### 历史

#### 观点

#### 把异常传递给控制台

#### 把被检查的异常转换为不检查的异常



### 异常指南



### 本章小结

