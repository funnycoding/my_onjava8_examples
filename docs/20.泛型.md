---
layout: post
title: 《On Java8》第二十章——泛型
date: 2020年02月29日16:09:46
tags:
- 读书笔记
categories: 
- 《On Java8》

---





### 简单泛型

Java 的泛型存在着一些限制，只有知道语言的缺陷才会让你成为高手，因为不必浪费时间在死胡同里。

<!-- more -->	

> 我们编写一个可持有其他对象的类：

```java
// generic/Holder1.java
class Automobile {}

public class Holder1 {
    private Automobile a;
    public Holder1(Automobile a) { this.a = a; }
    Automobile get() { return a; }
}
```

> 这个类的可复用性不高。因为只能持有特定类型的 Automobile 的对象实例。
>
> Java5 之前使用 Object 对象来实现通用性。

```java
// generics/ObjectHolder.java

public class ObjectHolder {
    private Object a;
    public ObjectHolder(Object a) { this.a = a; }
    public void set(Object a) { this.a = a; }
    public Object get() { return a; }

    public static void main(String[] args) {
        ObjectHolder h2 = new ObjectHolder(new Automobile());
        Automobile a = (Automobile)h2.get();
        h2.set("Not an Automobile");
        String s = (String)h2.get();
        h2.set(1); // 自动装箱为 Integer
        Integer x = (Integer)h2.get();
    }
}
```

> ObjectHolder 可以持有任何类型的对象。

#### 一个元祖类库



#### 一个堆栈库

#### RandomList



### 泛型接口

> 泛型也适用于接口。 例如生成器，这是一种专门负责创建对象的类，实际上这是 **工厂方法**
>
> 不过使用生成器创建新对象一般不需要任何参数，而工厂方法一般需要参数。
>
> Supplier 函数式接口就是一个生成器，调用其 get() 获取对象。 get() 是泛型方法，返回值是参数类型 T。

### 泛型方法

> 方法是否为泛型类型与类是否为泛型无关。
>
> 泛型方法独立于类。作为准则，应尽可能使用通用性更强的泛型方法。
>
> **静态方法无法访问该类的泛型类型参数。**
>
> 泛型参数列表定义在方法返回值之前。

```java
// generics/GenericMethods.java
public class GenericMethods {
    public <T> void f(T t) {
        System.out.println(t.getClass().getSimpleName());
    }

    public static void main(String[] args) {
        GenericMethods gc = new GenericMethods();
        gc.f("");
        gc.f(1);
        gc.f(1.0);
        gc.f('c');
        gc.f(gc);
    }
}
/**
输出
String
Integer
Double
Character
GenericMethods
*/
```



> 这里方法是泛型方法，类没有类型参数，是普通类。
>
> 使用泛型类时，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型，称为**类型参数推断。**



 

#### 变长参数和泛型方法

> 泛型方法和变长参数列表可以很好地共存：



```java
// generics/GenericVarargs.java
public class GenericVarags {


    public static <T> List<T> makeList(T... args) {
        ArrayList<T> result = new ArrayList<>();

        for (T item : args) {
            result.add(item);
        }
        return result;
    }

    public static void main(String[] args) {
        List<String> ls = makeList("A");
        System.out.println(ls);
        ls = makeList("A", "B", "C");
        System.out.println(ls);
        ls = makeList(
                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
        System.out.println(ls);

        // 个人添加
        List<Object> mixUp = makeList("A", 1, 1.0, new GenericVarags());
        System.out.println(mixUp);
    }
}

```







#### 一个泛型的 Supplier

#### 简化元祖的使用

#### 一个 Set 工具



### 构建复杂模型



### 泛型擦除

#### C++的方式

#### 迁移兼容性

#### 擦除的问题

#### 边界处的动作



### 补偿擦除

#### 创建类型的实例

#### 泛型数组



### 边界



### 通配符

#### 编译器有多聪明

#### 逆变

#### 无界通配符

#### 捕获转换



### 问题

#### 任何基本类型都不能作为类型参数

#### 实现参数化接口

#### 转型和警告

#### 重载

#### 基类劫持接口



### 自限定的类型

#### 古怪的循环泛型

#### 自限定

#### 参数协变



### 动态类型安全



### 泛型异常



### 混型

#### C++ 中的混型

#### 与接口混合

#### 使用装饰器模式

#### 与动态代理混合



### 潜在类型机制

#### python 中的潜在类型

#### C++ 中的潜在类型

#### GO 中的潜在类型

#### java 中的潜在类型



### 对缺乏潜在类型机制的补偿

#### 反射

#### 将一个方法用于序列



### Java 8中的辅助潜在类型

#### 使用 Suppliers 类的通用方法



### 总结：类型转换真的如此之糟吗？







