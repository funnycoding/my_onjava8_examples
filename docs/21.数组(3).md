---
layout: post
title: 《On Java8》第二十一章——数组(3)
date: 2020-03-10 00:22:03
tags:
- 读书笔记
categories: 
- 《On Java8》


---





### 增量生成

> 这是一个方法库，用于为不同类型生成 **增量值** 【这里这个增量不太明白啥意思】
>
> <!-- more -->	

> 这些被作为**内部类**来生成容易记住的名字；
>
> 比如使用 **Integer** 工具可以用 **new Count.Integer()**，如果你想要使用基本数据类型 int 工具，可以用 **new Count.Pint()** （基本类型的名字不能被直接使用，所以它们都在前面添加一个 P 来表示基本数据类型 `'primitive'`，我们的第一选择是使用基本类型名字后面跟下划线，比如 `Int_` 和 `double_` ，但是这种命名方式违背 Java 习惯。）
>
> 每个包装类的生成器都使用 `get()` 方法实现它们的 `Supplier`。 要使用 `Array.setAll()` ，一个重载的 `get(int n)` 方法要接受并忽略其参数。以便接受 `setAll()` 传递的索引值。
>
> 注意：通过使用包装类的名称作为内部类名，必须调用 `java.lang` 包保证可以使用实际包装类的名字：
>
> 

```java
// Count.java
public interface Count {
    // 接口的内部类
    class Boolean implements Supplier<java.lang.Boolean> {
        private boolean b = true;

        @Override
        public java.lang.Boolean get() {
            b = !b;
            return java.lang.Boolean.valueOf(b);
        }

        // 适配 Supplier 接口
        public java.lang.Boolean get(int n) {
            return get();
        }

        public java.lang.Boolean[] array(int sz) {
            java.lang.Boolean[] result = new java.lang.Boolean[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pboolean {
        private boolean b = true;

        public boolean get() {
            b = !b;
            return b;
        }

        public boolean get(int n) {
            return get();
        }

        public boolean[] array(int sz) {
            return ConvertTo.primitive(new Boolean().array(sz));
        }
    }

    class Byte implements Supplier<java.lang.Byte> {
        private byte b;


        @Override
        public java.lang.Byte get() {
            return b++;
        }

        public java.lang.Byte get(int n) {
            return get();
        }

        public java.lang.Byte[] array(int sz) {
            java.lang.Byte[] result = new java.lang.Byte[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pbyte {
        private byte b;

        public byte get() {
            return b++;
        }

        public byte get(int n) {
            return get();
        }

        public byte[] array(int sz) {
            return ConvertTo.primitive(new Byte().array(sz));
        }

    }


    char[] CHARS = "abcdefghijklmnopqrstuvwxyz".toCharArray();

    class Character implements Supplier<java.lang.Character> {

        private int i;

        @Override
        public java.lang.Character get() {
            i = (i + 1) % CHARS.length;
            return CHARS[i];
        }

        public java.lang.Character get(int n) {
            return get();
        }

        public java.lang.Character[] array(int sz) {
            java.lang.Character[] result = new java.lang.Character[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pchar {
        private int i;

        public char get() {
            i = (i + 1) % CHARS.length;
            return CHARS[i];
        }

        public char[] array(int sz) {
            return ConvertTo.primitive(new Character().array(sz));
        }
    }

    class Short
            implements Supplier<java.lang.Short> {
        short s;

        @Override
        public java.lang.Short get() {
            return s++;
        }

        public java.lang.Short get(int n) {
            return get();
        }

        public java.lang.Short[] array(int sz) {
            java.lang.Short[] result =
                    new java.lang.Short[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pshort {
        short s;

        public short get() {
            return s++;
        }

        public short get(int n) {
            return get();
        }

        public short[] array(int sz) {
            return primitive(new Short().array(sz));
        }
    }

    class Integer
            implements Supplier<java.lang.Integer> {
        int i;

        @Override
        public java.lang.Integer get() {
            return i++;
        }

        public java.lang.Integer get(int n) {
            return get();
        }

        public java.lang.Integer[] array(int sz) {
            java.lang.Integer[] result =
                    new java.lang.Integer[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pint implements IntSupplier {
        int i;

        public int get() {
            return i++;
        }

        public int get(int n) {
            return get();
        }

        @Override
        public int getAsInt() {
            return get();
        }

        public int[] array(int sz) {
            return primitive(new Integer().array(sz));
        }
    }

    class Long
            implements Supplier<java.lang.Long> {
        private long l;

        @Override
        public java.lang.Long get() {
            return l++;
        }

        public java.lang.Long get(int n) {
            return get();
        }

        public java.lang.Long[] array(int sz) {
            java.lang.Long[] result =
                    new java.lang.Long[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Plong implements LongSupplier {
        private long l;

        public long get() {
            return l++;
        }

        public long get(int n) {
            return get();
        }

        @Override
        public long getAsLong() {
            return get();
        }

        public long[] array(int sz) {
            return primitive(new Long().array(sz));
        }
    }

    class Float
            implements Supplier<java.lang.Float> {
        private int i;

        @Override
        public java.lang.Float get() {
            return java.lang.Float.valueOf(i++);
        }

        public java.lang.Float get(int n) {
            return get();
        }

        public java.lang.Float[] array(int sz) {
            java.lang.Float[] result =
                    new java.lang.Float[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pfloat {
        private int i;

        public float get() {
            return i++;
        }

        public float get(int n) {
            return get();
        }

        public float[] array(int sz) {
            return primitive(new Float().array(sz));
        }
    }

    class Double
            implements Supplier<java.lang.Double> {
        private int i;

        @Override
        public java.lang.Double get() {
            return java.lang.Double.valueOf(i++);
        }

        public java.lang.Double get(int n) {
            return get();
        }

        public java.lang.Double[] array(int sz) {
            java.lang.Double[] result =
                    new java.lang.Double[sz];
            Arrays.setAll(result, n -> get());
            return result;
        }
    }

    class Pdouble implements DoubleSupplier {
        private int i;

        public double get() {
            return i++;
        }

        public double get(int n) {
            return get();
        }

        @Override
        public double getAsDouble() {
            return get(0);
        }

        public double[] array(int sz) {
            return primitive(new Double().array(sz));
        }
    }
}

```

【很长，但是其实搞明白一组就够了。】

> 对于 `int`, `long` , `double` 这三个有特殊 `Supplier` 接口的原始数据类型来说, `Pint`,`Plong` 和 `Pdouble` 实现了 这些接口。
>
> 这里是对 Count 的测试：

```

```



### 随机生成



### 泛型和基本数组

> 在本章的前面，可以看到 泛型不能和基本类型一起工作。在这种情况下，必须将基本类型转为包装类型的数组，并且还必须从另一个方向转换。
>
> 下面是一个可以对所有类型的数据执行操作的转换器：

```java
// onjava/ConvertTo
public interface ConvertTo {
    // 将包装类转为基本类型数组
    static boolean[] primitive(Boolean[] in) {
        boolean[] result = new boolean[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static char[] primitive(java.lang.Character[] in) {
        char[] result = new char[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }


    static byte[] primitive(Byte[] in) {
        byte[] result = new byte[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static short[] primitive(Short[] in) {
        short[] result = new short[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static int[] primitive(Integer[] in) {
        int[] result = new int[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static long[] primitive(Long[] in) {
        long[] result = new long[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static float[] primitive(Float[] in) {
        float[] result = new float[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static double[] primitive(Double[] in) {
        double[] result = new double[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    // Convert from primitive array to wrapped array: 将基本类型转为包装器类型
    static Boolean[] boxed(boolean[] in) {
        Boolean[] result = new Boolean[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i]; // Autoboxing
        }
        return result;
    }

    static Character[] boxed(char[] in) {
        Character[] result = new Character[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Byte[] boxed(byte[] in) {
        Byte[] result = new Byte[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Short[] boxed(short[] in) {
        Short[] result = new Short[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Integer[] boxed(int[] in) {
        Integer[] result = new Integer[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Long[] boxed(long[] in) {
        Long[] result = new Long[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Float[] boxed(float[] in) {
        Float[] result = new Float[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }

    static Double[] boxed(double[] in) {
        Double[] result = new Double[in.length];
        for (int i = 0; i < in.length; i++) {
            result[i] = in[i];
        }
        return result;
    }
}

```

> `primitive()` 将 数组从对应的包装类 转为基本类型，如果任何包装的数组元素是 null，将得到一个异常（这是合理的，否则无法选择有意义的值进行替换）。注意在这个任务中自动装箱如何发生。
>
> 
>
> `boxed()` 将数组从基本类型转为包装器类型

> 下面是 ConvertTo 的测试：

```java
// arrays/TestConvertTo.java
public class TestConvertTo {
    static final int SIZE = 6;

    public static void main(String[] args) {
        Boolean[] a1 = new Boolean[SIZE];
        Arrays.setAll(a1, new Rand.Boolean()::get);
        show(a1);
        // 将包装类数组转为基本类型
        boolean[] a1p = primitive(a1);
        show(a1p);
        // 将基本类型数组再转回包装类
        Boolean[] a1b = boxed(a1p);
        show(a1b);

        // 其余的和 Boolean 都一样，先创建一个数组，然后随机填充，然后使用 primitive 转为基本类型，再用 boxed 转回包装类型
        Byte[] a2 = new Byte[SIZE];
        Arrays.setAll(a2, new Rand.Byte()::get);
        byte[] a2p = primitive(a2);
        show("a2p", a2p);
        Byte[] a2b = boxed(a2p);
        show("a2b", a2b);

        Character[] a3 = new Character[SIZE];
        Arrays.setAll(a3, new Rand.Character()::get);
        char[] a3p = primitive(a3);
        show("a3p", a3p);
        Character[] a3b = boxed(a3p);
        show("a3b", a3b);

        Short[] a4 = new Short[SIZE];
        Arrays.setAll(a4, new Rand.Short()::get);
        short[] a4p = primitive(a4);
        show("a4p", a4p);
        Short[] a4b = boxed(a4p);
        show("a4b", a4b);

        Integer[] a5 = new Integer[SIZE];
        Arrays.setAll(a5, new Rand.Integer()::get);
        int[] a5p = primitive(a5);
        show("a5p", a5p);
        Integer[] a5b = boxed(a5p);
        show("a5b", a5b);

        Long[] a6 = new Long[SIZE];
        Arrays.setAll(a6, new Rand.Long()::get);
        long[] a6p = primitive(a6);
        show("a6p", a6p);
        Long[] a6b = boxed(a6p);
        show("a6b", a6b);

        Float[] a7 = new Float[SIZE];
        Arrays.setAll(a7, new Rand.Float()::get);
        float[] a7p = primitive(a7);
        show("a7p", a7p);
        Float[] a7b = boxed(a7p);
        show("a7b", a7b);

        Double[] a8 = new Double[SIZE];
        Arrays.setAll(a8, new Rand.Double()::get);
        double[] a8p = primitive(a8);
        show("a8p", a8p);
        Double[] a8b = boxed(a8p);
        show("a8b", a8b);
    }
}
/**
输出
[true, false, true, true, true, false]
[true, false, true, true, true, false]
[true, false, true, true, true, false]
a2p: [123, 33, 101, 112, 33, 31]
a2b: [123, 33, 101, 112, 33, 31]
a3p: [b, t, p, e, n, p]
a3b: [b, t, p, e, n, p]
a4p: [635, 8737, 3941, 4720, 6177, 8479]
a4b: [635, 8737, 3941, 4720, 6177, 8479]
a5p: [635, 8737, 3941, 4720, 6177, 8479]
a5b: [635, 8737, 3941, 4720, 6177, 8479]
a6p: [6882, 3765, 692, 9575, 4439, 2638]
a6b: [6882, 3765, 692, 9575, 4439, 2638]
a7p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]
a7b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]
a8p: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]
a8b: [4.83, 2.89, 2.9, 1.97, 3.01, 0.18]
*/
```

> 这里的例子，先创建一个包装器类型的原始数组，然后使用 Arrays.setAll() 填充，然后使用 primitive 转为基本数组，再使用 boxed 转回来。

【还是 API 层面的知识，对底层没有啥突破，过一遍就行了。】

### 数组元素修改

> 传递给 Arrays.setAll() 的生成器函数可以使用它接收到的数组索引修改现有的数组元素：

```java
// arrays/ModifyExisting.java
public class ModifyExisting {
    public static void main(String[] args) {
        double[] da = new double[7];
        Arrays.setAll(da,new Rand.Double()::get);
        show(da);
        // 遍历数组并将每个元素都缩小100倍
        Arrays.setAll(da, n -> da[n] / 100); // [1]
        show(da);
    }
}
/**
输出
[4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99]
[0.0483, 0.028900000000000002, 0.028999999999999998, 0.0197, 0.0301, 0.0018, 0.009899999999999999]
*/
```

> [1] Lambdas 在这里特别有用，因为数组总是在 Lambda 表达式范围内

**【这里这个数组在 Lambda 范围内 这句话怎么理解？】**



### 数组并行

> 很快就不得不面对并行的主题(**paralleilism**)，**"并行"**在许多 Java 库方法中使用。并行可以利用 CPU 的多个核心 。"并行程序运行的更快" 这件事是可能的，**但是不幸的是，通过采用这种方法，可以很容易地编写比非并行更 慢 的代码。**

**【作者的黑色幽默】**

> 在深刻理解所有问题之前，并行看起来更像是**艺术**而非科学。

**【是指编写并行代码难度大，还是并行本身就不准确？】**



**【作者的观点：】**

> 用简单的方法编写代码，**不要开始处理并行性**，除非它真的称为一个问题。
>
> 你仍然会遭遇并行的问题，在本章中介绍一些为并行执行而编写的 JDK 方法。因此你必须对它有足够的了解，以便进行基本的讨论，并避免出现错误。

**【作者认为，能不用并行就不用，但是你需要对其有基本的了解，因为很多新的库是提供并行选项的，当你的场景有且只能用并行时，你不得不使用它。】**

> 在阅读并发编程之后，将更深入地了解它。但是这远远不够，重新理解并发与并行是不可能的。
>
> **在某些情况下，即时你只有一个处理器，无论是否显式地尝试并行，并行实现是唯一的，最佳的或最符合逻辑的选择。**
>
> 它是一个可以一直使用的工具，所以你必须了解它的相关问题。

**【并发与并行是非常难掌握的主题，但是它可以是被使用的工具（使用大牛为你编写好的库），所以你必须了解它。】**

> 最好从数据的角度来考虑并行性。对于大量数据以及可用的额外处理器，并行可能会有所帮助。但是也可能使事情变得更糟：
>
> 在本书的其余部分，将遇到不同的情况：
>
> - 1、所提供的唯一选项是并行的。这种情况下我们别无选择，但是这种情况很罕见。
> - 2、有多个选项，但是并行版本（通常是最新版本）被设计成在任何地方都可以使用（甚至在那些不关心并行的代码中）如案例 #1 我们将按预期使用并行版本
> - 3、案例1和案例2并不经常发生。（也就是说，必须使用并行的场景并不多）。相反，你将遇到某些算法的两个版本，一个用于并行使用，另一个正常使用。作者将描述并行的那个，但不会在普通代码中使用它，因为并行也许会产生所有可能的问题。**【我们建议你在自己的代码中采用这种方法】**

**【三种情况：只能用并行的，优选用并行的，能用并行而不建议用的。第三章情况最多】**

[要进一步了解为什么这是一个难题，请参阅Doug Lea的文章](http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html)

> **parallelSetAll()**
>
> 流式编程产生优雅的代码。假设要创建一个数值从零开始填充的长数组：

```java
// CountUpward.java
public class CountUpward {
    static long[] fillCounted(int size) {
        // seed : 从几开始
        return LongStream.iterate(0, i -> i + 1).limit(size).toArray();
    }

    public static void main(String[] args) {
        long[] longs = fillCounted(20);
        System.out.println(Arrays.toString(longs));

    }
}
/**
输出
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
*/
```

> 流 实际可以存储到将近 1000万 ，但是之后就会耗尽堆空间。

【之前说过，**流没有存储**，流处理的数据都在其本身存放的位置，对象的话都是在堆空间，但是之前也提到过，流因为其懒加载和延迟计算的特性，可以表示几乎无限大的数据，这里又说1000万。所以是否可以理解为 **流的上限就是堆空间可存储对象的上限**？】

> 常规的 setAll() 是有效的，但是如果我们能更快地处理如此大量的数字，就更好了。可以使用 setAll 初始化更大的数组。
>
> **如果速度成为问题，Arrays.parallelSetAll() 将（可能） 更快地执行初始化。【记住这个可能】**

【也就是并行代表着不确定性】

```java
// ParallelSetAll.java
public class ParallelSetAll {
    static final int SIZE = 10_000_0000;

    static void intArray() {
        int[] ia = new int[SIZE];
        Arrays.setAll(ia, new Rand.Pint()::get);
        Arrays.parallelSetAll(ia, new Rand.Pint()::get);
    }

    static void longArray() {
        long[] la = new long[SIZE];
        Arrays.setAll(la, new Rand.Plong()::get);
        Arrays.parallelSetAll(la, new Rand.Plong()::get);

    }

    public static void main(String[] args) {
        intArray();
        longArray();
    }
}

```

**【这里我的电脑可以创建 1亿个对象，2G的heap】**

### Arrays工具类

> 之前已经使用了 `java.util.Arrays` 中的 `fill()` ， `setAll()`/`parallelSetAll()`。
>
> 该类还包含许多其他有用的 **静态** 程序方法：
>
> **概述：**
>
> - **asList()** 将数组转为列表
> - **copyOf()**: 以新的长度创建现有数组的副本
> - **copyOfRange()**: 创建现有数组的一部分的新副本（子数组
> - **equals()** : 比较两个数组是否相等。
> - **deepEquals()**：多维数组的相等性比较
> - **stream()**：生成数组元素的流
> - **hashCode()**:生成数组的哈希值（将在附录中的理解 **equasl()** 和 **hashCode()** 明白这意味着什么）
> - **deppHashCode()**：生成多维数组的哈希值
> - **sort()**：数组排序
> - **parallelSort()**：数组并行排序，提高速度。
> - **binarySearch()**: 在已排序的数组中查找元素 （我记得是二分查找）
> - **parallelPrefix()**：使用提供函数的并行累计（以获得速度）基本上就是数组的 **reduce()**
> - **spliterator()**: 从数组中产生一个 Spliterator；这是本书涉及到流的高级部分中讲的
> - **toString()**:将数组转为字符串
> - **deepToString()**:将多维数组转为字符串

### 