---
layout: post
title: 《On Java8》第十五章——异常(2)
date: 2020-02-25
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### Java 标准异常

> Throwable 被 Java 用来标识任何可以作为异常被抛出的类。

<!-- more -->	

> Throwable 分为两种类型：
>
> - **Error** 编译时错误和系统错误（一般不用关心，发生这种错误时系统一般就崩了。）
> - **Exception**：可以被抛出的基本类型。在 Java类库、用户方法、以及运行时故障都有可能抛出 Exception 类型的异常吗，这种类型的异常也是程序员所关注的。
>
> 如果你浏览过异常的源码，你会发现这些异常除了名称外都差不多，对异常来说，关键是**理解概念以及如何使用**。
>
> **Java 异常的基本概念是用名称代表发生的问题，并且异常的名称应该可以望文知意。**





#### 特例：RuntimeException

> **运行时异常，自动被 JVM 抛出。**不必显示处理运行时异常，这些异常都是从 **RuntimeException** 继承而来。
>
> 这种y长属于错误，将被自动捕获，所以不需要程序员进行显示的处理。
>
> 虽然运行时异常会被自动捕获，但是还是可以手动抛出运行时异常。
>
> RuntimeException 代表：
>
> - **无法预料到的错误。比如从你的控制范围之外传递进来的空指针**
> - **编程错误，比如数组越界，没有对索引进行限制。**
>
> 使用运行时异常很有好处，为调试带来便利。
>
> 如果不捕获运行时异常，那么 RuntimeException 会穿越所有执行路径直达 main() 方法：

```java
// NeverCaught.java

public class NeverCaught {
    static void f() {
        throw new RuntimeException("f() 抛出的 RuntimeException");
    }

    // 调用f并抛出运行时异常
    static void g() {
        f();
    }

    public static void main(String[] args) {
        g();
    }
}
/**
输出
Exception in thread "main" java.lang.RuntimeException: f() 抛出的 RuntimeException
	at com.aibook.onjava.exceptions.NeverCaught.f(NeverCaught.java:12)
	at com.aibook.onjava.exceptions.NeverCaught.g(NeverCaught.java:17)
	at com.aibook.onjava.exceptions.NeverCaught.main(NeverCaught.java:21)
	*/
```

> 可以看到 运行时异常没有被捕获则直接到达 main() 方法 并在程序退出前调用了 `printStackTrace()` 方法。
>
> 运行时异常编译器不需要异常说明，其输出报告给了 `System.err`。
>
> 请务必记住：只能在代码中忽略 RuntimeException 类型的异常，因为所有受检查类型异常的处理都是由编译器强制实施的。【也就是说没有必要手动处理运行时异常】
>
> 不应该吧 Java 异常处理机制当成用途单一的工具。它被设计用来处理一些烦人的运行时错误，这些错误往往由代码控制能力之外的因素导致**。然而它对于发现某些编译器无法检测的编程错误也是非常重要的。**



### 使用 finally 进行清理

> 无论 try 块中异常是否被抛出都被执行的代码块被 finally 包裹。

```java
try {
// The guarded region: Dangerous activities
// that might throw A, B, or C
} catch(A a1) {
// Handler for situation A
} catch(B b1) {
// Handler for situation B
} catch(C c1) {
// Handler for situation C
} finally {
// 无论 try 是否被执行，或者 执行哪个 catch，这里的代码都会被执行
}
```



```java
// FinallyWorks.java
class ThreeException extends Exception {
}


public class FinallyWorks {
    static int count = 0;

    public static void main(String[] args) {
        while (true) {
            try {
            if (count++ == 0) {
                    throw new ThreeException();
                }
                System.out.println("没有发生异常");
            } catch (ThreeException e) {
                System.out.println("ThreeException");
            } finally {
                System.out.println("finnaly 方法块中的代码被执行");
                if (count == 2) {
                    break;
                }
            }
        }
    }
}

/**
输出
ThreeException
finnaly 方法块中的代码被执行
没有发生异常
finnaly 方法块中的代码被执行
*/

```

> 可以看到 finally 子句总被执行。
>
> 当 Java 中的异常允许我们回到异常抛出的地方的时候，可以将 try 放在循环里，就建立了一个 “程序继续执行之前必须达到的条件”
>
> 还可以加入一个 静态类型的计数器获得别的装置，使循环在放弃前能增加一定的重试次数。

**【网络请求、读取文件经常会出现错误，这时一般会编写关于重试的代码，就是使用的这个思路】**



#### finally 用来做什么

> **finally 一般用于资源的清理：比如各种耗费较大的流的关闭。网络连接或文件的关闭。**

```java
// exceptions/Switch.java
public class Switch {
    private boolean state = false;
    public boolean read() { return state; }
    public void on() {
        state = true;
        System.out.println(this);
    }
    public void off() {
        state = false;
        System.out.println(this);
    }
    @Override
    public String toString() {
        return state ? "on" : "off";
    }
}
// exceptions/OnOffException1.java
public class OnOffException1 extends Exception {}
// exceptions/OnOffException2.java
public class OnOffException2 extends Exception {}
// exceptions/OnOffSwitch.java
// Why use finally?
public class OnOffSwitch {
    private static Switch sw = new Switch();
    public static void f()
            throws OnOffException1, OnOffException2 {}
    public static void main(String[] args) {
        try {
            sw.on();
            // Code that can throw exceptions...
            f();
            sw.off();
        } catch(OnOffException1 e) {
            System.out.println("OnOffException1");
            sw.off();
        } catch(OnOffException2 e) {
            System.out.println("OnOffException2");
            sw.off();
        }
    }
}
/**
输出
on
off
*/
```

> 这里有4个类，不过代码都很简单。
>
> 主要是对不用finally 的话需要保证资源的关闭的代码的说明：
>
> 如果某个状态在 `main()` 方法运行结束后必须是 off 的话，就得在所以可能捕获到异常的地方添加 `sw.off()` 方法，是一种非常冗余的编码方式。
>
> 使用 finally 在一处编码就可以。

```java
// exceptions/WithFinally.java
// Finally Guarantees cleanup
public class WithFinally {
    static Switch sw = new Switch();
    public static void main(String[] args) {
        try {
            sw.on();
            // Code that can throw exceptions...
            OnOffSwitch.f();
        } catch(OnOffException1 e) {
            System.out.println("OnOffException1");
        } catch(OnOffException2 e) {
            System.out.println("OnOffException2");
        } finally {
            sw.off();
        }
    }
}
/**
输出
on
off
*/
```

> 甚至z哎异常没有被当前异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层异常处理程序之前执行 finally 子句：

```java
// AlwaysFinally.java

class FourException extends Exception {

}

public class AlwaysFinally {
    public static void main(String[] args) {
        System.out.println("Entering first try block");
        try {
            System.out.println("进入第二个 try块");
            try {
                throw new FourException();
            } finally {
                System.out.println("第二个 try 块里的 finally");
            }
        } catch (FourException e) {
            System.out.println("捕获异常的第一个 block");
        }finally {
            System.out.println("第一个 try 块的 finally");
        }
    }
}
/**
输出
Entering first try block
进入第二个 try块
第二个 try 块里的 finally
捕获异常的第一个 block
第一个 try 块的 finally
*/
```

> 可以看到 两个 try 块中的 finally 都被执行了。
>
> **当涉及到 break 和 continue 语句的时候， finally 子句也会得到执行。**



#### 在 return 中使用 finally

> 因为 finally 一定会被执行，所以一个方法内可以有多个 return 的地方，扔能保证重要的清理工作会被执行：

```java
// MultiReturns.java
    
public class MultiReturns {
    public static void f(int i) {
        System.out.println("初始化需要被清理的");
        try {
            System.out.println("Point1");
            if (i == 1) {
                return;
            }
            System.out.println("Point2");
            if (i == 2) {
                return;
            }
            System.out.println("Point3");
            if (i == 3) {
                return;
            }
        } finally {
            System.out.println("Finally");
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i <= 4; i++) {
            f(i);

        }
    }
}
/**
输出
初始化需要被清理的
Point1
Point2
Point3
Finally
初始化需要被清理的
Point1
Finally
初始化需要被清理的
Point1
Point2
Finally
初始化需要被清理的
Point1
Point2
Point3
Finally
初始化需要被清理的
Point1
Point2
Point3
Finally
*/
```



> **可以看到 finally 子句永远被执行。**



#### 缺憾：异常丢失

> **如果用某些特殊的方式使用 finally 子句，会造成异常被忽略** :
>
> 比如 try 块中抛出了异常，finally 中抛出了另外一种异常， 这两种异常被同一个 catch 捕获，则 try 中的异常会丢失。

```java
// 演示异常怎样被丢失的
// VeryImportantException.java
class VeryImportantException extends Exception {
    @Override
    public String toString() {
        return "重要的异常";
    }
}

// 不重要的异常
class HoHumException extends Exception {
    @Override
    public String toString() {
        return "不重要的异常";
    }
}

public class LostMessage {
    void f() throws VeryImportantException {
        throw new VeryImportantException();
    }

    void dispose() throws HoHumException {
        throw new HoHumException();
    }

    public static void main(String[] args) {
        try {
            LostMessage lm = new LostMessage();
            try {
                lm.f();
            } finally {
                lm.dispose();
            }
        } catch (VeryImportantException | HoHumException e) {
            System.out.println(e);
        }
    }
}
/**
输出
不重要的异常
*/
```



> **可以看到 lm.f() 抛出的 重要的异常不见了，它被 finally 子句里的 不重要的异常被取代。**

```java
    public static void main(String[] args) {
        try {
            LostMessage lm = new LostMessage();
            try {
                lm.f();
            } catch (VeryImportantException e) {
                e.printStackTrace();
            } finally {
                try {
                    lm.dispose();
                } catch (HoHumException e) {
                    e.printStackTrace();
                }
            }
        } catch (Exception e) {
            System.out.println();
        }
    }
```

如果每个 catch 都紧跟着 可能抛出异常的 try 的话，异常是能被正常的抛出的。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225214751.png)



> **一种更简单的丢失异常的方式是从 finally 子句中返回：**

```java
// ExceptionSilencer.java
public class ExceptionSilencer {
    public static void main(String[] args) {
        try {
            throw new RuntimeException();
        }finally {
            // 在 finally 中使用 return 会导致异常消失
            return;
        }
    }
}
```

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200225215348.png)

运行之后不会打印任何异常。

### 异常限制

> **当覆盖方法的时候，只能抛出在基类方法的异常类型列表中的异常。**
>
> 这个限制很有用，因为这意味着当基类使用的代码应用到子类对象时，一样能够工作。

【也就是子类不能抛出超过基类的异常，否则当父类引用指向子类对象 然后调用父类被子类重写的方法时就会抛出父类没有定义过的异常】

> 下面例子演示了在编译时对于异常的限制：

```java
// 覆盖基类方法只能抛出基类中定义的异常，或从基类中派生的异常
// StormyInning.java
class BaseballException extends Exception {
}

class Foul extends BaseballException {

}

class Strike extends BaseballException {

}

abstract class Inning {
    Inning() throws BaseballException {

    }

    public void event() throws BaseballException {
        // 声明了该方法可能抛出异常 实际不会抛出任何异常
    }

    public abstract void atBat() throws Strike, Foul;

    public void walk() { // 抛出运行时异常

    }
}

class PopFoul extends Foul {
}

class StormException extends Exception {
}

class RainedOut extends StormException {

}

interface Storm {
    void event() throws RainedOut;

    void rainHard() throws RainedOut;
}


public class StormyInning extends Inning implements Storm {
  
		// 你可以在构造函数中添加新的抛出异常类型，但是必须处理付六构造函数中的异常 父类构造函数抛出了 BaseballException，子类也必须抛出，这里另外添加了 RainedOut 异常
    StormyInning() throws BaseballException, RainedOut {
    }

    public StormyInning(String s)
            throws BaseballException {
    }

    // Regular methods must conform to base class:
//- void walk() throws PopFoul {} //Compile error
// Interface CANNOT add exceptions to existing
// methods from the base class:
//- public void event() throws RainedOut {}
// If the method doesn't already exist in the
// base class, the exception is OK:

    @Override
    public void event() {
    }
    // 这样写会导致编译异常，因为父类中只抛出了 BaseballException

    @Override
    public void atBat() throws PopFoul {
        throw new PopFoul();
    }

    @Override
    public void rainHard() throws RainedOut {

    }

    public static void main(String[] args) {
        try {
            StormyInning si = new StormyInning();
            si.atBat();
        } catch (PopFoul e) {
            System.out.println("Pop foul");
        } catch (Foul e) {
            System.out.println("Foul");
        } catch (RainedOut rainedOut) {
            System.out.println("Rain out");
        } catch (BaseballException e) {
            System.out.println("Generic Baseball Exception");
        }
        try {
						// 当多态发生时，需要补货具体对象构造时可能抛出的异常
            Inning i = new StormyInning();
            i.atBat();
        } catch (Strike e) {
            System.out.println("Strike");
        } catch (Foul e) {
            System.out.println("Foul");
        } catch (RainedOut e) {
            System.out.println("Rained out");
        } catch (BaseballException e) {
            System.out.println("Generic baseball exception");
        }
    }
}

```

> 在 Inning 类中，构造器和 event() 方法都将抛出异常，但是实际上没有抛出。**这种方式能强制使用者捕获可能在覆盖后的 event() 版本中增加的异常**，很合理。**这种情况对抽象方法同样成立，比如 atBat()。**
>
> 接口 Storm 包含了一个在 Inning 中定义的方法 event() 和一个不在 Inning 中定义的方法 rainHard()。 这两个方法都抛出新的异常 RainedOut。 
>
> 如果 StormyInning 类在扩展 Inning 类的同时又实现 Storm 接口，那么 Strom 里的 event() 方法就不能改变在 Inning 中的 event（方法的异常接口） **否则的话，在使用基类的时候就不能判断是否捕获了正确的异常**。所以这也很合理。
>
> 异常限制对构造器不起作用。你会发现 StormyInning 的构造器可以抛出任何异常，而不必理会基类构造器所抛出的异常。
>
> **然而，因为基类构造器必须以这样或那样的方式调用（这里默认构造器将被自动调用），派生类构造器的异常说明必须包含基类构造器的异常说明。**
>
> **子类构造器不能捕获基类构造器抛出的异常。**

```java
//public void walk() throws PopFoul {} // 这里覆写基类的 walk() 方法，但是基类没有抛出异常，则子类不能抛出异常，否则编译器会父类并没有抛出该异常
```

> StormyInning.walk() 不能通过编译是因为它抛出了异常，而父类 Inning.walk() 并没有声明异常。
>
> 如果编译器允许这么做的话，就可以在调用 Inning.walk() 的时候不用做异常处理了，而且当把它替换为 Inning 的炮声类对象时，这个方法就有可能抛出异常，于是程序就失灵了。
>
> 通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证。

```java
@Override
public void event() {
}

```

> 覆盖后的 `event()` 方法表明，子类可以不抛出任何异常，即使基类方法抛出了异常。
>
> 同样这是因为，假如基类方法会抛出异常，这样做不会破坏已有的程序，所以不会出问题。



```java
 @Override
    public void atBat() throws PopFoul {
        throw new PopFoul();
    }
```

> 类似的情况出现在 `atBat()` 身上，它抛出的异常是父类方法 抛出异常的子类，如果你写代码是同父类 Inning 打交道，并且调用了它的 `atBat()` 的话，那么肯定能捕获 Foul，而 PopFoul 是由 Foul 派生出来的，因此异常处理程序也能正常捕获父类异常的子类异常类型。



> 最后一个值得注意的地方睡是 main() ，可以看到，如果处理的刚好是子类对象 StormyInning 的话，编译器只会要求你捕获这个类所抛出的对象，如果将它向上转型那么编译器就会正确地要求你捕获基类的异常。
>
> **所有这些限制都是为了能产生更为强壮的异常处理代码。**

> **异常不是方法类型的一部分，不能基于异常类型说明来重载方法。**
>
> **出现在基类方法中的异常不一定会出现在子类方法中，这点与继承的规则明显不同，继承要求基类的方法必须出现在子类中。**
>
> 换句话说，在继承和覆盖的过程中，某个方法的异常说明的接口不是变大了而是变小了，这与类和接口在继承时相反。

### 构造器

> 如果异常发生，所有东西都能被正确地清理吗？
> 尽管大多数情况下是非常安全的，但是涉及到构造器时问题就出现了。
> 构造器会把对象初始化为安全的初始状态，但是还会有别的东西：比如打开一个文件，**这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能清理，如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。**
> 这意味着在编写构造器时要格外细心。
>
> 使用 finally 也未必能解决这个问题，因为 finally 会每次都执行清理代码，如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在 finally 子句中却是需要备清理的对象。
>
> 

**【也就是清理没有构造完成的对象，会导致异常吗？】**



```java
// InputFile.java
public class InputFile {
    private BufferedReader in;

    public InputFile(String fileName) throws Exception {
        try {
            in = new BufferedReader(new FileReader(fileName));
            // 其他代码可能导致了抛出异常
        } catch (FileNotFoundException e) {
            System.out.println("打开文件失败: " + fileName);
            // 没有打开指定文件，所以没有关闭它
            throw e;
        } catch (Exception e) {
            // 所以其他异常必须在这里被关闭
            try {
                in.close();

            } catch (IOException e2) {
                System.out.println("BufferReader 输入流关闭失败");
            }
            throw e; // 重新抛出打开失败异常
        }finally {
            // 不要在这里关闭
        }
    }

    public String getLine() {
        String s;
        try {
            s = in.readLine();
        } catch (IOException e) {
            throw new RuntimeException("readLine() field");
        }
        return s;
    }

    public void dispose() {
        try {
            in.close();
            System.out.println("dispose() successful");
        } catch (IOException e) {
            throw new RuntimeException("in.close failed");
        }
    }
}
```

> Input 的构造器接受字符串作为出参数，该字符串表示要打开的文件名，在 try 块中会使用此文件名建立 FileReader 对象。
>
> FileReader 对象本身用处不大，但是可以用它来建立 BUfferedReader 对象。
>
> 使用 InputFile 的好处是把两步操作 合二为一。

> 如果 FileReader 的构造器失败了，将抛出 FileNotFoundException 异常。对于这个异常，**并不需要关闭文件，因为这个文件还没有被打开。**
>
> **而任何其他捕获异常的 catch 子句必须关闭文件，因为在它们捕获到异常之时，文件已经打开了**（当然，如果还有其他方法能抛出 FileNotFoundException，这个方法就显得有些投机取巧了。这时，通常必须把这些方法分别放到各自的 try 块里），close() 方法也可能会抛出异常，所以尽管它已经在另一个 catch 子句块里了，还是要再用一层 try-catch，这对 Java 编译器而言只不过是多了一对花括号。在本地做完处理之后，异常被重新抛出，对于构造器而言这么做是很合适的，因为你总不希望去误导调用方，让他认为“这个对象已经创建完毕，可以使用了”。

> 在本例中，由于finanly 会在每次完成构造器之后都执行一遍，所以不该在 finally 调用关闭文件，否则该构造方法没有意义。

> getLine() 方法会返回表示文件下一行内容的字符串。它可能调用了能抛出异常的 readLine() 但是这个异常已经在方法内部得到处理，所以 getLine() 不会抛出任何异常。
>
> 在设计异常时有一个问题：应该把异常全部放在这一层处理；还是先处理一部分然后再向上层抛出相同的（或新的异常）；或者不做任何处理直接向上抛出。
>
> **如果用法恰当，直接向上抛出异常的确能简化编程。**
>
> 用户在不需要 InputFile 对象时，就必须调用 dispose() 方法，这将释放 Buffer额度Reader 和 FileReader 对象占用的系统资源（比如文件句柄）

> 对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的 try 子句：

```java
// exceptions/Cleanup.java
public class Cleanup {
    public static void main(String[] args) {
        try {
            InputFile in = new InputFile("Cleanup.java");
            try {
                String s;
                int i = 1;
                while ((s = in.getLine()) != null) {
                    //在这里进行逐行处理
                }

            } catch (Exception e) {
                System.out.println("Caught Exception in main");
                e.printStackTrace(System.out);
            } finally {
                in.dispose();
            }
        } catch (Exception e) {
            System.out.println("Inputfile 构造失败");
        }
    }
}
/**
输出
dispose() successful
*/
```



> 请仔细观察这里的逻辑：
>
> 对 Input 对象的构造在自己的 try 语句块中有效，如果构造失败，将进入外部的 catch 子句，**而 dispose() 方法不会被调用。**

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200227145319.png)

> 但是如果构造成功，我们肯定想确保对象能够被清理，因此在构造之后立即创建了一个新的 try 语句块。 执行清理的 finally 与内部的 try 语句关联。这种方式中，finally 子句在构造失败时不会执行，而构造成功时总是执行。

**【这种finally的使用方式到是第一次见，get到了，将对象构造成功后增加一个try，将其对应的清理语句放到这个try后的 finally 中】**



> 这种通用的清理惯用法在构造器不抛出任何异常时也应该运用，其基本规则是：**在创建需要清理的对象之后，立即进入一个 try-finally 语句块：**

```java
// exceptions/CleanupIdiom.java
// 清理对象必须在一个 try-finally 语句块中

class NeedsCleanUp { // 构造方法不能失败
    private static long counter = 1;
    private final long id = counter++;

    public void dispose() {
        System.out.println("需要清理的对象: " + id + " 被清理");
    }
}

class ConstructionException extends Exception {
}

class NeedsCleanUp2 extends NeedsCleanUp {
    // 构造方法可以失败
    public NeedsCleanUp2() throws ConstructionException {
    }
}


public class CleanupIdiom {
    public static void main(String[] args) {
        //[1]
        NeedsCleanUp nc1 = new NeedsCleanUp();
        try {
            //针对 nc1 的业务代码
        } finally {
            // 对资源进行清理
            nc1.dispose();
        }

        //[2]
        //如果构造函数不能失败，你可以对对象分组
        NeedsCleanUp nc2 = new NeedsCleanUp();
        NeedsCleanUp nc3 = new NeedsCleanUp();
        try {
            //...
        } finally { // 反向清理，后构建的先被清理，因为可能有依赖关系
            nc3.dispose();
            nc2.dispose();
        }

        //[3]
        // 如果构造对象时可能失败，必须针对每个对象的构造进行保护
        try {
            NeedsCleanUp2 nc4 = new NeedsCleanUp2();

            try {
                NeedsCleanUp2 nc5 = new NeedsCleanUp2();
                try {
                    //...
                } finally {
                    nc5.dispose();
                }
            } catch (ConstructionException e) { // nc5 抛出的异常
                System.out.println(e);
            } finally {
                nc4.dispose();
            }

        } catch (ConstructionException e) { // nc4 抛出的异常
            System.out.println(e);
        }
    }
}
/**
输出
需要清理的对象: 1 被清理
需要清理的对象: 3 被清理
需要清理的对象: 2 被清理
需要清理的对象: 5 被清理
需要清理的对象: 4 被清理
*/
```

> [1] 相当简单，遵循了在可去除对象之后紧跟 try-finally 的原则。如果对象构造不会失败，就不需要任何 catch。
>
> [2] 为了构造和清理，可以看到将具有不会失败的构造器的对象分组在一起。
>
> [3] 展示了如何处理那些构造对象时可能失败并需要清理的对象。为了正确处理这种情况，**对于每一个构造都必须包含在自己的 try-finally 语句块中，并且每一个构造对象都跟随一个 try-finally 语句块以确保清理。**


