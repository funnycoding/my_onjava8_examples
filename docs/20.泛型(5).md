### 边界

> 边界 (bounds) 在本章前面进行了简要介绍。边界允许我们对泛型的参数类型施加约束。这最重要的是我们能调用边界确定的类的方法。

**【比如，如果不使用边界通配符 extends 等，那么所有泛型参数都会被擦除为 Object，所以调用类型参数只能调用 Object 的方法，但是如果你指定了边界，那么就能调用对应类独有的方法】**

> 由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将**该参数限制为某类型的子集**，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。

【这里的 extends 表明了限制，该类至少是某类的子类，所以可以调用 extends 限制的父类中存在的方法】

> 重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：

```java
// generics/BasicBounds.java
interface HasColor {
    java.awt.Color getColor();
}

// 边界限制泛型元素实现了 HasColor 所以 T 可以有 getColor() 方法
class WithColor<T extends HasColor> {
    T item;

    WithColor(T item) {
        this.item = item;
    }

    T getItem() {
        return item;
    }

    java.awt.Color color() {
        return item.getColor();
    }
}

class Coord {
    public int x, y, z;
}

// This fails. Class must be first, then interfaces:
// class WithColorCoord<T extends HasColor & Coord> {

// Multiple bounds: 多重限制 泛型元素必须继承 Coord 并且实现 HasColor 接口
class WithColorCoord<T extends Coord & HasColor> {
    T item;

    public WithColorCoord(T item) {
        this.item = item;
    }

    T getItem() {
        return item;
    }

    java.awt.Color color() {
        return item.getColor();
    }

    // 继承 Coord 的字段
    int getX() {
        return item.x;
    }

    int getY() {
        return item.y;
    }

    int getZ() {
        return item.z;
    }
}

interface Weight {
    int weight();
}


// As with inheritance, you can have only one
// concrete class but multiple interfaces: 继承 Coord 实现 HasColor 和 Weight 接口。 这里把类放在最前面
class Solid<T extends Coord & HasColor & Weight> {
    T item;

    Solid(T item) {
        this.item = item;
    }

    T getItem() {
        return item;
    }

    java.awt.Color color() {
        return item.getColor();
    }

    int getX() {
        return item.x;
    }

    int getY() {
        return item.y;
    }

    int getZ() {
        return item.z;
    }

    int weight() {
        return item.weight();
    }
}

class Bounded extends Coord implements HasColor, Weight {

    @Override
    public Color getColor() {
        return null;
    }

    @Override
    public int weight() {
        return 10;
    }
}

public class BasicBounds<T extends HasColor> {
    public static void main(String[] args) {
        Solid<Bounded> solid = new Solid<>(new Bounded());
        // 这里调用的都是 Bounded 类的方法
        solid.color();
        solid.getY();
        solid.weight();
    }
}

```

**【这个例子虽然有点长，但是很简单，就是使用 extends 进行限制，有的是一个，有的是多个】**

> 你可能会观察到 BasicBounds.java 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了 **边界约束** 。

```java
// generics/InheritBounds.java
class HoldItem<T> {
    T item;

    public HoldItem(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}

// 限制了 T 是 HasColor 的子类
class WithColor2<T extends HasColor> extends HoldItem<T> {

    public WithColor2(T item) {
        super(item);
    }

    java.awt.Color color() {
        return item.getColor();
    }
}

class WithColorCOord2<T extends Coord & HasColor> extends WithColor2<T> {

    public WithColorCOord2(T item) {
        super(item);
    }

    int getX() {
        return item.x;
    }

    int getY() {
        return item.y;
    }

    int getZ() {
        return item.z;
    }
}

class Solid2<T extends Coord & HasColor & Weight> extends WithColorCOord2<T> {
    public Solid2(T item) {
        super(item);
    }

    int weight() {
        return item.weight();
    }
}


public class InheritBounds {
    public static void main(String[] args) {
        Solid2<Bounded> solid2 = new Solid2<>(new Bounded());
        solid2.color();
        solid2.getY();
        solid2.weight();
    }
}

```

**【这个类相比上个类，设计的更加精妙一些，挺有意思的。最先有一个 Holder 类，持有一个 T类型的泛型参数 item，后面用 extends 来对这个 item 进行限制，于是item 的职能范围随着限制符的扩大不断扩大】**

> `HoldItem` 拥有一个对象，因此此行为将**继承**到 `WithColor2` 中，这也需要其参数符合 `HasColor`。 `WithColor2` 和 `Solid2` 进一步**扩展了层次结构**，并**在每个级别添加了边界。**
>
> **现在这些方法已经被继承，并且在每个类中不再重复。**
>
> 下面展示一个具有更多层次的示例：

```java
// generics/EpicBattle.java
// Bounds in Java generics
interface SuperPower {

}

// 镭射眼
interface XRayVIsion extends SuperPower {
    // 穿墙
    void seeThroughWalls();
}

// 顺风耳
interface SuperHearing extends SuperPower {
    // 窃听
    void hearSubtleNoises();
}

// 狗鼻子
interface SuperSmell extends SuperPower {
    // 追踪
    void trackBySmell();
}

// 超英必须具有上面的超级能力
class SuperHero<POWER extends SuperPower> {
    POWER power;

    public SuperHero(POWER power) {
        this.power = power;
    }

    POWER getPower() {
        return power;
    }
}

// 超级忍犬
class CanineHero<POWER extends SuperHearing & SuperSmell> extends SuperHero<POWER> {

    public CanineHero(POWER power) {
        super(power);
    }

    void hear() {
        power.hearSubtleNoises();
    }

    void smell() {
        power.trackBySmell();
    }
}


// 超级听力和嗅觉的具体实现类
class SuperHearSmell implements SuperHearing, SuperSmell {

    @Override
    public void hearSubtleNoises() {
        System.out.println("战术目镜启动！");
    }

    @Override
    public void trackBySmell() {
        System.out.println("超级嗅觉！");
    }
}

class DogPerson extends CanineHero<SuperHearSmell> {

    public DogPerson() {
        super(new SuperHearSmell());
    }
}


// 史诗对决，牛逼了
public class EpicBattle {
    // 使用 extends 通配符限制 泛型边界

    static <POWER extends SuperHearing> void userSuperHearing(SuperHero<POWER> hero) {
        hero.getPower().hearSubtleNoises();
    }

    static <POWER extends SuperHearing & SuperSmell> void superFind(SuperHero<POWER> hero) {
        hero.getPower().hearSubtleNoises();
        hero.getPower().trackBySmell();

    }

    public static void main(String[] args) {
        DogPerson dogPerson = new DogPerson();
        System.out.println("----------");
        userSuperHearing(dogPerson);
        superFind(dogPerson);

        List<? extends SuperHearing> audioPeople;
        // But you can't do this: 不能这样做
        // List<? extends SuperHearing & SuperSmell> dogPs;
    }

}

```

**【这个例子非常有意思哈，还很带感，寓教于乐，我自己加了一些注释，因为如果看不懂这个例子的意思的话，就索然无味了。】**





### 通配符

> 你已经在 集合 章节中看到了一些简单示例使用了通配符 —— 泛型表达式中的问号。在类型信息 一张中这种示例更多。本节将深入地探讨这个特性。
>
> 我们的起始示例要展示数组的一种特殊行为： 你可以将子类数组赋值给基类引用：

**【也就是多态。父类数组的引用指向子类的数组】**

```java
// generics/CovariantArrays.java
    
class Fruit {

}

class Apple extends Fruit {
}

class Jonathan extends Apple {
}

class Orange extends Fruit {
}


public class CovariantArrays {
    public static void main(String[] args) {
        // 父类引用指向子类数组
        Fruit[] fruits = new Apple[10];

        fruits[0] = new Apple(); // ok 将子类对象存入数组
        fruits[1] = new Jonathan(); // ok 子类的子类存入数组

        try {
            // 编译器允许将父类对象存入指向子类的数组中
            fruits[0] = new Fruit(); // ArrayStoreException  但是实际运行会引发异常

        } catch (Exception e) {
            System.out.println(e);
        }

    }
}
/**
数组
java.lang.ArrayStoreException: generics.Fruit
*/
```

> `main()` 中的第一行创建了一个 `Apple` 类型的数组，并赋值其父类 `Fruit` 数组引用。这是有意义的。因为 Apple 也是一种 `Fruit`，因此 `Apple` 数组也应该是一种 `Fruit` 数组。
>
> 但是如果实际的数组是 `Apple[]` ，也可以在其中放置 `Apple` 或 `Apple` 的子类，在编译期和运行时都可以正常工作。但是你也可以在数组中放置其父类 Fruit 的对象。
>
> 这对编译器来说是由意义的，因为它有一个 `Fruit[]` 引用 —— 所以编译器没有理由不允许将 Fruit 对象或任何从 `Fruit` 继承出来的对象（比如 Orange） 放置到这个数组中。因为在编译期这是完全被允许的。
>
> 然而运行时的数组机制知道它是如何处理 `Apple[]` ，因此会在向数组中放置错误类型元素时抛出异常。
>
> **向上转型用在这里不合适。**
>
> **你真正在做的是将一个数组赋值给另一个数组。** 数组的行为是**持有**其他对象，这里只是因为我们能够向上转型而已，所以很明显，**数组对象可以保留有关它们包含的对象类型的规则**。
>
> 看起来就像数组对它们持有的对象是有意识的，因此在编译期间和运行时检查之间，你不能滥用它们。
>
> 数组的这种赋值并不可怕，因为在运行时你额可以发现插入了错误的类型。
>
> 但是泛型的主要目标之一是将错误的检测提前到编译期。所以当我们试图使用泛型集合代替数组的时候会发生什么?

【这里比较重要的知识点是 数组中的向上转型与多态不一样**，数组中的向上转型是不合适的**。】 

```java
// generics/NonCovariantGenerics.java
// {WillNotCompile}

import java.util.*;
// 编译器会提示你泛型参数错误
public class NonCovariantGenerics {
    // Compile Error: incompatible types:
    List<Fruit> flist = new ArrayList<Apple>();
}
```

**【之前的泛型擦除就讲过了，`List<Fruit>` 并不是 `List<Apple>` 的父类，因为这里的类型参数都会被擦除为 Object】**



> 尽管你在首次阅读这段代码时会认为 不能讲一个Apple 集合赋值给一个 Fruit 集合。 
>
> 泛型不仅仅是关于集合，它真正要表达的是，不能把一个涉及 Apple 的泛型赋值给一个涉及 Fruit 的泛型。
>
> 如果像在数组中的情况一下，编译器对代码的了解足够多，可以确定所涉及的集合，那么它可能会留下一些余地。
>
> 但是实际上编译器不知道任何有关这方面的信息，**因此它拒绝向上转型。**然而这实际上也不是向上转型——  **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。

【这段作者说的太绕了，核心就是我上面说的，参数类型会被擦除】

> 真正的问题是我们在讨论的**集合类型**，而**不**是**集合持有对象的类型**。
>
> 与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译期和运行时系统不知道你想用类型参数做什么，以及应该采用什么规则。
>
> 但是如果你想在**两个类型间建立某种向上转型关系**。**通配符**可以产生这种关系：

```java
// generics/GenericsAndCovariance.java
public class GnericAndCovariance {
    public static void main(String[] args) {
        // Wildcards allow covariance: 原始类型允许协变
        List<? extends Fruit> fList = new ArrayList<>();
 			  // 这里是我加的所以也就是可以将父类的 List 引用指向子类List
        List<Apple> aList = new ArrayList<>();
        fList = aList;
        // 下面的行为会产生一个编译时异常。无法添加任何对象到 fList 中
        // flist.add(new Apple());
        // flist.add(new Fruit());
        // flist.add(new Object());

        fList.add(null);

        // 我们知道下面的操作返回第一个元素
        Fruit fruit = fList.get(0);
        System.out.println(fruit);
    }
}

```

**【这里我有疑惑，为什么 Fruit 的子类不能放进去，这个通配符在这里代表了什么？】**

> flist 的类型是 List<? extends Fruit> ，可以看作：任何 Fruit 的子类。
>
> 然而这并不意味着 这个List 将持有任何类型的 Fruit，通配符引用的是明确的类型，因此它意味着某种 flist 引用没有指定的具体类型，因此这个被赋值的 List 必须持有 Fruit 或 Apple 这样的 指定类型，但是为了向上转型为 Fruit ，这个类型是什么没人在意。
>
> List 必须持有一种具体的 Fruit 或 Fruit 子类，但是如果你不关心具体的类型是什么，那么你能对这样的 List 做什么呢？如果不知道 List 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？ 就像在 ConvarintArryas.java 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。但是你很快会发现这个问题：
>
> 但是你会疑惑，为什么不能向刚刚声明过将持有 Apple 对象的 List 中放入一个 Apple 对象。
>
> 是的，但是编译器并不知道这一点。 `List<? extends Fruit>` 可能合法地指向一个 `List<Orange>` 。**一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至 Object 也不行。**【这个很关键，**那这里这种向上转型有啥用呢？**】
>
> 另一方面，如果你调用了一个返回 Fruit 的方法，则是安全的。因为你知道这个List 中的任何对象至少都是 Fruit 类型。因此编译器允许这么做。



#### 编译器有多聪明

> 现在你可能会猜想自己不能去调用任何接受参数的方法。但是考虑下面的代码：

```java
// generics/CompilerIntelligence.java
public class CompilerIntelligence {
    public static void main(String[] args) {
        // 相当于把一个 List<Apple> 赋值给 List<? extends Fruit>
        List<? extends Fruit> flist = Arrays.asList(new Apple());

        Apple apple = (Apple) flist.get(0); // 不会产生警告

        //flist.add(new Apple()); // Compiler Error

        System.out.println(flist.contains(new Apple())); // Argument is 'Object'
        System.out.println(flist.indexOf(new Apple())); // Argument is 'Object'

    }
}

```

> 这里对 contains() 和 indexOf() 的调用接受 Apple 对象作为参数，执行没有问题。 这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
>
> 通过查看 ArrayList 的文档，我们发现编译器没有那么聪明。

```java
// Arrays.java
   boolean contains(Object o);
   int indexOf(Object o);
```

> 可以看到这两个方法接受的参数类型都是 Object。 因此当你指定一个 ArrayList<? extends Fruit> 时，add() 的参数就变成了 "**？ extends Fruit**" 。**从这个描述中，编译器无法得知这里需要 Fruit 的哪个具体子类型，因此它不会接受任何类型的 Fruit。**
>
> 如果你先把 Apple 向上转型为 Fruit 也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。

```java
// Arrays.java
boolean add(E e);
```

> contains() 和 indexOf() 的参数是 Object，不涉及通配符，所以编译器允许调用它们。 这意味着将由泛型类的设计者来决定哪些调用是安全的，并使用 Object 类作为它们的参数。
>
> 为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。【这句话的翻译让我有点懵逼，而且我现在也没有理解透这个概念，明天回过头看一下， 然后试着改一下这个翻译】
>
> 下面展示一个简单的 Holder 类：

```java
// generics/Holder.java
// 这里我修改了一些变量名，与书中例子的不同，更贴近例子
public class Holder<T> {
    private T value;

    public Holder() {
    }

    public Holder(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }

    public void set(T value) {
        this.value = value;
    }

    // 首先 对象要属于 Holder 并且 Holder中持有的 value 与对象的 value 相同
    @Override
    public boolean equals(Object o) {
        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(value);
    }

    public static void main(String[] args) {
        Holder<Apple> appleHolder = new Holder<>(new Apple());
        Apple apple = appleHolder.get();
        appleHolder.set(apple);
        //Holder<Fruit> fruitHolder = appleHolder; // 编译异常 不能完成这样的类型转换
        Holder<? extends Fruit> fruitHolder = appleHolder; // 这样是 OK的
        Fruit fruit = fruitHolder.get();
        apple = (Apple) fruitHolder.get(); // 这里也是OK的，因为这里的 Fruit List 中实际保存的是 Apple 对象

        try {
            Orange c = (Orange) fruitHolder.get(); // 这里就会产生类转换异常了，因为无法将 Apple 转为 Orange 类
        } catch (Exception e) {
            System.out.println(e);
        }

        //fruitHolder.set(new Apple()); 不能这样调用 set() 方法
        //fruitHolder.set(new Fruit()); 不能这样调用 set() 方法
        System.out.println(fruitHolder.equals(apple)); // OK

    }
}
/**
输出
java.lang.ClassCastException: generics.Apple cannot be cast to generics.Orange
false
*/
```

> `Holder` 中有一个接受 `T` 类型的 `set()` 方法，一个返回 `T` 对象的 `get()` 方法和一个接受 `Object` 对象的 `equals()` 方法。 
>
> `Holder<Apple>` 不能向上转型为 `Holder<Fruit>` 但是可以向上转型为 `Holder<? extends Fruit>`。 如果调用 `get()` ，只能返回一个 `Fruit` —— 这就是在给定任何扩展自 `Fruit` 的对象 这一边界后，它所能知道的一切。
>
> 如果你知道更多的信息，就可以将其转型到某种具体的 Furit 而不会导致编译时的警告，但是可能导致运行时的类转换异常（比如上例中的 将 **Apple** 转为 **Orange**）。
>
> `set()` 方法不能工作在 `Apple` 和 `Fruit` 上，因为 set() 的参数也是 `"? extends Fruit"`，这意味着它可以是任何事物，而编译器无法验证这种 "任何事物"的类型安全性。
>
> 但是 `eqauls()` 方法可以正常工作，因为它接受的参数是 `Object` 而不是 `T` 类型，**不涉及**到通配符。
>
> **因此，编译器只关注传递进来和要返回的对象类型，它不会分析代码，以查看是否执行了任何实际的写入和读取操作。**
>
> Java 7 引入了 `java.util.Objects` 库，使创建 `equlas()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。 `eqauls()` 方法的标准形式参考  [附录：理解 equals 和 hashCode 方法](https://lingcoder.github.io/OnJava8/#/book/Appendix-Understanding-equals-and-hashCode) 一章。

#### 逆变【Contravariance】（这里的逆变指的是使用 super 通配符）

> 还可以走另外一条路，使用 超类型通配符。 这里可以声明通配符是由某个特定类的任何基类来限定的，方法是指定 `<? super MyClass>` 甚至使用 超类型通配符 + 类型参数 `<? super T>` (尽管你不能对泛型参数给出一个超类型边界 —— 不能声明 `< T super MyClass>` )。
>
> 这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 Collection 写入了：

【问题来了 `<? super Myclass>` 和 `<T super Myclass>` 的区别？ 一个是无界通配符，一个是类型参数，那么具体的编译器处理机制的区别呢？

```java
// generics/SuperTypeWildcards.java
public class SuperTypeWildcards {
    static void writeTo(List<? super Apple> apples) {
        apples.add(new Apple()); //ok 正常工作
        apples.add(new Jonathan());
        // apples.add(new Fruit()); // Error
    }

    // 与之前的 ? extends 他们的父类 Fruit 做对比
    static void writeTo2(List<? extends Fruit> fruits) {
        //fruits.add(new Apple()); // 编译器异常
        //fruits.add(new Jonathan()); // 编译器异常
    }
}


```

【这里可以看到，下面是我添加的之前的例子，`< ? extends Fruit>` 无法添加他们的子类对象，因为编译器无法确定。但是这里 `<? super Apple>` 却可以添加 `Apple` 和它的子类对象，挺神奇的。】

> 参数 `apples` 是 `Aplle` 的某种类型的 **List**，这样你就知道**向其中添加 Apple 或者 Apple 的子类是安全的**。但是因为 `Apple` 是**下界**，所以向这个 **List 中添加 Apple 的父类 `Fruit` 是不安全的**，这将使 List 敞开口子，从而可以向其中添加非 Apple 类型的对象（**因为 Fruit 的子类不一定是 Apple 的父类**） 而这**违反静态类型安全。**
> 下面 的例子复习了**逆变**和通配符的使用：

```java
// generics/GenericReading.java
public class GenericReading {
    static List<Apple> apples = Arrays.asList(new Apple());
    static List<Fruit> fruits = Arrays.asList(new Fruit());

    // 泛型方法，返回 List 的第一个元素
    static <T> T readExact(List<T> list) {
        return list.get(0);
    }

    // A static method adapts to each call 适配器方法
    static void f1() {
        Apple apple = readExact(apples);
        Fruit fruit = readExact(fruits);
        fruit = readExact(apples);
    }

    // 这里是一个静态内部类，带有一个泛型参数，但是作用好像跟上面的泛型方法应该是一样的
    static class Reader<T> {
        T readExact(List<T> list) {
            return list.get(0);
        }
    }

    static void f2() {
        Reader<Fruit> fruitReader = new Reader<>();
        Fruit f = fruitReader.readExact(fruits);
        //Fruit fruit = fruitReader.readExact(apples); // Error Require List<Fruit> Provide List<Apple>
    }

    // 协变类型
    static class ConvariantReader<T> {
        T readCovariant(List<? extends T> list) {
            return list.get(0);
        }
    }

    static void f3() {
        ConvariantReader<Fruit> fruitReader = new ConvariantReader<>();
        Fruit f = fruitReader.readCovariant(fruits);
        Fruit a = fruitReader.readCovariant(apples);
    }


    public static void main(String[] args) {
        f1();
        f2();
        f3();
    }
}

```

**【作者选的例子都挺有带表性的，这里三种不同的泛型使用，第一个是使用泛型方法，第二个是使用泛型类，第三个使用协变通配符，仔细看，挺有意思的】**

> readExact() 方法 使用了确切的类型 T。如果使用这个没有任何通配符的精确类型，就可以向 List 中写入和读取 这个精确类型。另外对于返回值，静态的泛型方法 `readExact()`  可以有效地 "适应每个方法地调用" 并能够从 `List<Apple>` 中返回一个 `Apple`，从 `List<Fruit>` 中f安徽一个 `Fruit`。 就像在 f1() 中看到的那样。【`f1()` 是对 `readExact()` 的封装】
>
> 因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
>
> 然而对于**泛型类**来说，当你创建这个类的**实例时**，**就要为这个类确定参数**。 就像在 f2() 中看到的 fruitReader 实例可以从 `List<Fruit>` 中读取一个 `Fruit`，因为**这就是泛型类确切的类型**。但是 `List<Apple>` 也应该产生Fruit 对象，而 `fruitReader` **不允许**这么做。【因为 `List<Apple>` 产生的只能是 Apple对象 这里又要回到类型擦除知识点上， `List<Fruit>` 并不是 `List<Apple>` 的父类。所以 `List<Apple>` 不能产生 Fruit 对象。】
>
> 为了修正这个问题，`ConvariantReader.readConvariant()` 方法将接收 `List<? extends T>`，因此，从这个列表中读取一个 `T` 是安全的（**你知道在这个列表中所有对象至少是一个 T 或者 T 的某个子类**） 在 `f3()` 中，你可以看到修正可以从 `List<Apple>` 中获得 `Fruit` 对象了。

#### 无界通配符

> 无界通配符 <?> 看起来意味着 "任何事物" ，因此使用无解通配符好像等价于使用 原生类型**【意思就是跟持有一个 Object一样】**，但是事实上，编译器初看起来是支持这种判断的：

```java
// generics/UnboundedWildcards1.java
public class UnboundedWildcards1 {
    static List list1;
    static List<?> list2; // 无界通配符
    static List<? extends Object> list3;

    // 这里的入参类型是 RawType 未使用泛型的List
    static void assign1(List list) {
        list1 = list; // ok  将RawType 赋值给 RawType
        list2 = list; // ok 将 RawType 赋值给使用 ? 无界通配符的 List
        //list3 = list; // 将 RawType 赋值给 extends 带有边界的List  编译器会产生警告 unchecked assignment
    }

    // 入参是一个无界List 区别于未使用反省的 RawType
    static void assign2(List<?> list) {
        list1 = list;
        list2 = list;
        list3 = list; // 三种赋值操作都不会产生警告信息
    }

    // 限定类型参数都是 Object 的子类（这不是等于没说。。。）
    static void assign3(List<? extends Object> list) {
        list1 = list;
        list2 = list;
        list3 = list; // 三种操作也不会产生警告信息
    }

    public static void main(String[] args) {
        assign1(new ArrayList());
        assign2(new ArrayList());
        // 这里会产生一个 未检查的赋值警告 ArrayList 无法被编译器确定为 ArrayList<? extends  Object> 也就是这俩无法划等号
        assign3(new ArrayList());

				// 这三个都是类型参数为 Object 的 List
        assign1(new ArrayList<>());
        assign2(new ArrayList<>());
        assign3(new ArrayList<>());
        // Both forms are acceptable as List<?>: 使用 ? 无界通配符的 List 对象可以指向不适用泛型的 List 对象
        List<?> wildList = new ArrayList();
        wildList = new ArrayList<>();
        assign1(wildList);
        assign2(wildList);
        assign3(wildList);
    }
}

```



> 有很多情况都和这里的情况类似：编译器很少关心使用的是原生类型（泛型的 RawType） 还是 `<?>`。在这些情况中， <?> 可以被认为是一种装饰，但是它仍旧是由价值的，因为实际上它是在**声明**：**我是想用 Java 泛型来编写这段代码，我在这里并不是要用原生类型，但是在这种情况下，泛型参数可以持有任何类型。**【也就是我清楚的知道使用   无界通配符的作用。
>
> 第二个例子展示了无界通配符的一个**重要应用**：当你在**处理多个泛型参数时**，有时**允许一个参数可以是任何类型**，同时**为其他参数确定某种特定类型的这种能力**会显得很重要。

```java
// generics/UnboundedWildcards2.java
public class UnboundedWildcards2 {
    // 先来一个RawType Map
    static Map map1;
    // 再来一个不限制泛型类型的 Map
    static Map<?, ?> map2;

    // 再来一个 一个Key为String Value 随意的 Map
    static Map<String, ?> map3;

    // 下来分别写对map进行赋值的方法

    static void assign1(Map map) {
        map1 = map;
    }

    static void assign2(Map<?, ?> map) {
        map2 = map;
    }

    static void assign3(Map<String, ?> map) {
        map3 = map;
    }

    public static void main(String[] args) {
        assign1(new HashMap()); //ok
        assign2(new HashMap()); //ok
        assign3(new HashMap()); // 编译警告 跟上个例子一样，无法确认 HashMap 是 HashMap<String,?> 类型的

        assign1(new HashMap<>());
        assign2(new HashMap<>());
        assign3(new HashMap<>());
    }

}

```

【感觉这个例子基本和上个 ArrayList 的例子一致】

> 当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来无法将其余 原生 Map 区分开。
>
> 另外，**UnboundedWildcards1.java** 展示了编译器处理 `List<?>` 和 `List<? extends Object>` 是不同的。令人困惑的是，编译器并非总是关注像 List 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数会被擦除为它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>`，而 List  的 原始类型实际也就是一个 `List<Object>` —— 除非这些语句都不为真。 
>
> **`List` 实际上可以表示"任何持有 `Object` 类型的原生 List "，而 `List<?>` 表示 具有某种特定类型的非原生 `List`，只是我们还没有确定具体类型是什么。**
>
> 编译器何时会关注原生类型和涉及无界通配符类型之间的差异呢？下面的例子使用了之前定义的 `Holder<T>` 类，**它包含接受 `Holder` 作为参数的各种方法**，但是它们具有**不同的形式**：作为**原生类型**，**具有具体的类型参数**以及具有**无界通配符参数：**

```java
// generics/Wildcards.java
// Exploring the meaning of wildcards 展示  wildcards 的意义
// 这个例子比较长，有一些场景是重复的
public class Wildcards {
    // Raw Argument 使用 RawType Holder类
    static void rawArgs(Holder holder, Object arg) {
        //holder.set(arg); // 抛出警告，Unchecked 的方法调用

        // Can't do this; don't have any 'T':
        // holdger.get() 的返回值不能是泛型参数 T ,因为这里使用的是 RawType
        // T t = holder.get();
        // OK, but type information is lost:
        // 使用 holdger get 获取 holder 中存储的对象 运行正常，但是丢失了类的具体信息，需要手动进行强转
        Object obj = holder.get();
    }

    // Like rawArgs(), but errors instead of warnings:
    // 和原始类型有点像，但是 上面的警告编程了下面的 Error
    static void unboundedArg(Holder<?> holder, Object arg) {
        // 这里不能确定 Object 是 无界通配符类型的
        // error: method set in class Holder<T>
        // cannot be applied to given types;
        //     holder.set(arg);
        //           ^
        //   required: CAP#1
        //   found: Object
        //   reason: argument mismatch;
        //     Object cannot be converted to CAP#1
        //   where T is a type-variable:
        //     T extends Object declared in class Holder
        //   where CAP#1 is a fresh type-variable:
        //     CAP#1 extends Object from capture of ?
        // 1 error
        //holder.set(arg);

        // OK, but type information is lost: 与上面的一样，获取 Holder 中的对象正常，但是丢失对象类型
        Object obj = holder.get();
    }

    // 这里返回的是具体类型 T 而不是上面的 Object
    static <T> T exact1(Holder<T> holder) {
        return holder.get();
    }

    // 这里将对应 T 类型的元素放入 Holder<T> 很合理，没毛病
    static <T> T exact2(Holder<T> holder, T arg) {
        holder.set(arg);
        return holder.get();
    }

    // 返回 Holder 中持有的对象
    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
        // Error 这里需要的是 ? extends T 而不是具体的类型
        //holder.set(arg);
        return holder.get();
    }

    static <T> void wildSuperType(Holder<? super T> holder, T arge) {
        // set 工作正常，因为通配符限制了元素都是 T 类型的父类，所以 T 可以放入 Holder
        holder.set(arge);

        // 但是现在 Holder.get() 无法确定具体类型，只能获得 Object，于是无法返回 T 类型
        Object object = holder.get();

        //- T t = holder.get();
        // error: incompatible types:
        // CAP#1 cannot be converted to T
        //     T t = holder.get();
        //                     ^
        //   where T is a type-variable:
        //     T extends Object declared in method
        //       <T>wildSupertype(Holder<? super T>,T)
        //   where CAP#1 is a fresh type-variable:
        //     CAP#1 extends Object super:
        //       T from capture of ? super T
        // 1 error
    }

    public static void main(String[] args) {
        // Raw Type
        Holder raw = new Holder<>();
        //  或者直接这样
        raw = new Holder();

        // Long 包装器类型的 Holder
        Holder<Long> qualified = new Holder<>();
        // 无界通配符 Holder
        Holder<?> unbounded = new Holder<>();
        // 持有 Long 父类的 Holder
        Holder<? extends Long> bounded = new Holder<>();

        Long lng = 1L;
        rawArgs(qualified, lng);
        rawArgs(unbounded, lng);
        rawArgs(bounded, lng);

        // 都ok
        unboundedArg(raw, lng);
        unboundedArg(qualified, lng);
        unboundedArg(unbounded, lng);
        unboundedArg(bounded, lng);

        Object o = exact1(raw); // Unchecked Assign 警告 ，因为 raw 是原始类型
        Long aLong = exact1(qualified); // 获得确定的 Long 对象
        Object r3 = exact1(unbounded); // Must return Object 只能返回 Object，不能返回确定类型
        Long r4 = exact1(bounded); // 可以确定其中保存的都是 Long 的子类，所以可以返回父类引用
        Long r5 = exact2(raw, lng); // 使用原始类型，编译器无法确定其中保存的对象类型，给出警告

        Long r6 = exact2(qualified, lng); // 确定类型的泛型，没问题

        //Long r7 = exact2(unbounded, lng); // 无界通配符，无法返回具体类型，只能返回 Object

        // 这里也无法返回具体的 Long 类型对象 这里需要的是 Holder<Long> 而不是 Hodler<? extends Long>
        // 这里传入的 T 是Long  而 bounded 类型是 <? extends Long> 于是无法确定
        //Long r8 = exact2(bounded, lng);

        Long r9 = wildSubtype(raw, lng); // 原始类型的Holder，同样抛出 Unchecked Assign 警告
        Long r10 = wildSubtype(qualified, lng); // 确切泛型 Holder 一直都 Ok
        Object r11 = wildSubtype(unbounded, lng);// 无界通配符只能返回 Object
        Long r12 = wildSubtype(bounded, lng); // 确定返回的都是 Long 类型的子类

        wildSuperType(raw, lng); // Unchecked
        wildSuperType(qualified, lng); // ok

        //wildSuperType(unbounded, lng); error
        // error: method wildSupertype in class Wildcards
        // cannot be applied to given types;
        //     wildSupertype(unbounded, lng);
        //     ^
        //   required: Holder<? super T>,T
        //   found: Holder<CAP#1>,Long
        //   reason: cannot infer type-variable(s) T
        //     (argument mismatch; Holder<CAP#1>
        //     cannot be converted to Holder<? super T>)
        //   where T is a type-variable:
        //     T extends Object declared in
        //     method <T>wildSupertype(Holder<? super T>,T)
        //   where CAP#1 is a fresh type-variable:
        //     CAP#1 extends Object from capture of ?
        // 1 error

        //wildSuperType(bounded, lng); // error
        // error: method wildSupertype in class Wildcards
        // cannot be applied to given types;
        //     wildSupertype(bounded, lng);
        //     ^
        //   required: Holder<? super T>,T
        //   found: Holder<CAP#1>,Long
        //   reason: cannot infer type-variable(s) T
        //     (argument mismatch; Holder<CAP#1>
        //     cannot be converted to Holder<? super T>)
        //   where T is a type-variable:
        //     T extends Object declared in
        //     method <T>wildSupertype(Holder<? super T>,T)
        //   where CAP#1 is a fresh type-variable:
        //     CAP#1 extends Long from capture of
        //     ? extends Long
        // 1 error

    }

}

```

> 在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类，因此即使它在这里被表示成一个原生类型，编译器仍旧知道 向 set() 传递一个 Object 是不安全的。
>
> 由于它是**原生类型**，你可以将任何类型传递给 `set()` ， 而这个对象将被**向上转型为** `Object`。 **因此无论何时，只要使用了原生类型，都会放弃编译器检查** 。 对 get() 的调用说明了相同的问题：**没有任何 `T` 类型的对象，因此结果只能是一个 `Object`。** 
> 人们会很自然地开始考虑原生 `Holder` 与 `Holder<?>` 之间的关系，认为是大致相同的事物，但是 `unboundedArg()` 强调它们是**不同**的 —— 这揭示了相同的问题，但是它将这些问题作为错误 而不是编译期警告报告，**因为 原生 Holder 将持有任何类型的组合，而 `Hodler<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 Object。**
> 在 `exact1()` 和 `exact2()` 中，你可以看到使用了**确切的泛型参数** —— 没有任何通配符，你将看到 `exact2()` 与 `exact1()` 具有不同的限制，因为它有额外的参数。
> 在 `wildSubType()` 中，在 `Holder` 类型上的限制被放松为持有任何扩展自 `T` 对象的 `Holder`。这还是意味着如果 `T` 是 `Fruit` 那么 `holder` 可也是 `Holder<Apple>` ，这是合法的。
> 为了防止将 Orange 放入到 `Holder<Apple>` 中，对 set() 的调用（或者对任何接受这个类型参数为参数的方法的调用） **都是不允许的。** 
>
> 但是你仍旧知道任何来自 `Holder <? extends Fruit>` 的对象都是 `Fruit` 的**子类**，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法） 都是允许的。 
>
> `wildSuperType()` 展示了`super`类型通配符，这个方法有与 `wildSubType()` 相反的行为： `holder` 可以是持有**任何** `T` 的**基类型的容器**。因此 `set()` **可以接受 `T`**，因为任何可以工作于基类的对象都是可以多态的工作在子类（这里就是 T) 上。但是尝试调用 `get(`) 是没有用的，因为由 `holder` **持有的类型可以是任何超类型，因此唯一安全的类型就是 `Object`。**
>
> **这个例子还展示了对于在 unbounded() 中使用无界通配符能够做什么不能做什么做出的限制：因为你没有 T，所以你不能讲 set() 或 get() 作用于 T 上。**
>
> 在 `main()` 方法中你看到了某些方法在接收某些类型的参数时没有报错和警告。为了**迁移兼容性**， `rawArgs()` 将接受所有 **Holder** 的不同变体，而不会产生警告。 `unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，**它在方法体内处理这些类型的方式并不相同。**
>
> 如果向接受 "确切" 泛型类型（没有通配符） 的方法传递一个原生的 Holder 引用，就会得到警告，因为确切的参数期望得到在原生类型中并不存在的信息。
>
> 如果向 exact1() 中传递一个无界引用，就不会有任何可以确定返回类型的类型信息。**【所以 `? extedns Fruit` 只能返回 Object】** 可以看到, `exact2()` 具有最多的限制，因为它希望精确地得到一个 **`Holder<T>`** 以及一个具有类型 `T` 的参数，**正由于此**，如果不提供确切的参数，这个方法将产生错误或警告。
>
> 有时这样做很好，但是如果它过于受限，那么就需要使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSuperType()` )中看到的那样。**【这两个方法很有意思，一会拿出来对比】**
>
> 因此，**使用确切类型来代替通配符类型的好处是，可以用泛型参数来做更多的事。但是使用通配符使得你必须接受范围更宽的参数化类型作为参数**。因此，必须因地制宜，选择适合你的方法。

【其实这里的核心问题就是 `List<?>` 和 `List<T>` 以及 `List<? extends T>` `List< ? super T>` 之间的区别。】 把这几个区别搞明白了，也就把上面一大段话搞明白了



