---
layout: post
title: 《On Java8》第二十章——泛型
date: 2020年02月29日16:09:46
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### 首先总结一下个人对泛型的理解：

泛型的种类：

- **类类型**
- **方法类型**

泛型出现的时间：JDK 5

泛型出现的意义：通过类型参数指明之前用 Object 存储的对象的类型，尽量减少 ClassClastException 的发生，将异常提前到编译期，由编译器来检查定义的类型和实际使用的类型是否匹配。

主要目的：配合CollectionFramework，规定集合存储对象的种类。

泛型的关键知识点：

- 通配符
- 泛型与多态
- 泛型擦除
- 泛型本质上是语法糖，在 JVM 上并没有骚操作，只是编译器多帮我们干了一些活。

<!-- more -->	

### 简单泛型



> **Java 的泛型存在着一些限制**，只有知道**语言的缺陷才**会让你成为高手，因为**不必浪费时间在死胡同里**。
>
> 我们编写一个可持有其他对象的类：

```java
// generic/Holder1.java
class Automobile {}

public class Holder1 {
    private Automobile a;
    public Holder1(Automobile a) { this.a = a; }
    Automobile get() { return a; }
}
```

> 这个类的可复用性不高。因为只能持有**特定类型**的 Automobile 的对象实例。
>
> Java5 之前使用 `Object` 对象来实现通用性。

```java
// generics/ObjectHolder.java

public class ObjectHolder {
    private Object a;
    public ObjectHolder(Object a) { this.a = a; }
    public void set(Object a) { this.a = a; }
    public Object get() { return a; }

    public static void main(String[] args) {
        ObjectHolder h2 = new ObjectHolder(new Automobile());
        Automobile a = (Automobile)h2.get();
        h2.set("Not an Automobile");
        String s = (String)h2.get();
        h2.set(1); // 自动装箱为 Integer
        Integer x = (Integer)h2.get();
    }
}
```

> ObjectHolder 可以通过其持有的 `Object 引用 a` 持有任何类型的对象。
>
> 例子中分别持有 Automobile ，String，Intenger，三种对象。
>
> 一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来**约定集合要存储什么类型的对象**，并且通过**编译器**确保规约得以满足。
>
> 泛型使用一个类型占位符来替代 Object 引用。定义占位符后当使用时才会决定具体使用什么类型。
>
> 要达到这个目的，需要使用***类型参数***，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：

```java
// GenericHolder.java
public class GenericHolder<T> {
    // 相当于定义一个 Object 引用
    private T a;

    public GenericHolder() {
    }

    // 对类型参数的赋值 以及对应的获取方法
    public GenericHolder(T a) {
        this.a = a;
    }

    public T getA() {
        return a;
    }

    public void set(T a) {
        this.a = a;
    }

    public static void main(String[] args) {
        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
        h3.set(new Automobile()); // 此处编译器会对 Set 方法做类型校验 如果不是 Automobile 类 ，则报错
        Automobile a = h3.getA(); // 无需进行 Class Cast，编译器知道 GnericHolder 中的 T 就是 Automobile类型
        //h3.set("Not an Automobile"); // 报错
        //h3.set(1);  // 报错
    }
}
```

> 创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为**多态与泛型不冲突**）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
>
> 这就是 Java 泛型的**核心概念**：你只需**告诉编译器要使用什么类型**，**剩下的细节交给它来处理。**

**【编译器做了检查类型，擦除类型的工作。】**

> 这里创建 h3 对象的时候定义非常反复，左右两边都确定了泛型类型
>
> ​      `GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();`
>
> 到了Java 7 之后，有了类型推导 只需要在声明引用的时候定义类型参数就可以了。



```java
// generics/Diamond.java

class Bob {}

public class Diamond<T> {
    public static void main(String[] args) {
        GenericHolder<Bob> h3 = new GenericHolder<>();
        h3.set(new Bob());
    }
}
```



> 注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
>
> 一般来说，你可以认为**泛型和其他类型差不多，只不过它们碰巧有类型参数罢了**。在使用泛型时，你只需要**指定它们的名称和类型参数列**表即可。

**【泛型就是多了类型参数，而这个参数在后面讲到擦除的时候还会着重提，所以刚开始看到泛型可能会感觉比较复杂，尤其多个类型参数的时候，但是你想明白它的核心就会发现，这只是语法层面的东西，任何不涉及JVM的我认为都是不复杂的。】**



#### 一个元组（Tuple）类库

【这里我首先有疑问，Tuple 这个概念我是第一次见，代表啥？】

> 当一个方法需要返回多个对象，而 Java 中 return 只能返回单个对象时，**解决方法就是返回一个封装多个对象的对象**【套娃】
>
> 可以在每次需要的时候专门创建一个类来完成这样的工作，但是有了**泛型**，就可以**一劳永逸**，并且获得了**编译时的类型安全**。
>
> 这个概念称为 **元组**   *它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 数据传输对象（DTO）* 或 *信使（Messager）* ）。

**【说了这么多，原来就是DTO... 那么下面就用 】**

> 通常，元组可以有任意长度，元组中的对象可以是不同类型的。
>
> 不过，我们希望能够**为每个对象指明类型**，**并且从元组中读取出来时**，能够得到正确的类型。要处理不同长度的问题，**我们需要创建多个不同的元组**。下面是一个可以存储两个对象的元组：

```java
// Tuple2.java
// 持有2个泛型对象的容器类
public class Tuple2<A, B> {
  	// 这里对字段定义为 public final 的意义在于：为不同的元素创建不同的 Tuple2，无法重复对元素赋值
    public final A a1;
    public final B a2;

    public Tuple2(A a1, B a2) {
        this.a1 = a1;
        this.a2 = a2;
    }

    public String rep() {
        return a1 + ", " + a2;
    }

    @Override
    public String toString() {
        return "（" + rep() + ")";
    }
}

```

> 构造函数传入要存储的对象。这个元组**隐式地保持了其中元素的次序**。

【泛型类型参数是与顺序相关的。】

> 初次阅读上面的代码时，你可能认为这违反了 Java 编程的**封装原则**。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
>
> **另一种设计思路**：是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，**采用上例中的形式无疑更加安全**，**如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。**
>
> 我们可以**利用继承机制实现长度更长的元组**。**添加更多的类型参数就行了**

**【意思是定义一个子类子类有自己的类型参数，然后继承这个父类，就有子类+父类的类型参数列表？**

**自己加的例子：】**

```java
// Tuple2Son
// 定义一个元组类的子类，这样就又多了一种C类型可以使用，但是缺点就是要明确父类的类型 
//public class Tuple2Son<C> extends Tuple2<String, Integer> {
public class Tuple2Son<C> extends Tuple2<String, Integer> {
    public C c;

    public Tuple2Son(String a1, Integer a2, C c) {
        super(a1, a2);
        this.c = c;
    }
}
```



【书上的例子】

```java
// onjava/Tuple3.java
package onjava;

public class Tuple3<A, B, C> extends Tuple2<A, B> {
    public final C a3;
    public Tuple3(A a, B b, C c) {
        super(a, b);
        a3 = c;
    }

    @Override
    public String rep() {
        return super.rep() + ", " + a3;
    }
}

// onjava/Tuple4.java
package onjava;

public class Tuple4<A, B, C, D>
  extends Tuple3<A, B, C> {
    public final D a4;
    public Tuple4(A a, B b, C c, D d) {
        super(a, b, c);
        a4 = d;
    }

    @Override
    public String rep() {
        return super.rep() + ", " + a4;
    }
}

// onjava/Tuple5.java
package onjava;

public class Tuple5<A, B, C, D, E>
  extends Tuple4<A, B, C, D> {
    public final E a5;
    public Tuple5(A a, B b, C c, D d, E e) {
        super(a, b, c, d);
        a5 = e;
    }

    @Override
    public String rep() {
        return super.rep() + ", " + a5;
    }
}
```

**【原来继承之后需要在子类中定义父类的类型参数，然后就可以不用指定父类的具体参数了。】**

> 演示需要，再定义两个类：

```java
// generics/Amphibian.java
public class Amphibian {}

// generics/Vehicle.java
public class Vehicle {}
```

> 使用元组时需要定义一个长度适合的元组，将其作为返回值即可。
>
> 注意下面例子中方法返回的类型：

```java
// TupleTest.java
public class TupleTest {
    static Tuple2<String, Integer> f() {
        // 47 自动装箱为 Integer
        return new Tuple2<>("hi", 47);
    }

    static Tuple3<Amphibian, String, Integer> g() {
        return new Tuple3<>(new Amphibian(), "hi", 47);
    }

    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
    }

    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }

    public static void main(String[] args) {
        Tuple2<String, Integer> ttsi = f();
        System.out.println(ttsi);

        //ttsi.a1 = "55"; // 编译错误 final 变量不能重新赋值
        System.out.println(g());
        System.out.println(h());
        System.out.println(k());
    }
}
/**
输出

```

【这个例子表示了有了DTO。可以很方便创建，并返回DTO中要封装的对象】

> 有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
>
> 通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
>
> **在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。**



#### 一个堆栈库

> 下面是一个稍微复杂的例子：堆栈。
>
> 在集合章节中，用 LinkedList 实现了 onjava.Stack 类。在那个例子中 LinkedList 本身已经具备了创建堆栈所需要的方法。 Stack 是通过两个泛型类 `Stack<T>` 和 `LinkedLIst<T>` 的组合来创建。
>
> 可以看出，泛型不过只是一种类型罢了。
>
> 这次不用 LinkedList，自己实现内部链式存储机制。

【那就得用数组来实现了吧】

```java
// generics/LinkedStack.java
// LinkedStack.java
public class LinkedStack<T> {
    // 再搞一个私有静态内部类 代表节点
    private static class Node<U> {
        U item;
        Node<U> next;

        public Node() {
            item = null;
            next = null;
        }

        public Node(U item, Node<U> next) {
            this.item = item;
            this.next = next;
        }

        boolean end() {
            return item == null && next == null;
        }

    }

    private Node<T> top = new Node<>(); // 栈顶

    // 入栈操作
    public void push(T item) {
        top = new Node<>(item, top);
    }

    // 出栈，同时判断 是否存在下一个 Node 如果存在，则将 top 指向下一个 Node
    public T pop() {
        T result = top.item;
        if (!top.end()) {
            top = top.next;
        }
        return result;
    }

    public static void main(String[] args) {
        LinkedStack<String> lss = new LinkedStack<>();
        for (String s : "Phasers on stun!".split(" ")) {
            lss.push(s);
        }
        // 打印栈内元素
        String s;
        while ((s = lss.pop()) != null) {
            System.out.println(s);
        }
    }
}
/**
输出
stun!
on
Phasers
先入后出
*/
```

> 内部类 Node 也是一个泛型，它拥有自己的类型参数。
>
> 这个例子使用了一个**末端标识(end sentinel)** 来判断栈何时为空。这个末端标识是在构造 LinkeStack 时创建的。然后每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。
>
> 当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>` ，并将 top 指向下一个 `Node<T>` ，除非到达末端，这时就不能继续移动 `top`了，此时再调用 `pop()` 方法只能得到 `null`。

#### RandomList

> 另一个容器的例子：假设需要一个持有特定类型对象的列表。**每次调用它的 select() 方法时都返回一个随机的元素。**
>
> 如果希望这种列表可以适用于任何类型，就需要使用泛型：

```java
// RandomList.java
public class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);

    // 随机获取一个元素
    public T select() {
        return get(rand.nextInt(size()));
    }

    public static void main(String[] args) {
        RandomList<String> rs = new RandomList<>();
        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
        IntStream.range(0, 11)
                .forEach(i -> System.out.print(rs.select() + " "));
    }
}

/**
输出
brown over fox quick quick dog brown The brown lazy brown 
*/
```



> `RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。

### 泛型接口

> 泛型也适用于**接口**。 例如**生成器【比如函数式接口 Supplier】**，这是一种**专门负责创建对象的类**，实际上这是 **工厂方法**
>
> 不过使用生成器创建新对象一般**不需要任何参数**【为什么？】，**而工厂方法一般需要参数**。
>
> 一般而言，生成器只定义一个方法，用于创建对象。 例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器。 调用其 `get()` 方法获取对象。 `get()` 是泛型方法，返回值为类型参数 `T`。
>
> 为了演示 Supplier 我们需要定义几个类：

```java
// generics/coffee/Coffee.java
package generics.coffee;

public class Coffee {
    private static long counter = 0;
    private final long id = counter++;

    @Override
    public String toString() {
        return getClass().getSimpleName() + " " + id;
    }
}


// generics/coffee/Latte.java
package generics.coffee;
public class Latte extends Coffee {}


// generics/coffee/Mocha.java
package generics.coffee;
public class Mocha extends Coffee {}


// generics/coffee/Cappuccino.java
package generics.coffee;
public class Cappuccino extends Coffee {}


// generics/coffee/Americano.java
package generics.coffee;
public class Americano extends Coffee {}


// generics/coffee/Breve.java
package generics.coffee;
public class Breve extends Coffee {}
```



【上面编写了一个咖啡爸爸和许多具体的咖啡种类】

> 现在，编写一个类，实现 Supplier<Coffee> 接口，让它能够随机生成不同类型的 Coffee 对象：

```java
// generics/coffee/CoffeeSupplier.java
// {java generics.coffee.CoffeeSupplier}
// 实现一个 Coffee 类的生成器
public class CoffeeSupplier implements Supplier<Coffee>, Iterable<Coffee> {
    // 定义所有 Coffee 类型的 Class类字面量数组
    private Class<?>[] types = {Latte.class, Mocha.class,
            Cappuccino.class, Americano.class, Breve.class};
    // 搞一个随机数
    private static Random rand = new Random(47);

    // 定义给迭代器使用的变量
    private int size = 0;

    public CoffeeSupplier() {}

    // 只是创建一个空的
    public CoffeeSupplier(int size) {
        this.size = size;
    }

    @Override
    public Iterator<Coffee> iterator() {
        return new CoffeeIterator();
    }

    @Override
    public Coffee get() {
        try {
            return (Coffee) types[rand.nextInt(types.length)].newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    class CoffeeIterator implements Iterator<Coffee> {

        int count = size;

        // 不支持该操作
        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }


        @Override
        public boolean hasNext() {
            return count > 0;
        }

        @Override
        public Coffee next() {
            count--;
            // 这里的 .this 指的是什么？
            return CoffeeSupplier.this.get();
        }
    }

    public static void main(String[] args) {
        Stream.generate(new CoffeeSupplier()) // Supplier 接口提供了生成对象的功能
                .limit(5)
                .forEach(System.out::println);
        System.out.println("------------");
      // 因为 CoffeeSupplier 实现了 Iterable 接口，所以可以使用 for-in遍历
        for (Coffee c : new CoffeeSupplier(5)) {
            System.out.println(c);
        }
    }
}

/**
输出
Americano 0
Latte 1
Americano 2
Mocha 3
Mocha 4
------------
Breve 5
Americano 6
Latte 7
Cappuccino 8
Cappuccino 9
*/


```

这里刚开始被  Iterator 中的    `return CoffeeSupplier.this.get();` 看懵了，说明内部类那块不扎实。

这里 `CoffeeSupplier.this` 的作用是调用 `CoffeeIterator` 的外部类 `CoffeeSupplier 的 get(`) 方法

**【R大的讲解非常的清晰】**

![image-20200311180112752](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200311180119.png)





> 
>
> 这里泛型接口 `Supplier` 确保了 `get()` 方法返回的值是`Coffee` 类型。
>
> **CoffeeSupplier 同时实现了 Iterable 接口，代表其可使用 for-in 语法遍历**。不过它还需要知道何时终止循环，这正是**第二个构造函数的作用**。

> 下面是另一个实现 `Supplier<T>` 接口的例子，它负责生产 **Fibonacci** 数列

```java
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584// generics/Fibonacci.java
// Generate a Fibonacci sequence
public class Fibonacci implements Supplier<Integer> {
    private int count = 0;


    @Override
    public Integer get() {
        return fib(count++);
    }

    // 生成斐波那契数列的算法
    private int fib(int n) {
        if (n < 2) {
            return 1;
        }
        return fib(n - 2) + fib(n - 1);
    }

    public static void main(String[] args) {
        Stream.generate(new Fibonacci())
                .limit(18)
                .map(n -> n + " ")
                .forEach(System.out::print);
    }
}
/**
输出
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
*/
```



> 这里可以看到虽然使用的一直是 int，但是 Supplier 的类型参数是 Integer 因为泛型无法使用基本类型作为参数。
>
> 不过由于 Java5 具备自动装箱和拆箱功能，编译器会自动帮我们将对象在基本类型和包装类型进行转换。
>
> 关于这个例子还可以更进一步，编写一个实现了 `Iterator` 迭代器的 斐波那契额数列生成器。但是当你无法修改源代码直接实现 Iterator 接口的时候的时候，还有另一个选择 —— **适配器模式**来实现所需接口。
>
> 多种方法可以实现适配器。例如可以通过继承来创建适配器类：

```java
// IterableFibonacci.java
// 继承生成斐波那契的类并使用适配器模式增加其Iterable特性，使其可以使用 for-in 算法
public class IterableFibonacci extends Fibonacci implements Iterable<Integer> {
    private int n;
		
  	
  	// 构造函数中的边界值。确定了 hasNext() 方法何时返回 false
    public IterableFibonacci(int count) {
        n = count;
    }

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            @Override
            public boolean hasNext() {
                return n > 0;
            }

            @Override
            public Integer next() {
                n--;
                // 通过 Supplier 的 get() 生成 斐波那契数列
                return IterableFibonacci.this.get();
            }

            // 不支持的操作
            @Override
            public void remove() { // Not implemented
                throw new UnsupportedOperationException();
            }
        };
    }

    public static void main(String[] args) {
        for (int i : new IterableFibonacci(18)) {
            System.out.print(i + " ");
        }
    }
}
/**
输出
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 
*/
```

> 在 for-in 语句中 迭代 IterableFIbonacci，必须在**构造函数**中提供一个边界值，这样 hasNext() 才知道何时返回  false 结束循环。

**【这里两次都提到了 边界值与结束循环这个概念，因为迭代要有结束的条件，这里需要覆写 iterator 接口的 hasNext 来返回 false 从而结束迭代，返回 false 的依据就是 构造函数中的 n。 】**



