---
layout: post
title: 《On Java8》第二十一章——数组(4)
date: 2020-03-10 00:22:03
tags:
- 读书笔记
categories: 
- 《On Java8》
---




### 数组拷贝

> 与使用 for 循环手工执行复制相比， copyOf() 和 copyOfRange() 复制数组要快很快。 这些方法被重载以处理所有类型。
>
> <!-- more -->	

```java
// ArrayCopying.java
class Sup {
    private int id;

    public Sup(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + id;
    }
}

class Sub extends Sup {
    public Sub(int id) {
        super(id);
    }
}


public class ArrayCopying {
    public static final int SZ = 15;

    public static void main(String[] args) {
        int[] a1 = new int[SZ];

        Arrays.setAll(a1, new Count.Integer()::get);

        show("a1", a1);

        int[] a2 = Arrays.copyOf(a1, a1.length);

        // 证明 a1 a2 是不同的数组：
        Arrays.fill(a1, 1); // 将 a1 的所有元素改为1
        show("a1", a1);
        show("a2", a2);
        // 将 a2 数组的长度进行扩容 没有被初始化的元素都是默认值 0
        a2 = Arrays.copyOf(a2, a2.length + 5);
        show("a2", a2);

        // 对包装类进行 Copy
        Integer[] a3 = new Integer[SZ];
        Arrays.setAll(a3, new Count.Integer()::get);
        show("a3", a3);
        Integer[] a4 = Arrays.copyOfRange(a3, 4, 12); // 左闭右开 (] 5-12
        show("a4", a4);
        a4 = Arrays.copyOf(a4, a4.length + 5);
        show("a4 after expansion ", a4);

        Sub[] d = new Sub[SZ / 2];
        Arrays.setAll(d, Sub::new);
        show("d", d);
        // 拷贝子类数组转为父类引用
        Sup[] b = Arrays.copyOf(d, d.length, Sup[].class);//[4]
        show("b",b); // 这里打印的元素还是具体的子类类型，没有向上转型打印出父类 Sup

        Sub[] d2 = Arrays.copyOf(b, b.length, Sub[].class);
        show("d2",d2);
        Sup[] b2 = new Sup[SZ / 2];
        Arrays.setAll(b2, Sup::new);
        show("b2", b2);
         try {
            Sub[] d3 = Arrays.copyOf(b2, b2.length, Sub[].class); //[6]
        } catch (Exception e) {
            System.out.println(e);
        }

    }
}
/**
输出
a1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
a1: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
a2: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
a2: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 0, 0, 0, 0]
a3: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
a4: [4, 5, 6, 7, 8, 9, 10, 11]
a4 after expansion : [4, 5, 6, 7, 8, 9, 10, 11, null, null, null, null, null]
d: [Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6]
b: [Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6]
d2: [Sub0, Sub1, Sub2, Sub3, Sub4, Sub5, Sub6]
b2: [Sup0, Sup1, Sup2, Sup3, Sup4, Sup5, Sup6]
java.lang.ArrayStoreException
*/
```



> [1] 这是复制的**基本方法**;只需给出**返回的复制数组的大小**。这对于**编写需要调整存储大小的算法很有帮助**。复制之后，我们把a1的所有元素都设为1，以证明a1的变化不会影响a2中的任何东西。
>
> [2] 通过更改最后一个参数，我们可以缩短或延长返回的复制数组。**【修改拷贝数组的长度】**
>
> [3] **copyOf()** 和 **copyOfRange()** 也可以使用包装类型。**copyOfRange()** 需要一个开始和结束索引。**【复制数组的一个子集】**
>
> [4] **copyOf()** 和 **copyOfRange()** 都有一个版本，该版本通过在方法调用的**末尾添加目标类型**来创建不同类型的数组。我首先想到的是，这可能是**一种从原生数组生成包装数组的方法**， **反之亦然**。 但这没用。它的**实际用途是“向上转换”和“向下转换”数组**。也就是说，如果您有一个子类型(派生类型)的数组，而您想要一个基类型的数组，那么这些方法将生成所需的数组。
>
> [5] 您甚至可以成功地“**向下强制转换**”，并从超类型的数组生成子类型的数组。这个版本运行良好，因为我们只是“upcast”。
>
> [6] 这个“数组转换”将编译，但是如果**类型不兼容**，您将得到一个**运行时异常**。在这里，**强制将基类型转换为派生类型是非法的**，**因为派生对象中可能有基对象中没有的属性和方法**。
>
> 实例表明，原生数组和对象数组都可以被复制。但是，如果复制对象的数组，那么只复制引用—不复制对象本身。这称为浅拷贝(有关更多细节，请参阅附录:传递和返回对象)。
>
> 还有一个方法 **System.arraycopy()** ，它将一个数组复制到另一个已经分配的数组中。这将不会执行自动装箱或自动卸载—两个数组必须是完全相同的类型。


### 数组比较

> 数组提供了 `equals()` 比较一维数组 和 `deepEquals()` 比较多维数组。对于所有原生类型和对象，这些方法都是**重载**的。
>
> **数组相等的含义**：数组必须有**相同数量的元素**，并且**每个元素必须与另一个数组中的对应元素相等**，对每个元素使分别调用 `equasl()` 方法，对于基本类型，调用基本类型的包装类的 `equals()` 方法。 例如 `int` 的 `Integer.eqauls()`

```java
// ComparingArrays.java
public class ComparingArrays {
    public static final int SZ = 15;

    // 初始化二维数组
    static String[][] twoDArray() {
        String[][] md = new String[5][];
        Arrays.setAll(md, n -> new String[n]);
        for (int i = 0; i < md.length; i++) {
            Arrays.setAll(md[i], new Rand.String()::get);
        }
        return md;
    }

    public static void main(String[] args) {
        // 初始化两个 int[] a1,a2
        int[] a1 = new int[SZ], a2 = new int[SZ];

        // 分别填充两个数组
        Arrays.setAll(a1, new Count.Integer()::get);
        Arrays.setAll(a2, new Count.Integer()::get);

        // 判断 a1 a2 是否相等
        System.out.println("a1 == a2: " + Arrays.equals(a1,a2));

        // 修改一个元素后再进行比较
        a2[3] = 11;
        System.out.println("a1 == a2: " + Arrays.equals(a1,a2));

        // 初始化两个 int 包装类的数组
        Integer[] a1w = new Integer[SZ], a2w = new Integer[SZ];

        Arrays.setAll(a1w, new Count.Integer()::get);
        Arrays.setAll(a2w, new Count.Integer()::get);

        System.out.println("a1w == a2w: " + Arrays.equals(a1w, a2w));

        a2w[3] = 11;
        System.out.println("a1w == a2w: " + Arrays.equals(a1w, a2w));

        // 初始化二维字符串数组
        String[][] md1 = twoDArray(), md2 = twoDArray();

        System.out.println("md1: " + Arrays.deepToString(md1));
        System.out.println("md2: " + Arrays.deepToString(md2));
        System.out.println("deepEquals(md1, md2): " + Arrays.deepEquals(md1, md2));
        System.out.println("md1 == md2: " + Arrays.equals(md1, md2)); // 使用普通的数组比较方法
        md1[4][1] = "#$#$#$#";
        System.out.println(Arrays.deepToString(md1));
        System.out.println("deepEquals(md1, md2): " + Arrays.deepEquals(md1, md2));
    }
}

/**
输出
a1 == a2: true
a1 == a2: false
a1w == a2w: true
a1w == a2w: false
md1: [[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv, gmeinne], [btpenpc, cuxszgv, gmeinne, eloztdv]]
md2: [[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv, gmeinne], [btpenpc, cuxszgv, gmeinne, eloztdv]]
deepEquals(md1, md2): true
md1 == md2: false
[[], [btpenpc], [btpenpc, cuxszgv], [btpenpc, cuxszgv, gmeinne], [btpenpc, #$#$#$#, gmeinne, eloztdv]]
deepEquals(md1, md2): false
*/

```

> 这个例子就是简单的数组比较例子，值得注意的是如果使用普通的数组比较方法去做多维数组的比较的话，返回的会是错误的结果【废话。。】



### 流和数组

> **`stream()`** 方法很容易从某些类型的数组中生成元素流。

```java
// StreamFromArray.java
public class StreamFromArray {
    public static void main(String[] args) {
        String[] s = new Rand.String().array(10);

        Arrays.stream(s)
                .skip(3)
                .limit(5)
                .map(ss -> ss + "!")
                .forEach(System.out::println);

        int[] ia = new Rand.Pint().array(10);

        Arrays.stream(ia).skip(3).limit(5)
                .map(i -> i * 10).forEach(System.out::println);

        Arrays.stream(new long[10]);
        Arrays.stream(new double[10]);

        // 只有 int、long、double 可以正常工作
        // - Arrays.stream(new boolean[10]);
        // - Arrays.stream(new byte[10]);
        // - Arrays.stream(new char[10]);
        // - Arrays.stream(new short[10]);
        // - Arrays.stream(new float[10]);
        // 上面的都没有支持
        // For the other types you must use wrapped arrays:
        // 对于其他的基础类型必须使用包装类来创建流
        float[] fa = new Pfloat().array(10);
        Arrays.stream(ConvertTo.boxed(fa)); // 基本类型转包装类
        Arrays.stream(new Rand.Float().array(10));
    }
}
/**
输出
eloztdv!
ewcippc!
ygpoalk!
ljlbynx!
taprwxz!
47200
61770
84790
66560
37680
*/
```

> 基础类型中只有 **int**、**long**、和 **double** 可以与 **Arrays.stream()** 一起使用，其他类型必须获取包装类型的数组然后才能转换成流。

> 通常，将数组转换成流来生成所需要的结果比直接操作数组要容易得多。
>
> 但是需要注意流不能重复消费，而你仍然拥有数组——你可以使用数组生成另一个流。

### 数组排序

> **根据对象的实际类型执行比较排序。**一种方法是为不同的类型编写对应的排序方法，但是这样的代码不能复用
>
> 编程设计的一个主要目标是将"易变的元素与稳定的元素分开"【也就是**封装变化**，找到稳定的和不变的】，在这里，保持**不变**的代码是一般的**排序算法**，**变化**的是**对象的比较方式**。
>
> 因此，使用**策略模式**而不是将比较代码放入许多不同的排序源码中。使用策略模式时，变化的代码部分被封装在一个单独的类（策略对象）中。
>
> Java 有两种方式提供比较功能：
>
> - 实现 java.lang.Comparable 接口的原生方法。这是一个简单接口，只包含一个方法 compareTo()。该方法接受另一个与参数类型相同的对象作为参数如果当前对象小于参数，则产生一个负值，等于则返回0，大于产生一个正数。
> - 自己编写比较器
>
> 这里有一个实现了 Comparable 的接口并演示了可比性，使用 JDK Arrays.sort();

```java
// CompType.java
public class CompType implements Comparable<CompType> {
    private static int count = 1;
    private static SplittableRandom r = new SplittableRandom(47);
    int i;
    int j;

    // 构造函数
    public CompType(int i, int j) {
        this.i = i;
        this.j = j;
    }

    // 随机构造 CompType
    public static CompType get() {
        return new CompType(r.nextInt(100), r.nextInt(100));
    }


    @Override
    public String toString() {
        String result = "[i = " + i + "," + "j = " + j + "]";
        if (count++ % 3 == 0) {
            result += "\n";
        }
        return result;
    }

    @Override
    public int compareTo(CompType rv) {
        return (i < rv.i ? -1 : (i == rv.i ? 0 : 1));
    }

    public static void main(String[] args) {
        CompType[] a = new CompType[12];
        Arrays.setAll(a, n -> get());
        show("排序前 ComType数组：", a);
        Arrays.sort(a);
        show("排序后 ComType数组：", a);
    }
}
/**
输出
排序前 ComType数组：: [[i = 35,j = 37], [i = 41,j = 20], [i = 77,j = 79]
, [i = 56,j = 68], [i = 48,j = 93], [i = 70,j = 7]
, [i = 0,j = 25], [i = 62,j = 34], [i = 50,j = 82]
, [i = 31,j = 67], [i = 66,j = 54], [i = 21,j = 6]
]
排序后 ComType数组：: [[i = 0,j = 25], [i = 21,j = 6], [i = 31,j = 67]
, [i = 35,j = 37], [i = 41,j = 20], [i = 48,j = 93]
, [i = 50,j = 82], [i = 56,j = 68], [i = 62,j = 34]
, [i = 66,j = 54], [i = 70,j = 7], [i = 77,j = 79]
]
*/
```

> 当定义比较方法的时候，一定要决定怎样比较两个对象的大小，在例子中只比较 i 的值， j被忽略。

同时这里比较 IDEA提示我们代表可以进行优化：

![image-20200309170716302](/Users/xuyanxin/Library/Application Support/typora-user-images/image-20200309170716302.png)

可以看到 Integer 实现了这个比较的方法，优化为：

```java
(i < rv.i ? -1 : (i == rv.i ? 0 : 1)); // 优化前，自己编写的
Integer.compare(i, rv.i) // jdk中自带的
```

**源码：**

```java
// Integer.java
public static int compare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }
```

> get() 方法通过使用随机值初始化 ComType 对象来构建它们。 在 main() 中，get() 与 Arrays.setAll() 一起使用。以填充一个 CompType 类型的数组，然后对其进行排序。
>
> 如果没有实现 Comparable 接口，那么当试图调用 sort() 方法时，将获得一个运行时异常，因为 sort() 方法需要将参数转为 **Comparable** 类型



【我们创建一个没有实现 Comparable 的类 然后试试】

![image-20200309171114370](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200309171114.png)

【确实是抛出了类转换异常】

**【源码里在这里对参数进行了强转，如果没有实现接口则报错】**：

![image-20200309171148880](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200309171148.png)

### Arrays.sort() 的使用

> 使用 JDK 内置的排序方法。可以实现**Comparable** 接口 或 具有 **Comparator** 的任何对象数组 或 任何原生数组进行排序。
>
> 这里是一个生成随机字符串对象数组并对其排序的例子：

```java
// arrays/StringSorting.java
public class StringSorting {
    public static void main(String[] args) {
        String[] sa = new Rand.String().array(20);
        show("排序之前", sa);

        Arrays.sort(sa);
        show("排序之后", sa);

        Arrays.sort(sa, Collections.reverseOrder());
        show("Reverse Sort 之后",sa);

        Arrays.sort(sa,String.CASE_INSENSITIVE_ORDER); // 无论大小写，将单词组合在一起的排序
        show("Case-insensitive排序",sa);

    }
}

/**
输出
排序之前: [btpenpc, cuxszgv, gmeinne, eloztdv, ewcippc, ygpoalk, ljlbynx, taprwxz, bhmupju, cjwzmmr, anmkkyh, fcjpthl, skddcat, jbvlgwc, mvducuj, ydpulcq, zehpfmm, zrxmclh, qgekgly, hyoubzl]
排序之后: [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl, jbvlgwc, ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]
Reverse Sort 之后: [zrxmclh, zehpfmm, ygpoalk, ydpulcq, taprwxz, skddcat, qgekgly, mvducuj, ljlbynx, jbvlgwc, hyoubzl, gmeinne, fcjpthl, ewcippc, eloztdv, cuxszgv, cjwzmmr, btpenpc, bhmupju, anmkkyh]
Case-insensitive排序: [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl, jbvlgwc, ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, ydpulcq, ygpoalk, zehpfmm, zrxmclh]
*/
```

> 注意**字符串排序算法中的输出**。它是**字典式**的，所以它把所有以**大写字母开头的单词**放在前面，**然后是所有以小写字母开头的单词**。(电话簿通常是这样分类的。)**无论大小写**，要将单词组合在一起，请使用 `String.CASE_INSENSITIVE_ORDER` ，如对`sort()`的最后一次调用所示。
>
> JDK 标准库中使用的排序算法被设计为最适合正在排序的类型的 基**础类型的快速排序** 和**对象的归并排序**。

**String.CASE_INSENSITIVE_ORDER源码**

```java
    /**
			一个由compareToIgnoreCase排序String对象的比较器。 该比较器是可序列化的。
请注意，该比较器未考虑语言环境，并且会导致某些语言环境的排序不理想。 java.text包提供了Collators以允许对语言环境敏感的排序。
     */
    public static final Comparator<String> CASE_INSENSITIVE_ORDER
                                         = new CaseInsensitiveComparator();

// CaseInsensitiveComparator 的具体实现

 private static class CaseInsensitiveComparator
            implements Comparator<String>, java.io.Serializable {
        // use serialVersionUID from JDK 1.2.2 for interoperability
        private static final long serialVersionUID = 8575799808933029326L;

        public int compare(String s1, String s2) {
            int n1 = s1.length();
            int n2 = s2.length();
            int min = Math.min(n1, n2);
            for (int i = 0; i < min; i++) {
                char c1 = s1.charAt(i);
                char c2 = s2.charAt(i);
                if (c1 != c2) {
                    c1 = Character.toUpperCase(c1);
                    c2 = Character.toUpperCase(c2);
                    if (c1 != c2) {
                        c1 = Character.toLowerCase(c1);
                        c2 = Character.toLowerCase(c2);
                        if (c1 != c2) {
                            // No overflow because of numeric promotion
                            return c1 - c2;
                        }
                    }
                }
            }
            return n1 - n2;
        }

   
```

【可以看到是将两个字符串转为 char 之后先转大写，再转小写，最后返回 c1 - c2 的结果。】



### 并行排序

> 如果排序性能是问题，那么可以使用 Java 8的 并行排序 **`parallelSort()`**，它为所有不可预见的情况（包括数组的排序区域，或使用了比较器）提供了重载版本。为了查看相比于普通的 sort() ，parallelSort() 的优点，下面使用了用来验证代码的 **JMH**：

```java
// ParallelSort.java
// 这里书上的例子并不完整，我看了下例程代码库，也找不到调用 Benchmakr 的地方，于是自己去找了下网上的例子。
@State(Scope.Thread)
@BenchmarkMode(Mode.AverageTime)
public class ParallelSort {
    private long[] la;

    @Setup
    public void setup(){
        la = new Rand.Plong().array(100_000000);
    }

    @Benchmark
    public void sort() {
        Arrays.sort(la);
    }

    @Benchmark
    public void parallelSort() {
        Arrays.parallelSort(la);
    }
	
  // 调用测试用例的地方
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(ParallelSort.class.getSimpleName())
                .forks(1)
                .warmupIterations(5)
                .measurementIterations(5)
                .build();

        new Runner(opt).run();
    }

}
/**
输出
# JMH 1.14.1 (released 1266 days ago, please consider updating!)
# VM version: JDK 1.8.0_172, VM 25.172-b11
# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home/jre/bin/java
# VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=53952:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: arrays.jmh.ParallelSort.parallelSort

# Run progress: 0.00% complete, ETA 00:00:20
# Fork: 1 of 1
# Warmup Iteration   1: 1.393 s/op
# Warmup Iteration   2: 0.989 s/op
# Warmup Iteration   3: 0.995 s/op
# Warmup Iteration   4: 1.004 s/op
# Warmup Iteration   5: 1.299 s/op
Iteration   1: 0.999 s/op
Iteration   2: 0.996 s/op
Iteration   3: 1.014 s/op
Iteration   4: 1.224 s/op
Iteration   5: 0.997 s/op


Result "parallelSort":
  1.046 ±(99.9%) 0.384 s/op [Average]
  (min, avg, max) = (0.996, 1.046, 1.224), stdev = 0.100
  CI (99.9%): [0.662, 1.430] (assumes normal distribution)


# JMH 1.14.1 (released 1266 days ago, please consider updating!)
# VM version: JDK 1.8.0_172, VM 25.172-b11
# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home/jre/bin/java
# VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=53952:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: arrays.jmh.ParallelSort.sort

# Run progress: 50.00% complete, ETA 00:00:17
# Fork: 1 of 1
# Warmup Iteration   1: 4.876 s/op
# Warmup Iteration   2: 0.702 s/op
# Warmup Iteration   3: 0.697 s/op
# Warmup Iteration   4: 0.746 s/op
# Warmup Iteration   5: 0.860 s/op
Iteration   1: 0.788 s/op
Iteration   2: 0.771 s/op
Iteration   3: 0.733 s/op
Iteration   4: 0.766 s/op
Iteration   5: 0.761 s/op


Result "sort":
  0.764 ±(99.9%) 0.076 s/op [Average]
  (min, avg, max) = (0.733, 0.764, 0.788), stdev = 0.020
  CI (99.9%): [0.688, 0.840] (assumes normal distribution)


# Run complete. Total time: 00:00:38

Benchmark                  Mode  Cnt  Score   Error  Units
ParallelSort.parallelSort  avgt    5  1.046 ± 0.384   s/op
ParallelSort.sort          avgt    5  0.764 ± 0.076   s/op


*/
```

> **parallelSort() 算法将大数组拆分成更小的数组**，直到数组大小达到极限，然后使用普通的 **Arrays .sort()** 方法。然后**合并结果**。**该算法需要不大于原始数组的额外工作空间。**
>
> 您可能会看到不同的结果，但是在我的机器上，并行排序将速度提高了大约3倍。由于并行版本使用起来很简单，所以很容易考虑在任何地方使用它，而不是 **Arrays.sort ()**。当然，它可能不是那么简单—看看微基准测试。



**【这里让人迷惑的是:**

**1、作者的例子没有给完，我并不知道怎样运行这个测试用例**

**2、并行排序比普通排序还要慢。。。，并且数据越大，慢的越多**

**3、 使用这个例子还需要引入 jmh 的maven 依赖】**

```xml
 <jmh.version>1.14.1</jmh.version>
  <!--  OpenJDK 基准测试依赖  -->
    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-core</artifactId>
      <version>${jmh.version}</version>
    </dependency>

    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-generator-annprocess</artifactId>
      <version>${jmh.version}</version>
      <scope>provided</scope>
    </dependency>
```

[JMH基本使用](https://blog.dyngr.com/blog/2016/10/29/introduction-of-jmh/)

### binarySearch 二分查找

> 一旦数组被排序，就可以使用 Arrays.binarySearch() 执行对特定项的快速搜索。
>
> 如果尝试在未排序的数组上使用 binarySearch() ，则**结果不可预测**。
>
> 下面的例子是 Rand.Pint类 创建一个填充随机整数的数组，然后使用 getAsInt(因为 Rand.Pint是一个 IntSupplier) 来产生搜索值

```java
// ArraySearching.java
public class ArraySearching {
    public static void main(String[] args) {
        Rand.Pint rand = new Rand.Pint();

        int[] a = new Pint().array(25);
        Arrays.sort(a);
        show("排序后的数组",a);
        while (true) {
            int r = rand.getAsInt();
            int location = Arrays.binarySearch(a, r);
            if (location >= 0) {
                System.out.println("Location of  " + r + "所在的位置: " + location);
                break;
            }
        }

    }
}

/**
输出
排序后的数组: [125, 267, 635, 650, 1131, 1506, 1634, 2400, 2766, 3063, 3768, 3941, 4720, 4762, 4948, 5070, 5682, 5807, 6177, 6193, 6656, 7021, 8479, 8737, 9954]
Location of  635所在的位置: 2
*/
```

> While 循环中，随机值作为搜索项生成，直到在数组中找到其中一个位置。
>
> 找到后 **Arrays.binarySearch()**  将返回一个大于等于0的值，否则返回一个负值，表示如果手动维护已排序的数组，则应该插入元素的位置。产生的值是 （插入点） -1。插入点是大于键的第一个元素的索引，如果数组中的所有元素都小于指定的键，则是 **a.size()**。
>
> 如果数组包含重复元素，则无法保证找到其中重复的项。**搜索算法不是为了支持重复的元素，而是为了容忍他们。**如果需要没有重复元素的排列表，可以使用 **TreeSet（用于维持排序顺序）** 这个数据结构 或 **LinkedHashSet（用于维持插入顺序）。**
>
> 这些类将自动为你处理细节，只有当性能出现瓶颈的情况下，才应该使用手工维护的数组替换这些类中的一个。
>
> 如果使用比较器（**原始数组不允许使用比较器进行排序**）对对象数组进行排序，在执行 binariSearch() （使用重载版本的 `binarySearch()` 时必须包含**相同的比较器**）【这句话很重要】
>
> 例如，可以修改 `StringSorting.java` 来执行搜索：



```java
// arrays/AlphabeticSearch.java
public class AlphabeticSearch {
    public static void main(String[] args) {
        String[] sa = new Rand.String().array(30);
        Arrays.sort(sa,String.CASE_INSENSITIVE_ORDER);
        show(sa);
        int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER);
        System.out.println("Index: " + index + "\n" + sa[index]);
    }
}
/**
输出
[anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv, ewcippc, ezdeklu, fcjpthl, fqmlgsh, gmeinne, hyoubzl, jbvlgwc, jlxpqds, ljlbynx, mvducuj, qgekgly, skddcat, taprwxz, uybypgp, vjsszkn, vniyapk, vqqakbm, vwodhcf, ydpulcq, ygpoalk, yskvett, zehpfmm, zofmmvm, zrxmclh]
Index: 10
gmeinne
*/
```

> 比较器本身必须作为第三个参数传递给重载的 `binarySearch()`。在本例中，成功是有保证的，因为搜索项是从数组本身中选择的。



### parallePrefix 并行前缀

> 没有 `prefix()` 方法，只有 parallelPrefix()。这类似于 Stream 类中的 reduce() 方法：**它对前一个元素和当前一个元素执行一个操作，并将结果放入当前元素的位置。**

```java
//ParallelPrefix1.java
public class ParallelPrefix1 {
    public static void main(String[] args) {
        int[] nums = new Count.Pint().array(10);
        show(nums);
        // 0 - 9 求和
        System.out.println(Arrays.stream(nums).reduce(Integer::sum).getAsInt());
        Arrays.parallelPrefix(nums,Integer::sum);
        show(nums);
        // 0 - 5 求和
        System.out.println(Arrays.stream(new Count.Pint().array(6)).reduce(Integer::sum).getAsInt());
    }
}
/**
输出
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
45
[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
15
*/
```

> 这里对数组应用 `Integer::sum` ，就是对数组中的元素求和。在位置0中，它将先前计算的值（因为没有先前的值）与原始数组位置0中的值组合在一起。 
>
> 在位置1中，它获取之前计算的值，它只是存储在位置0中，并将其与位置1中先前计算的值相结合。依次往复。
>
> 使用 `Stream.reduce()` ，只能得到**最终结果**，而使用 `Arrays.parallelPrefix()` 还可以**得到所有中间计算**，以确保它们是有用的。
>
> **注意，第二个 Stream.reduce() 计算的结果已经在 parallelPrefix() 计算的数组中。**

> 下面是一个使用字符串的例子：

```java
// ParallelPrefix2.java
public class ParallelPrefix2 {
    public static void main(String[] args) {
        // 生成8个长度为1个的数组
        String[] strings=new Rand.String(1).array(8);
        show(strings);
        // 元素相加
        Arrays.parallelPrefix(strings,(a,b) -> a + b);
        show(strings);
    }
}
/**
输出
[b, t, p, e, n, p, c, c]
[b, bt, btp, btpe, btpen, btpenp, btpenpc, btpenpcc]
*/
```

确实使用字符串更加清楚。

> 使用流进行初始化非常优雅，但是对于大型数组，这种方法可能耗尽堆空间。使用 **`setAll()`** 执行**初始化更节省内存**。

```java
// arrays/ParallelPrefix3.java
// {ExcludeFromTravisCI}

import java.util.Arrays;

public class ParallelPrefix3 {
    static final int SIZE = 10_000_000;

    public static void main(String[] args) {
        long[] nums = new long[SIZE];
        Arrays.setAll(nums, n -> n);
        Arrays.parallelPrefix(nums, Long::sum);
        System.out.println("First 20: " + nums[19]);
        System.out.println("First 200: " + nums[199]);
        System.out.println("All: " + nums[nums.length - 1]);
    }
}
/* Output:
First 20: 190
First 200: 19900
All: 49999995000000
*/
```

> 正确使用 parallelPrefix() 可能相当复杂，所以通常应该只在存在 内存 或 速度问题（或两者皆有）时使用。否则 Stream.reduce() 应该是首选。

### 小结

介绍了很多数组与流的 API ，以及 数组的排序查找操作。

学习数组是为了学习集合或遇到性能问题时能够以更底层的手段解决问题。

同时并行操作不应该成为首选，这种操作的后果有时无法预知。

> **Java为固定大小的低级数组提供了合理的支持**。这种数组强调的是性能而不是灵活性，就像C和c++数组模型一样。在Java的最初版本中，固定大小的低级数组是绝对必要的，这不仅是因为Java设计人员选择包含原生类型(也考虑到性能)，还因为那个版本对集合的支持非常少。因此，在早期的Java版本中，选择数组总是合理的。
>
> **在Java的后续版本中，集合支持得到了显著的改进，现在集合在除性能外的所有方面都优于数组**，即使这样，集合的性能也得到了显著的改进。正如本书其他部分所述，无论如何，性能问题通常不会出现在您设想的地方。
>
> 使用自动装箱和泛型，在集合中保存原生类型是毫不费力的，这进一步鼓励您用集合替换低级数组。由于泛型产生类型安全的集合，数组在这方面也不再有优势。
>
> 如本章所述，当您尝试使用泛型时，您将看到泛型对数组是相当不友好的。通常，即使可以让泛型和数组以某种形式一起工作(在下一章中您将看到)，在编译期间仍然会出现“unchecked”警告。
>
> 有几次，当我们讨论特定的例子时，我直接从Java语言设计人员那里听到我应该使用集合而不是数组(我使用数组来演示特定的技术，所以我没有这个选项)。
>
> 所有这些问题都表明，在使用Java的最新版本进行编程时，应该“优先选择集合而不是数组”。只有当您证明性能是一个问题(并且切换到一个数组实际上会有很大的不同)时，才应该重构到数组。这是一个相当大胆的声明，但是有些语言根本没有固定大小的低级数组。它们只有可调整大小的集合，而且比C/C++/java风格的数组功能多得多。