### 泛型方法

> **方法是否为泛型类型与类是否为泛型无关。**【即便类不是泛型类，方法也可以是泛型的】
>
> 泛型方法独立于类。作为准则，应尽可能使用通用性更强的泛型方法。
>
> **静态方法无法访问该类的泛型类型参数。**因此，如果使用了泛型类型参数，则它必须是泛型方法。

![image-20200312105114805](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200312105114.png)

> 语法：**泛型参数列表定义在方法返回值之前。**

```java
// generics/GenericMethods.java
public class GenericMethods {
  	// 打印类型参数的类名称
    public <T> void f(T t) {
        System.out.println(t.getClass().getSimpleName());
    }

    public static void main(String[] args) {
        GenericMethods gc = new GenericMethods();
        gc.f("");
        gc.f(1);
        gc.f(1.0);
        gc.f('c');
        gc.f(gc);
    }
}
/**
输出
String
Integer
Double
Character
GenericMethods
*/
```



> 这里**方法是泛型方法**，**类没有类型参数，是普通类**。
>
> 对于泛型类，**必须在实例化该类时指定类型参数**。**使用泛型方法时，通常不需要指定参数类型**，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
>
> 如果使用基本类型调用 f() ，则自动装箱开始工作，自动将基本类型转换为对应的包装类型。

![image-20200312105530579](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200312105530.png)

【 **泛型方法如果要指定参数类型则在调用对象后指定.**】



#### 变长参数和泛型方法

> **泛型方法**和**变长参数列**表可以很好地共存：

```java
// generics/GenericVarargs.java
public class GenericVarags {


    public static <T> List<T> makeList(T... args) {
        ArrayList<T> result = new ArrayList<>();

        for (T item : args) {
            result.add(item);
        }
        return result;
    }

    public static void main(String[] args) {
        List<String> ls = makeList("A");
        System.out.println(ls);
        ls = makeList("A", "B", "C");
        System.out.println(ls);
        ls = makeList(
                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
        System.out.println(ls);

        // 个人添加
        List<Object> mixUp = makeList("A", 1, 1.0, new GenericVarags());
        System.out.println(mixUp);
    }
}

```

> 此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
>
> `@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。

![image-20200312110916847](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200312110916.png)

#### 一个泛型的 Supplier

> 这是一个为任意具有无参构造方法生成 `Supplier` 的类。 为了减少键入，它还包括一个用于**生成** `BasicSupplier` 的泛型方法

```java
// onjava/BasicSupplier.java
// Supplier from a class with a no-arg constructor
public class BasicSupplier<T> implements Supplier<T> {

    // 所包含的类对象
    private Class<T> type;

    public BasicSupplier(Class<T> type) {
        this.type = type;
    }

    @Override
    public T get() {
        try { // 通过 Class 类型创建对应类的对象
            return type.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    // 生成一个默认的 Supplier
    public static <T> Supplier<T> create(Class<T> type) {
        return new BasicSupplier<>(type);
    }
}

```

> 这个类的作用：
>
> 1. 是 `public` 权限类，因为这个类在单独的工具类包中，所以相关类必须具有 `public` 权限，而不仅仅是包级访问权限。
> 2. 具有无参构造方法**【这里的无参构造方法指的是 create() 方法】**。要创建 BasicSupplier 对象，则调用 create() 方法。并将要生成类的类型对象传递给它。 通用的 create() 方法提供了 `BasicSupplier.create(MyType.class)` 这种较为简洁的方法来替代笨拙的 `new BasicSupplier<MyType>(MyType.class)`

> 例如，这是一个具有无参构造方法的简单类：

```java
// CountedObject.java
// id 自增的计数类
public class CountedObject {
    private static long counter = 0;
    private final long id = counter++;

    public long id() {
        return id;
    }

    @Override
    public String toString() {
        return "Counted Object " + id;
    }
}
```

> CountedObject 类可以跟踪自身创建了多少实例，并通过 toString() 方法报告这些实例的数量。
>
> BasicSupplier 可以轻松地为 CountedObject 创建 Supplier：

**【然后通过 Supplier 作为类的生成器，轻松生成对应类的实例】**	

```java
// generics/BasicSupplierDemo.java
public class BasicSupplierDemo  {
    public static void main(String[] args) {
        Stream.generate(BasicSupplier.create(CountedObject.class))
                .limit(5)
                .forEach(System.out::println);
    }
}
/**
输出
Counted Object 0
Counted Object 1
Counted Object 2
Counted Object 3
Counted Object 4
*/
```

> **泛型方法减少了 Supplier 对象所需要的代码量**。 Java 泛型强制传递 Class 对象，以便在 create() 方法中将其用于类型判断。

![image-20200312114626707](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200312114626.png)

**【create() 方法就是对待参构造方法的封装，符合 《EffectiveJava》 中的 使用静态工厂替代构造函数思想，因为工厂可以命名为更具语义化的名字】**



#### 简化元祖的使用

> 使用类型参数推断和静态导入，我们将早起的元组重写为更通用的库。这里使用重载的静态方法创建元组：

```java
// 使用5个重载的静态泛型方法生成不同的元组对象
public class Tuple {

    // 创建一个包含2种对应入参类型的 Tuple2 元组对象
    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
        return new Tuple2<>(a, b);
    }

    // 这里返回值后面跟的泛型其实不属于方法泛型的范畴，而是给返回的 Tuple3 对象定义为泛型类，而不是 RawType
    // 我第一次看到的时候还以为是方法泛型的一部分，所以有点懵逼
    public static <A, B, C> Tuple3<A, B, C> tuple(A a, B b, C c) {
        return new Tuple3<>(a, b, c);
    }

    public static <A, B, C, D> Tuple4<A, B, C, D> tuple(A a, B b, C c, D d) {
        return new Tuple4<>(a, b, c, d);

    }

    public static <A, B, C, D, E>
    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
        return new Tuple5<>(a, b, c, d, e);
    }

}

```



> 修改 `TupleTest.java` 来测试 `Tuple.java`

```java
// TupleTest2.java
public class TupleTest2 {
    static Tuple2<String, Integer> f() {
        return tuple("hi", 47);
    }

    // 返回 RawType Tuple
    static Tuple2 f2() {
        return tuple("hi", 47);
    }

    static Tuple3<Amphibian, String, Integer> g() {
        return tuple(new Amphibian(), "hi", 47);
    }
    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
        return tuple(
                new Vehicle(), new Amphibian(), "hi", 47);
    }

    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
        return tuple(new Vehicle(), new Amphibian(),
                "hi", 47, 11.1);
    }

    public static void main(String[] args) {
        Tuple2<String, Integer> ttsi = f();
        System.out.println(ttsi);
        System.out.println(f2());
        System.out.println(g());
        System.out.println(h());
        System.out.println(k());
    }
}

/**
输出
(hi, 47)
(hi, 47)
(generics.Amphibian@66d3c617, hi, 47)
(generics.Vehicle@63947c6b, generics.Amphibian@2b193f2d, hi, 47)
(generics.Vehicle@355da254, generics.Amphibian@4dc63996, hi, 47, 11.1)
*/
```

> 注意这里 f() 返回一个反省类 Tuple2 对象，而 f2() 返回一个 未使用类型参数的 RawType Tuple2 对象。
>
> 编译器不会在这里警告 f2() 因为返回值未以参数化方式使用。 从某种意义上来说，它被向上转型为一个 "未使用参数化的 Tuple2"。但是如果尝试将 f2() 的结果放入到 泛型 Tuple2 中，则编译器将发出警告。

![image-20200312121548874](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200312121549.png)

**【也就是这样，将 f2() 的返回结果赋值给一个使用泛型参数的 Tuple2 对象，编译器会告诉你这个赋值没有被检查，可能会出问题】**

#### 一个 Set 工具

> 对于泛型方法的另一个示例，考虑由 Set 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：

```java
//Sets.java
public class Sets {
    // 入参是2个Set，返回这2个 Set 的并集
    public static <T> Set<T> union(Set<T> a, Set<T> b) {
        Set<T> result = new HashSet<>(a);
        result.addAll(b);
        return result;
    }

    // 返回 SetA 与 SetB 的交集
    public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
        Set<T> result = new HashSet<>(a);
        result.retainAll(b);
        return result;
    }

    // 返回两个集合之间的差集
    public static <T> Set<T> difference(Set<T> superset, Set<T> subset) {
        Set<T> result = new HashSet<>(superset);
        result.removeAll(subset);
        return result;
    }

    // Reflexive--everything not in the intersection:
    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
        // a 与 b 的并集 与 a与b 的交集 做差集
        return difference(union(a, b), intersection(a, b));
    }
}

```

> 前三个方法通过将第一个参数的引用复制到新的 HashSet 对象中来复制第一个参数，因此不会直接修改参数集合。**返回的是一个新的 Set对象**
>
> 这四种方法代表数学集合操作： `union()` 返回一个包含两个参数**并集**的 **Set** ， `intersection()` 返回一个包含两个参数集合**交集**的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有**不在交集中的元素的 Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：

```java
public enum Watercolors {
    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
}
```

> 为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](https://lingcoder.github.io/OnJava8/#/book/22-Enumerations)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` **要求提供所要在结果 Set 中创建的元素范围的第一个和最后一个元素：**

```java
public class WatercolorSets {
    public static void main(String[] args) {
        // 截取传入枚举之间的枚举
        Set<Watercolors> set1 = EnumSet.range(Watercolors.红, Watercolors.紫);
        Set<Watercolors> set2 =
                EnumSet.range(Watercolors.白, 黄);
        System.out.println("set1: " + set1);
        System.out.println("set2: " + set2);
        System.out.println(
                "union(set1, set2): " + union(set1, set2));

        Set<Watercolors> subset = intersection(set1, set2);
        System.out.println("subset: " + subset);
        System.out.println("difference(set1, subset): " + difference(set1, subset));
        System.out.println("complement(set1, set2): " + complement(set1, set2));
    }
}
/**
输出
set1: [红, 白, 黄, 绿, 青, 蓝, 紫]
set2: [白, 黄]
union(set1, set2): [绿, 青, 白, 蓝, 黄, 紫, 红]
subset: [白, 黄]
difference(set1, subset): [绿, 青, 蓝, 紫, 红]
complement(set1, set2): [绿, 青, 蓝, 紫, 红]
*/
```

**【这个例子就是使用刚才编写的交集，并集，差集和求不在交集中的元素。这里我对枚举进行了修改，因为那一堆大写英文实在看的很头疼，直接上中文了，看着清晰一些，仅作参考与示范，正式编码中还是要用英文：】** 

```java
public enum Watercolors {
    红,白,黄,绿,青,蓝,紫
}

```



> 接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：

```java
// onjava/CollectionMethodDifferences.java
// {java onjava.CollectionMethodDifferences}

// 打印子类的特有方法以及子类的接口列表的工具类，挺有意思
public class CollectionMethodDifferences {
    // 将传入类的方法转为TreeSet集合
    static Set<String> methodSet(Class<?> type) {
        return Arrays.stream(type.getMethods())
                .map(Method::getName)
                .collect(Collectors.toCollection(TreeSet::new));
    }

    static void interfaces(Class<?> type) {
        // 列出传入类型的所有父类接口
        System.out.print("Interfaces in" + type.getSimpleName() + ": ");
        System.out.println(Arrays.stream(type.getInterfaces())
                .map(Class::getSimpleName)
                .collect(Collectors.toList())
        );
    }

    static Set<String> object = methodSet(Object.class);

    // 优先于构造函数执行
    static {
        object.add("clone");
    }

    // 打印 子类中特有的方法，以及子类的所有接口列表
    static void difference(Class<?> superset, Class<?> subset) {
        System.out.print(superset.getSimpleName() + ", extends " + subset.getSimpleName() + ", adds: ");
        Set<String> comp = Sets.difference(methodSet(superset), methodSet(subset));
        comp.removeAll(object); // 将 超类 Object 中的方法 remove
        System.out.println(comp);
        // 获取 superset 的接口列表
        interfaces(superset);
    }

    public static void main(String[] args) {
        // 打印 Collection 类的方法
        System.out.println("Collection: " + methodSet(Collection.class));

        // Collection 的接口
        interfaces(Collection.class);

        // Set 和 Collection 的差集（也就是 Set中子类特有的方法）
        difference(Set.class, Collection.class);

        difference(HashSet.class, Set.class);

        difference(LinkedHashSet.class, HashSet.class);

        // TreeSet 增加了很多方法
        difference(TreeSet.class, Set.class);

        difference(List.class, Collection.class);

        difference(ArrayList.class, List.class);

        difference(LinkedList.class, List.class);

        difference(Queue.class, Collection.class);

        difference(PriorityQueue.class, Queue.class);

        System.out.println("Map: " + methodSet(Map.class));

        difference(HashMap.class, Map.class);

        difference(LinkedHashMap.class, HashMap.class);

        difference(SortedMap.class, Map.class);

        difference(TreeMap.class, Map.class);
    }
}

/**
输出
Collection: [add, addAll, clear, contains, containsAll, equals, forEach, hashCode, isEmpty, iterator, parallelStream, remove, removeAll, removeIf, retainAll, size, spliterator, stream, toArray]
Interfaces inCollection: [Iterable]
Set, extends Collection, adds: []
Interfaces inSet: [Collection]
HashSet, extends Set, adds: []
Interfaces inHashSet: [Set, Cloneable, Serializable]
LinkedHashSet, extends HashSet, adds: []
Interfaces inLinkedHashSet: [Set, Cloneable, Serializable]
TreeSet, extends Set, adds: [headSet, descendingIterator, descendingSet, pollLast, subSet, floor, tailSet, ceiling, last, lower, comparator, pollFirst, first, higher]
Interfaces inTreeSet: [NavigableSet, Cloneable, Serializable]
List, extends Collection, adds: [replaceAll, get, indexOf, subList, set, sort, lastIndexOf, listIterator]
Interfaces inList: [Collection]
ArrayList, extends List, adds: [trimToSize, ensureCapacity]
Interfaces inArrayList: [List, RandomAccess, Cloneable, Serializable]
LinkedList, extends List, adds: [offerFirst, poll, getLast, offer, getFirst, removeFirst, element, removeLastOccurrence, peekFirst, peekLast, push, pollFirst, removeFirstOccurrence, descendingIterator, pollLast, removeLast, pop, addLast, peek, offerLast, addFirst]
Interfaces inLinkedList: [List, Deque, Cloneable, Serializable]
Queue, extends Collection, adds: [poll, peek, offer, element]
Interfaces inQueue: [Collection]
PriorityQueue, extends Queue, adds: [comparator]
Interfaces inPriorityQueue: [Serializable]
Map: [clear, compute, computeIfAbsent, computeIfPresent, containsKey, containsValue, entrySet, equals, forEach, get, getOrDefault, hashCode, isEmpty, keySet, merge, put, putAll, putIfAbsent, remove, replace, replaceAll, size, values]
HashMap, extends Map, adds: []
Interfaces inHashMap: [Map, Cloneable, Serializable]
LinkedHashMap, extends HashMap, adds: []
Interfaces inLinkedHashMap: [Map]
SortedMap, extends Map, adds: [lastKey, subMap, comparator, firstKey, headMap, tailMap]
Interfaces inSortedMap: [Map]
TreeMap, extends Map, adds: [descendingKeySet, navigableKeySet, higherEntry, higherKey, floorKey, subMap, ceilingKey, pollLastEntry, firstKey, lowerKey, headMap, tailMap, lowerEntry, ceilingEntry, descendingMap, pollFirstEntry, lastKey, firstEntry, floorEntry, comparator, lastEntry]
Interfaces inTreeMap: [NavigableMap, Cloneable, Serializable]

*/

```

**【这个小工具挺有意思的。我感觉还有一定的实用价值。】**

