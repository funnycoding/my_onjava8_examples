---
layout: post
title: 《On Java8》第十三章——函数式编程(3)高阶函数、闭包与柯里化
date: 2020-02-18 01:26:52
tags:
- 读书笔记
categories: 
- 《On Java8》
---


### 高阶函数

> ##### 高阶函数(Higher-order Function) 指 消费或产生函数的函数。
>
> **【也就是一个方法的返回值是另一个方法。】**
>
> 来一个**产生函数**的例子：

<!-- more -->	



```java
// ProduceFunction.java
// 继承了 Function 接口，返回值和入参类型相同
interface MyFunction extends Function<String, String> {
} // [1]

public class ProduceFunction {
    // 高阶函数，返回了将入参字符串转为小写这个动作
    static MyFunction produce() {
        return s -> s.toLowerCase(); // [2]
    }

    public static void main(String[] args) {
        MyFunction f = produce();
        System.out.println(f.apply("YELLING"));
    }
}

// 输出
yelling
```



> 这里 `produce()` 是**高阶函数**。
>
> [1] **使用继承可以轻松为预定义好的专用函数式接口来创建别名**
>
> [2] **使用 Lambda 表达式轻松在方法中创建和返回一个函数**
>
> 要消费一个函数，消费函数需要在**参数列表**正确地描述函数类型：

**其实本质是：【返回了一个实现接口的虚拟内部类的实例】**



```java
// ConsumeFunction.java
class One {
}

class Two {
}

// 我自己又加了个根据方法引用生成 Two 的
class Three {
    static Two test(One o) {
        return new Two();
    }
}

public class ConsumeFunction {
    // 入参是一个两个参数的Function，根据参数位置可以看到入参是One，返回值是 Two，与这个方法的返回值一致。
    static Two consume(Function<One, Two> oneTwo) {
        System.out.println("入参是 Function，根据 Function.apply 返回 Two对象的方法被调用了");
        return oneTwo.apply(new One());
    }

    public static void main(String[] args) {
        // 实现与 consume 相同效果的 Lambda 表达式
        Function<One, Two> f = one -> new Two();
        //  f.apply(new One) 直接可以生成一个 Two 的实例
        Two apply = f.apply(new One());
        System.out.println("使用Lambda表达式生成的对象：" + apply);

        Two consume = consume(f);
        System.out.println("使用 Consume 生成的对象：" + consume);

        Two two = consume(one -> new Two());
        System.out.println("将Lambda表达式传入 consume 生成的对象: " + two);

        // 把 Three类的test方法赋值给 Function，传入consume，也可以生成 Two 对象
        Two three = consume(Three::test);
    }
}

/**
输出
使用Lambda表达式生成的对象：functional.Two@7b23ec81
入参是 Function，根据 Function.apply 返回 Two对象的方法被调用了
使用 Consume 生成的对象：functional.Two@6acbcfc0
入参是 Function，根据 Function.apply 返回 Two对象的方法被调用了
将Lambda表达式传入 consume 生成的对象: functional.Two@3feba861
*/

```

**【可以看到这里我发散了一下，自己加了个方法引用的例子，大家也可以多魔改一下样例代码，试试自己的理解到底对不对。找出自己的薄弱项】**

> 当**消费函数的同时生成一个新的函数**，事情就变得相当有趣了

```java
class I {
    @Override
    public String toString() {
        return "IIII";
    }
}

class O {
    public O() {
        System.out.println("O的构造函数被调用了");
    }

    @Override
    public String toString() {
        return "OOO";
    }
}


public class TransformFunction {
    // 这个方法的入参也是一个 Function 可以看做是一个函数 一种行为
    // 入参是一种行为 返回值也是一种行为，消费行为，生成行为
    // 这里我觉得如果刚开始看不太明白的话，直接通过IDE的功能将 lambda 展开为 匿名内部类 就会看得非常清楚了
    // 这里实现了一个 Function 的匿名内部类，类中的 apply 方法 打印入参 然后不做处理直接返回

    /**
     * 将 Lambda 展开为匿名内部类形式
     * static Function<I, O> transform(Function<I, O> in) {
     * return in.andThen(new Function<O, O>() {
     *
     * @Override public O apply(O o) {
     * System.out.println(o);
     * return o;
     * }
     * });
     * }
     */

    // Lambda
    // 然后在看一下 andThen 函数的定义
    static Function<I, O> transform(Function<I, O> in) {
        System.out.println("transform 被调用了");
        return in.andThen(o -> {
            System.out.println("transform 被调用才进来的");
            System.out.println("当前对象："+o + "apply()");
            return o;
        });
    }


    public static void main(String[] args) {
        System.out.println("第一个方法引用:myApply");
        Function<I, O> ioFunction = // 这里使用我自己实现的 apply方法赋值给 Function
                TransformFunction::myApply;
        System.out.println("开始调用 transform(), 入参是一个 Lambda 表达式， 该表达式的入参是 i，输出i，返回 O");
        Function<I,O> f2 = transform(i -> {
            System.out.println(i);
            return new O();
        });
        f2.apply(new I());
        System.out.println("transform 调用结束");

        System.out.println("开始调用 iOFunction 的 apply()"); // 这里实际调用的是我下面定义的 myApply()函数
        System.out.println(ioFunction.apply(new I())); // 这里打印出来的 OOO 是 ioFunction.apply(new I()) 这里生成的对象 O
        System.out.println("-------------");
    }

    private static O myApply(I i) {
        System.out.println("这里是打印i的上一行");
        System.out.println("打印I: " + i );
        System.out.println("这里是return O 的上一行");
        // 为什么这个返回这个对象 或者说调用 O 的构造函数，toString 方法被调用了
        System.out.println("开始构造 O 对象");
        O o = new O();
        System.out.println("打印O对象 "+o);
        return o;
    }
}

/**
第一个方法引用:myApply
开始调用 transform(), 入参是一个 Lambda 表达式， 该表达式的入参是 i，输出i，返回 O
transform 被调用了
IIII
O的构造函数被调用了
transform 被调用才进来的
当前对象：OOOapply()
transform 调用结束
开始调用 iOFunction 的 apply()
这里是打印i的上一行
打印I: IIII
这里是return O 的上一行
开始构造 O 对象
O的构造函数被调用了
打印O对象 OOO
returnO的上一句
OOO
-------------


*/

```

**【这里我把这个例子改的复杂了点，但是一个例子就加深了不少掌握程度，下面是原例子】：**

```java
// functional/TransformFunction.java

import java.util.function.*;

class I {
  @Override
  public String toString() { return "I"; }
}

class O {
  @Override
  public String toString() { return "O"; }
}

public class TransformFunction {
  static Function<I,O> transform(Function<I,O> in) {
    return in.andThen(o -> {
      System.out.println(o);
      return o;
    });
  }
  public static void main(String[] args) {
    Function<I,O> f2 = transform(i -> {
      System.out.println(i);
      return new O();
    });
    O o = f2.apply(new I());
  }
}
/**
输出结果
I
O
*/
```

> 这里 `transform()` 生成一个与传入函数具有相同签名的函数，但是可以生成任意你想要的类型。
>
> 这里调用的 andThen 是 Function 中的默认方法，专门用于操作函数。
>
> 顾名思义，在调用 in 函数之后调用 toThen() 。要附加一个 andThen() 函数，只需要将函数作为参数传递。
>
> transform() 产生的是一个新函数，它将 in 的动作与 andThen() 函数的参数结合起来



**【可以看到 andThen 的入参是一个 Function ，例子中传入的是一个 Lambda ，该 Lambda 的入参和返回值都是 o，符合 andThen 的入参要求。】**

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218152055.png)

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218152109.png)

##### 

### 闭包

##### 【之前在匿名内部类章节就中讲到了闭包这个行为】

> 在上一节的 `ProduceFunction.java` 例子中，我们从方法中返回 Lambda 函数。
>
> 虽然过程简单，但还是有些问题必须回过头探讨一下

##### 【这就对了啊，感觉很多东西都没有说的太清楚太细，是不是默认读者都已经完全明白了啊？】

> 闭包（Closure） 一词总结了这些问题。它非常重要，利用闭包可以轻松生成函数。
>
> 考虑一个更复杂的 Lambda，**它使函数作用于 域之外的变量**。返回该函数会发生什么？
>
> 也就是说，当你调用函数时，它对那些”外部“变量引用做了什么？
>
> 如果语言不能自动解决这个问题，那将变的非常有挑战性。
>
> 能够解决这个问题的语言被称为 **支持闭包** 或者叫 在**词法上限定范围**（或使用术语 — **变量捕获**）
>
> Java8 提供了**有限但合理的闭包支持**，下面用一些简单的例子说明：

##### 【之前说过，Lambda 或者 函数式的好处就是不改变函数外的变量，但是一旦 Lambda 涉及到函数外的变量就可能引起很多问题， 闭包指的是能够解决 Lambda 引用函数外变量的情况下可能发生的问题。这个看起来确实很重要，直接敲代码吧。】

> 下面例子的函数中，**方法返回访问对象字段和方法参数**：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218153457.png)

> 但是仔细考虑一下， i 的这种用法并非大难题。
>
> 因为对象很可能在调用 makeFun() 之后就存在了。
>
> ##### 实际上，垃圾收集器几乎肯定会保留一个对象，并将现有的函数以这种方式绑定到该对象上[5] 
>
> ##### 如果你对同一个对象多次调用 makeFun()，你最终会得到多个函数，它们共享 i 的存储空间：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218154932.png)

> ##### 可以看到，每次调用 getAsInt() i 都会增加，表明其存储是共享的。
>
> 如果 i 是 `makeFun()` 方法的**局部变量**怎么办？ 
>
> 正常情况下，**方法执行结束，局部变量消失**，但是如果你这么写仍然可以通过编译：

```java
// functional/Closure2.java
public class Closure2 {
    IntSupplier makeFun(int x) {
        int i = 0;
        return () -> x + i;
    }
}

```



> 由 makeFun() 返回的 IntSupplier "关闭" i 和 x ，因此当你调用返回的函数时两者仍然有效。
>
> 但请注意，没有像 Closure1 那样对 **i 进行递增**，因为会产生编译时的错误，看代码：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218155448.png)

**【这里说 Lambda 表达式中的变量必须是不可变的】**

> 从 Lmbda 表达式引用的局部变量必须是 final 或者等同 final效果的。
>
> 如果使用 final 修饰则通过编译，也代表 i 不可变。

```java
// functional/Closure3.java

// {WillNotCompile}
import java.util.function.*;

public class Closure3 {
    IntSupplier makeFun(int x) {
       final int i = 0;
        //return () -> x++ + i++;   // x++ 和 i++ 都会报错： 因为 Lambda 中局部变量必须为 等效final的，也就是不能够修改
        return () -> x + i;
    }
}

```

**【说到底还是因为匿名内部类的入参必须是 final，引申到语法不同但是核心机制应该相同的 Lambda/方法引用上也是一样的道理】**

> x 和 i 的操作犯了同样的错误，：从 Lambda 表达式引用的局部变量必须是 `final` 或者是等同 `final` 效果的。

```java
// functional/Closure4.java

import java.util.function.*;

public class Closure4 {
  IntSupplier makeFun(final int x) {
    final int i = 0;
    return () -> x + i;
  }
}
```



> 那么为啥 **Closure2里面没有显示的定义 i 为final 但是同样没有报错呢？**
>
> 这叫做**同等 final 效果(Effectively Final)** 。这个术语是 Java8 才开始出现的。表示虽然**没有明确地声明变量为 final**，但是因为**变量没有被改变过而实际有了 final 的同等效果。**
>
> ##### 如果局部变量的初始值永远不会改变，那么它实际上就是 final的。
>
> **如果 x 和 i 的值在方法中的其他位置发生了改变（但不在返回的函数内部），则编译器仍将其视为错误。**
>
> 每个递增操作会分别产生错误信息，代码如下：

```java
/ functional/Closure5.java

// {无法编译成功}
import java.util.function.*;

public class Closure5 {
  IntSupplier makeFun(int x) {
    int i = 0;
    i++;
    x++;  // x 和 i 都必须为等效 final 的变量
    return () -> x + i;
  }
}
```





> **等同final效果** 意味着可以在变量声明前加上 final 关键字而不用更改任何其余代码。
>
> **通过在闭包中使用 final 关键字提前修饰变量 x 和 i** ，我们解决了 Closure5 中的问题：

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218160914.png)

> 意思就是这里 x 和 i 都是 只增加1的常量，只要在使用之前用 final 修饰并赋值给另一个引用就ok。
>
> 其实这里也不用使用 final 修饰符，因为 将 i 赋值给 iFinal 之后 该变量未发生改变。

```java
// functional/Closure6.java

import java.util.function.*;

public class Closure6 {
  IntSupplier makeFun(int x) {
    int i = 0;
    i++;
    x++; // 这里虽然 i和x的值改变了，但是之前要返回之前将其定义为 final即可正常运行
    final int iFinal = i;
    final int xFinal = x;
    return () -> xFinal + iFinal;
  }
}
```



> 如果这里使用的是包装类型，需要把 Int 改为 Integer：

```java
// functional/Closure7.java

// {无法编译成功}
import java.util.function.*;

public class Closure7 {
  IntSupplier makeFun(int x) {
    Integer i = 0;
    i = i + 1;  // Integer 的值发生了改变，导致非final的产生
    return () -> x + i;
  }
}
```



> 就算使用包装器类型编译器仍然能够识别该变量被更改过
>
> 接下来尝试一下 List:

```java
// functional/Closure8.java

import java.util.*;
import java.util.function.*;

public class Closure8 {
  Supplier<List<Integer>> makeFun() {
    // 每次调用 makeFun 返回的都是新的内含一个参数 "1"的不可变的 ArrayList
    final List<Integer> ai = new ArrayList<>();
    ai.add(1);
    return () -> ai;
  }
  public static void main(String[] args) {
    Closure8 c7 = new Closure8();
    List<Integer>
      l1 = c7.makeFun().get(),
      l2 = c7.makeFun().get();
    System.out.println(l1);
    System.out.println(l2);
    l1.add(42);
    l2.add(96);
    System.out.println(l1);
    System.out.println(l2);
  }
}
/**
输出
[1]
[1]
[1, 42]
[1, 96]
*/
```

**【可以看到就算重复调用 makeFun() 方法，生成的list 的元素也都是1】**

> 这次一切正常，哪怕我们改变了 List 的值也没有产生编译时错误。
>
> 通过观察输出发现，这看起来非常安全，因为**每次调用 makeFun() 都会创建并返回一个全新的 ArrayList**
>
> ##### 也就是说，每个闭包内都有自己独立的 ArrayList，它们之间互不干扰。
>
> 例子中的 list 被声明为是 final的，尽管在这个例子中去掉 final 也能获得同样的结果。
>
> **应用于引用对象的final 仅仅代表不能重新赋值引用，而改变对象本身的值是被允许的**。【final 章节中的基础知识】
>
> 下面看看 Closure7 和 Closure8 之间的区别： 在 `Closure7.java` 中变量 `i` 有过重新赋值。 也许这就是**等同 final 效果**错误消息的触发点。



> 下面看看给 List重新赋值所导致的编译错误：



```java
// functional/Closure9.java

// {无法编译成功}
import java.util.*;
import java.util.function.*;

public class Closure9 {
  Supplier<List<Integer>> makeFun() {
    List<Integer> ai = new ArrayList<>();
    ai = new ArrayList<>(); // 这里给返回的数组重新进行了赋值，打破了等同 final效果
    return () -> ai;
  }
}
```



> 现在回顾一下 Closure1.java 中的 i，**为什么那里面的 i 被修改了编译器却并没有报错？**
>
> **因为 i 是外部类的成员**，所以**这样做肯定是安全的**（**除非你正在创建共享可变内存的多个函数）。**
>
> **你可以说当变量是外部类的成员变量而不是方法内的局不变量时不会发生变量捕获（Variable Capture）。**
>
> 但可以肯定的是 Closure3.java 的错误信息是专门针对局部变量的
>
> 因此**，规则并非只是 在 Lambda 之外定义的任何变量必须是 fina 或者 等同 final 效果那么简单。** 
>
> 而是你必须考虑**捕获的变量**是否**等同 final** 效果。
>
> 如果它是**对象中的字段**，那么它拥有**独立的生命周期**，并且**不需要任何特殊的捕获**，以便稍后在调用 Lambda时存在。

**【这段话中的信息挺关键，总结一下就是如果变量是方法内的，则需要考虑捕获的是否是 final 变量，如果是类变量，则不需要考虑】**

### 作为闭包的内部类

> 我们可以使用**匿名内部类**重写之前的例子：

```java
// functional/AnonymousClosure.java

import java.util.function.*;

public class AnonymousClosure {
  IntSupplier makeFun(int x) {
    int i = 0;
    // 同样规则的应用:
    // i++; // 非等同 final 效果
    // x++; // 同上
    return new IntSupplier() {
      public int getAsInt() { return x + i; }
    };
  }
}
```



> 实际上**只要有内部类，就会有闭包**（Java8 只是简化了语法）。
>
> 在 **Java8 之前， 变量 x 和 i 必须被确定的声明为 final**， **Java8** 中，内部类的规则放宽，**包括了等同 final 效果。**

### 函数组合

> 函数组合 （Function Composition） 意味 "**多个函数组合成新函数**"。
>
> **它通常是函数式编程的基本组成部分。**
>
> 在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。
> 一些 java.util.function 接口中包含支持函数组合的方法:

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200301231408.png)

> 下例使用了 `Function` 里的 `compose()` 和 `andThen()` 

```java
// FunctionComposition.java
public class FunctionComposition {

    // 这里声明了4个函数 f4 是前三个的组合
    static Function<String, String> f1 = s -> {
        System.out.println("S1获得了字符串: " + s);
        System.out.println(s);
        return s.replace('A', '_');
    },
            f2 = s -> s.substring(3),

    f3 = s -> {
        System.out.println("f3入参:" + s);
        return s.toLowerCase();
    },
            f4 = f1.compose(f2).andThen(f3); // compose 表示 f2的调用该发生在f1之前 然后调用 s3

    public static void main(String[] args) {
        System.out.println(f4.apply("GO AFTER ALL AMBULAMNCES"));
    }
}
/**
输出
S1获得了字符串: AFTER ALL AMBULAMNCES
AFTER ALL AMBULAMNCES
f3入参:_FTER _LL _MBUL_MNCES
_fter _ll _mbul_mnces
*/
```

> 这里我们重点看正在创建的新函数 `f4`。它调用 `apply()` 的方式与常规几乎无异[^8]。
>
> 当 `f1` 获得字符串时，它已经被`f2` 剥离了前三个字符。这是因为 `compose（f2）` 表示 `f2` 的调用发生在 `f1` 之前。

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200218172026.png)

> p4 获得了所有动作的组合，并组合成了一个更复杂的动作。
>
> 解读： **如果字符串不包含 bar 且长度小于5，或者包含foo，则结果为 true。**
>
> 正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，**我创建了一个字符串对象的流**，然后将每个对象传递给 `filter()` 操作。 `filter()` 使用 `p4` 的谓词来确定对象的去留。最后我们使用 `forEach()` 将 `println` 方法引用应用在每个留存的对象上。
>
> 从输出结果我们可以看到 `p4` 的工作流程：任何带有 `foo` 的东西都会留下，即使它的长度大于 5。 `fongopuckey` 因长度超出和不包含 `bar` 而被丢弃。

### 总结：

【**闭包的核心在于方法内变量的不可变性，而对方法外的类变量则没有要求。**】

### 柯里化和部分值：将多个入参的函数转化为一组单入参函数

> 柯里化（Currying） 的名称来自于其发明者之一 Haskell Curry。他可能是计算机领域唯一名字被命名重要概念的人（另外就是 Haskell语言）
>
> 柯里化指的是：**将一个多参数的函数，转换为一系列的单参数函数**

##### 【重构中也提到了这个概念，降低函数复杂的度的】

```java
// CurryingAndPartials.java
public class CurryingAndPartials {
    // 未柯里化的函数，有多个入参
    static String uncurried(String a, String b) {
        return a + b;
    }

    public static void main(String[] args) {
        // 柯里化函数
        Function<String, Function<String, String>> sum =
                a -> b -> a + b; //[1] a 的入参是一个函数b。 b 是一个 返回 a+b 的函数

        System.out.println("uncurried:" + uncurried("HI ", "Ho"));

        Function<String, String> hi = sum.apply("HI "); //[2]
        String ho = hi.apply("Ho");
        System.out.println("sum.apply:" + ho);

        // 部分应用
        Function<String, String> sumHi = sum.apply("Hup ");
        System.out.println(sumHi.apply("Ho"));
        System.out.println(sumHi.apply("Hey"));
    }
}
/**
输出
uncurried:HI Ho
sum.apply:HI Ho
Hup Ho
Hup Hey
*/
```



【看着这一串的箭头是不是感觉有点懵逼？仔细看看，发现就是函数套函数】

> 第二个参数是另一个函数
>
> [2] **柯里化的目标是通过提供一个参数来创建一个新的函数**。
>
> 所以现在有了**一个带参函数和剩下的无参函数**。 **你可以从一个双参数函数开始，得到一个单参数的函数。**

> 下面来一个柯里化的三参数函数：

```java
public class Curry3Args {
    public static void main(String[] args) {
        Function<String,
                Function<String,
                        Function<String, String>>> sum =
                a -> b -> c -> a + b + c; // 这里相当于参数的连续传递吗，c -> a + b + c 这里 b和c是哪里来的?

        Function<String, Function<String, String>> hi =
                sum.apply("Hi ");
        Function<String, String> ho = hi.apply("Ho ");
        System.out.println(ho.apply("Hup"));
    }
}

// 输出结果
Hi  Ho Hup
```

> 处于每个级别的箭头级联（Arrow-cascading) ，**你在类型声明中包裹了另一个 `Function`。**
>
> 处理基本类型装箱时，请适当使用 **`Function`** 接口：

##### 

##### 

```java
public class CurriedIntAdd {
    public static void main(String[] args) {
        IntFunction<IntUnaryOperator> curriedIntAdd = a -> b -> a + b; // 使用不需要拆装箱的内置Function

        IntUnaryOperator add4 = curriedIntAdd.apply(4);
        System.out.println(add4);
        System.out.println(add4.applyAsInt(5));
    }
}

/**
输出
9
*/
```

##### 【可以看到输出是4和5进行相加，将两个入参的函数 比如(int a,int b) 柯里化了两个 单参数的函数】

> 可以在网络上找到更多的柯里化的例子。通常它们是Java 之外的语言实现的。 **但是如果你理解了柯里化的基本概念，你可以很轻松地用户 Java 实现它们。**

### 纯函数编程

> Java 的函数式编程需要确定变量是 final 的。 
>
> 同时方法和函数没有副作用【这里的副作用我理解为修改方法之外的变量】
>
> Java 在本质上并非是不可变语言，我们无法通过编译器查错。【这句话是否太片面，需要自己进行求证】

作者更推荐使用 Scala 或者 Clojure 这样的为了保持不变形而设计的语言，如果你必须要使用**纯函数式编写**，则用这些语言更合适。

不过为什么要用纯函数式呢？看着是很简洁，但是也增加了理解成本和学习成本，不过多学点东西还是好的。



### 本章小结

> Lambda 表达式和方法引用并没有改变 Java 的本质，没有将 Java 转换成函数式语言，只是提供了对函数式编程的支持。
>
> 这对 Java 来说增加了语法的支持，如果你喜欢编写更简洁明了，易于理解的代码，可以使用这两种形式。还有下一章中的流式编程，看起来简洁明了。



> Lambda 和方法引用 因为 Java 早期的语言包袱会导致也有很多问题，特别是没有泛型的 Lambda。
>
> Lambda 在 Java中并非一等公民，但是它的使用也会让人感觉到沮丧和鸡肋。

【说明有巨大的局限性，但是局限性在哪里作者只给出了结论却没有支撑的数据和论证，让人看着很难受】



### 总结：



### 额外参考资料：

[ [深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]](https://www.cnblogs.com/figure9/p/java-8-lambdas-insideout-language-features.html)

