---
layout: post
title: 《On Java8》第十四章——流式编程(1) —— 流创建 
date: 2020年02月20
tags:
- 读书笔记
categories: 
- 《On Java8》
---

## 《On Java8》第十四章 流式编程（1）— 流创建

> 集合优化了对象的存储，而**流和对象的处理有关。**
>
> **流**是一系列**与**特定**存储无关**的元素。**流中并不存在存储的概念。**

<!-- more -->	

**【那么第一个问题来了，流中的元素存储在哪里？】** 

[IBM Devlper- Java 8 中的 Stream API 详解找到了答案](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html)

文章中对流做了如下总结：

- 流不是数据结构。
- 流没有内部存储，流只是使用操作管道从 source(数据结构【我猜作者想说的是集合框架。】，数组，generator function、IO channel) 抓取数据。
- 流不修改所封装的底层数据结构的数据。 Stream 的 filter 操作会产生一个不包含被过滤元素的新的 Stream，而不是改变 source,删除那些元素。【有点像String的生成，字符串拼接后形成一个新字符串，因为不可变】
- 所有 Stream 的操作必须以 Lambda 表达式为参数
- 不支持索引访问
- 可以请求第一个元素，但无法请求第二个，第三个，或最后一个，不过可以参阅下一个、
- 很容易生成数组或者 List。
- 惰性化
- 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。
- Intermediate 操作永远是惰性化的。
- 并行能力
- 当一个 Stream 是并行的，就不需要再写多线程代码，所有对它的操作会自动并行进行。
- 可以是无限的
  - 集合有固定大小，Stream则不必。 limit(n)  和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。



这里可以看到作者说流只是从 source 处抓取数据，所以流没有自己的存储。




> **使用流**，我们**无需迭代集合中的元素就可以提取和操作它们**。这些**管道**通常被组合在一起，在流上形成一条操作管道。
>
> 大多数情况下，将对象存储在集合中是为了处理他们。因此焦点从集合转移到了流上——因为**流可以直接操作集合中的对象**。
>
> **流的一个核心好处是，它使得程序更加短小并更易理解。**
>
> 当 Lambda 表达式和方法引用与流一起使用的时候会让人感觉自成一体。
>
> 流使得 Java 8 更具有吸引力。

<!-- more -->	



> 举个栗子，如果要随机展示 5 - 20 之间不重复的整数并排序。首先应该是创建一个**有序的集**合，围绕这个集合进行后续的操作。
>
> 但是使用流式编程，你就可以简单陈述你想做什么：

```java
// streams/Randoms.java
public class Randoms {
    public static void main(String[] args) {
        // 创建随机数，给个种子
        new Random(47)
                .ints(5, 20) // 生成  包含(5,20)的随机数  的流
                .distinct() // 去重
                .limit(7) // 限制数量 7个
                .sorted() // 排序
                .forEach(System.out::println);  // 输出

    }
}
/**
输出
6
10
13
16
17
18
19
  */
```

> 分析一下这个例子，首先使用带种子的 `Random` 对象保证运行时的相同输出。
>
> int() 方法产生一个流 并且 int() 方法有多重方式的重载—两个参数限定了数值产生的边界，这将生成一个整数流。
>
> 有了流我们就可以使用中间流操作（intermediate stream operation)  。**distinct() — 去重** 
>
> **limit() 获取流中前7个元素**
>
> **sorted() 排序**
>
> foreach() 根据入参函数对流中的每个对象执行操作，这里我们传入的是System.out::println 所以每个对象都被打印到控制台中。
>
> 同时注意，**在这个例子中我们没有声明任何变量**— **流可以在不使用赋值或可变数据的情况下对有状态的系统建模。**
>
> **声明式编程（Declaretive Programming）是一种：声明要做什么，而非怎么做的编程风格。** 
>
> **而命令式的编程风格会更加难以理解【也就是我们平时使用的编程风格】**
>
> 下面是命令式编程形式的代码：

```java
// ImperativeRandoms.java
public class ImperativeRandoms {
    public static void main(String[] args) {
        Random rand = new Random(47);
        SortedSet<Object> rints = new TreeSet<>();
        while (rints.size() < 7) {
            int r = rand.nextInt(20);
            if (r < 5) {
                continue;
            }
            rints.add(r);
        }
        System.out.println(rints);
    }
}

// 输出
[7, 8, 9, 11, 13, 15, 18]
```

> 对比一下声明式编程和命令式编程，命令式编程定义了3个变量，并且 nextInt() 方法不能设置下限，所以我们需要额外增加判断来避免添加小于5的值。
>
> **注意**，**你必须明白程序的真正意图**，而在 Randoms.java 中，代码只是告诉了你它正在做什么。这种语义清晰性也是 Java 8 的流式编程更受推崇的重要原因。
>
> 在  ImperativeRandoms.java 中显示的编写 while 循环 被称为 **外部迭代**，而在 Randoms.java 中，流式编程采用**内部迭代**，这是流式编程的核心机制之一。
>
> 这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。
>
> 通过放弃对迭代过程的控制，我们将控制权交给了并行化机制。
>
> 同时，**流是懒加载的**，这代表着它只在绝对必要时才计算。你可以将流看作"延迟列表"。由于计算延迟，**流使我们能够表示非常大（甚至无限的序列） 而不需要考虑内存问题。**
>
> **【为什么懒加载就可以计算近乎无限大的流序列，为什么流能表示近乎无限的序列而不需要考虑内存，序列中的对象存储在哪里？】**

### 小结

序言给出流很重要的一些特点：

- 流与具体的存储无关，也就是说和 List Map Set 之类的没有耦合。
- 流的核心是操作集合中的对象
- 流不需要迭代集合中的元素就可以操作这些对象，是不是意味着效率会大幅度提高？
- 流存在管道的概念。
- 流与Lambda/方法引用一起使用会显得更和谐。
- 流是**内部迭代**且并行的，可以利用多核处理器。
- 流是懒加载且计算延迟的，可以表示非常大甚至无限的序列。
- 声明式编程：只告诉你想要的结果(What)，机器自己摸索过程(How) 对应 **内部迭代**
- 命令式编程：详细的命令机器怎样（How) 处理一件事情以达到你想要的效果 对应**外部迭代**

### 问题：

- 管道这里怎样理解？

### 流支持

> 难题：**怎样将全新的概念引入已经被大量第三方类库使用的老的库中**。
>
> 比如在 **Random** 中添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。 

**【也就是增量更新，遵守开闭原则，不修改原有代码，只增加新的方法】**

> 问题是接口部分怎么改造呢？特别是涉及集合类的接口部分。如果你想把一个集合转换为流，**直接向原有接口中添加新方法会破坏所有老的接口的实现类。**

**【因为接口如果新增加了方法，那么实现类就需要添加对应的实现，就会影响到所有使用该类库的开发者】**

> Java 8 采用的解决方法：**接口中增加 default 默认方法**。这样不会影响到实现接口的类。
>
> 通过这种方案，设计者们可以将流式方法平滑地嵌入到现有的类中。
>
> **内置的 Stream 方法几乎已经满足了我们平常的所有需求。**
>
> **Stream 操作的类型由三种：**
>
> - **创建流**
> - **修改流元素(中间操作 Intermediate Operations)**
> - **消费流元素（终端操作, Terminal Operations）**
>   - 消费流元素通常意味着收集流元素（通常是到集合中）。【也就是将流转化为具体的集合】

### 小结

- 主要先简单的介绍了一下流，有了一个初步的认知，同时也产生了很多疑问，比如流为什么能表示无限大的序列，流的懒加载机制是怎样运作的等。

- Java 8的各个特性果然是互相联系互相支持的，为了平滑地增加 Stream 方法同时不影响已有接口的实现，于是有了 default 关键字，有了接口默认方法

  



### 流创建

> 使用 **`Stream.of()`** 可以很容易地将一组元素转化称为流：

 【**这里使用的 Bubble 是在后面才创建的 但是这个例子中要使用**】

```java
public class Bubble {
    public final int i;

    public Bubble(int n) {
        i = n;
    }

    @Override
    public String toString() {
        return "Bubble(" + i + ")";
    }

    private static int count = 0;

    public static Bubble bubbler() {
        return new Bubble(count++);
    }
}

```



```java
// StreamOf.java
public class StreamOf {
    public static void main(String[] args) {

        // 这里有三个将传入元素转为流的例子
       
        Stream.of(new Bubble(1),
                new Bubble(2),
                new Bubble(3))
                .forEach(System.out::println);

        Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie! ")
                .forEach(System.out::print);

        System.out.println();

        Stream.of(3.14159, 2.718, 1.618)
                .forEach(System.out::println);
    }
}
/**
输出：
Bubble(1)
Bubble(2)
Bubble(3)
It's a wonderful day for pie! 3.14159
2.718
1.618
*/
```

【**既然用到了新的类，而且这么重要，那么一定要去看一下源码：**】

```java
// 指出顺序和并行聚合操作一系列元素的类 里面包括了各种重要的操作
// 该接口的方法很多，而且都是核心方法，所以这里只列出例子中用到的
public interface Stream<T> extends BaseStream<T, Stream<T>> {
  
  // 这两个方法可以看到是对应不同情况，一个是返回单个对象的Stream 一个是返回载有多个元素的Stream。
    @SafeVarargs
    @SuppressWarnings("varargs") // Creating a stream from an array is safe
    public static<T> Stream<T> of(T... values) {
        return Arrays.stream(values);
    }
  
   public static<T> Stream<T> of(T t) {
        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);
    }
}
```

> 除此之外，每个集合都可以通过 **`stream()`** 方法来产生一个流：

```java
// streams/CollectionToStream.java
// 将集合框架转换为流的例子
public class CollectionToStream {
    public static void main(String[] args) {

        List<Bubble> bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        // 将 List 转为流，然后将 bubble 中的 i 求和 这里 i 分别是 1/2/3
        System.out.println(bubbles.stream()
                .mapToInt(bubble -> bubble.i)
                .sum());

        Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
        w.stream()
                .map(x -> x + " ")
                .forEach(System.out::print);
        System.out.println();

        HashMap<String, Double> m = new HashMap<>();
        m.put("pi", 3.1415926);
        m.put("e", 2.718);
        m.put("phi", 1.618);

        m.entrySet()
                .stream()
                .map( e -> e.getKey() + ": " + e.getValue())// 每个键值对中间插一个 ": "
                .forEach(System.out::println);
    }
}
/**
输出
6
a pie! It's for wonderful day
phi: 1.618
e: 2.718
pi: 3.14159
*/
```

【这里可以看到，每个集合都可以调用 `stream()`方法，因为刚才也说了，为了平滑嵌入流式编程，在之前的接口中增加 默认函数就可以，所以可以看到这里的 方法来自于集合框架顶层接口 Collection 中的 `stream()`】

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200220203038.png)

> 创建 `List<Bubble>` 对象之后，调用 `stream()`获取流， `map()` 会**获取流中的所有元素**，**并且对流中元素应用操作从而产生新的元素**【也就是对流中的元素进行加工】，并将其传递到后续的流中。
>
> **通常 `map()` 会获取对象并产生新的对象**，但是这里产生了特殊的用于数值类型的流。例如 `mapToInt()`方法将一个对象流 (Object Stream) 转换成为包含整形数字的 `IntStream`。【避免了自动装箱，可以提高效率？】
>
> 同样，针对 `Float` 和 `Double` 也有类似名字的操作。
>
> 我们通过调用字符串的 `split()`操作，根据空格进行切分获取 w。
>
> 为了从 Map 集合中产生流数据，首先调用 `entrySet()` 产生一个对象流，每个对象都包含一个 `key` 和与其关联的 `value`, 然后分别调用 `getKey()` 和 `getValue()`获取值

**【至于为啥Map需要获取 EntrySet 然后才调用 stream ，因为该函数只在 Collection 接口中存在，Map里是没有的。】**

#### 随机数流

> `Random` 类被一组生成流的方法**增强**了：

```java
// RandomGenerators.java
public class RandomGenerators {
    // 打印流中前4个元素
    public static <T> void show(Stream<T> stream) {
        stream.limit(4)
                .forEach(System.out::println);
        System.out.println("------------");
    }

    public static void main(String[] args) {
        Random rand = new Random(47);
        show(rand.ints().boxed());
        show(rand.longs().boxed());
        show(rand.doubles().boxed());
        // 增加上下限范围限制
        show(rand.ints(10,20).boxed());
        show(rand.longs(50,100).boxed());
        show(rand.doubles(20,30).boxed());

        // 控制流大小：
        show(rand.ints(2).boxed());
        show(rand.longs(2).boxed());
        show(rand.doubles(2).boxed());

        // 控制流的大小和界限
        show(rand.ints(3, 3, 9).boxed());
        show(rand.longs(3, 12, 22).boxed());
        show(rand.doubles(3, 11.5, 12.3).boxed());
    }
}
/**
输出
什么都没有限制的
-1172028779
1717241110
-2014573909
229403722
------------
2955289354441303771
3476817843704654257
-8917117694134521474
4941259272818818752
------------
0.2613610344283964
0.0508673570556899
0.8037155449603999
0.7620665811558285
------------
限制流上下限的
16
10
11
12
------------
65
99
54
58
------------
29.86777681078574
24.83968447804611
20.09247112332014
24.046793846338723
------------
限制流元素个数的

1169976606
1947946283
------------
2970202997824602425
-2325326920272830366
------------
0.7024254510631527
0.6648552384607359
------------
限制流元素个数和上下限的

6
7
7
------------
17
12
20
------------
12.27872414236691
11.732085449736195
12.196509449817267
------------
```

> 这里泛型方法 `show(String<T> stream); ` 类型参数 `T` 可以是任何类型，但是 Random 类只能生成 基本类型 int,long,double的流，所以代码中使用了 **`boxed()` 函数，将基本类型转为 包装类型**，使 `show()`能接受流。
>

```java
// IntPipeline.java

		/**
		返回一个由该流的元素组成的Stream，每个元素都装在一个Integer中。
这是一个中间操作。*/
		@Override
    public final Stream<Integer> boxed() {
        return mapToObj(Integer::valueOf);
    }
```

> 我们可以使用 Random 为任意对象创建集合 Supplie。下面是一个文本文件提供字符串对象的例子：
>
> Cheese.data 文件的内容:

```
// streams/Cheese.dat
Not much of a cheese shop really, is it?
Finest in the district, sir.
And what leads you to that conclusion?
Well, it's so clean.
It's certainly uncontaminated by cheese.
```

> 我们通过 File 类将 `Cheese.dat` 文件的所有行读取到 `List<String>`中：

```java
// RandomWords.java
public class RandomWords implements Supplier<String> {

    List<String> words = new ArrayList<>();
    Random rand = new Random(47);

    RandomWords(String fname) throws IOException {
        // 读取传入文件路径的所有内容
        // 这里Paths 路径获取文件中的文件必须在 Parents 文件夹下面，否则只能根据绝对路径查找对应的文件
        List<String> lines = Files.readAllLines(Paths.get(fname));

        // 略过第一行
        for (String line : lines.subList(1, lines.size())) {
            for (String word : line.split("[ .?,]+")) {
                words.add(word.toLowerCase());
            }
        }
    }


    @Override
    public String get() {
        return words.get(rand.nextInt(words.size()));
    }

    @Override
    public String toString() {
        return words.stream().collect(Collectors.joining(" "));
    }

    public static void main(String[] args) throws IOException {
        System.out.println(Stream.generate(new RandomWords("Cheese.dat")) // 这里我是必须使用绝对路径的，如果使用文件名会找不到文件
                .limit(10)
                .collect(Collectors.joining(" ")));
    }
}
/**
  输出
  it shop sir the much cheese by conclusion district is
  */
```



> 这里 `split()`使用正则来分割，**每一行都被 `split()` 通过空格或者被方括号包裹的任意标点符号进行分割。**在结束方括号后面的 `+` 代表 `+` 前面的东西可以出现一次或者多次。
>
> 在构造函数中循环体使用命令式编程（外部迭代）。
>
> `toString（）` 和 主方法中你看到了 `collect()` 收集操作，它根据参数来组合流中的所有元素。
>
> `Collector.joining()` 会得到一个 String 类型的返回值，每个元素都根据 `joining()` 的参数来进行分割。 还有许多不同的 `Collector` 用于产生不同的结果。
>
> `Stream.generator()` 可以把任意的 `Supplier<T>` 用于生成 `T` 类型的流

```java
// Stream.java
		/**
		返回无限顺序无序流，其中每个元素由提供的Supplier生成。 这适用于生成恒定流，随机元素流等。
		*/
    public static<T> Stream<T> generate(Supplier<T> s) {
        Objects.requireNonNull(s);
        return StreamSupport.stream(
                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
    }
```

**【如果是第一次接触大量的Stream的 API，一定是会比较懵逼的，可以再去单独找找专门讲解的文章。】**



