---
layout: post
title: 《On Java8》第十九章——RTTI(4)【完】
date: 2020-02-28
tags:
- 读书笔记
categories: 
- 《On Java8》

---



### Optional 类

> 如果你使用内置的 `null` 来表示空指针对象，那么每次使用引用的时候就必须测试一下引用是否为`null` ，这显得很枯燥。而且 null 没有自己的行为，只是在你想使用它执行操作的时候抛出空指针异常。 
>
> <!-- more -->	
>
> **【但是其实开发中都是Controller层对入参校验，不过如果有别的数据的引用确实需要比较频繁的参数校验，防御式编程嘛】**
>
> `java.util.Optional` 为 `null` 值提供了一个轻量级的代理， `Optional` 对象可以防止你的代码直接抛出 `NullPointException`。
>
> 虽然 `Optional` 是 `Java8` 为了支持流式编程才引入的，但其他它是一个通用工具。
>
> 只要需要检测引用是否为`null` 的地方都使用 `Optional` 是没有意义的，**`Optional` 最有用的是在那些 "更接近数据的地方"，在问题空间中代表实体的对象上。**
>
> 举个简单的例子，很多系统中都有 `Person` 类型，代码中有些情况下你可能没有一个实际的 `Person` 对象（或者可能有，但是你还没用到）这时在传统方法下，你会用到一个 为空的引用，并且在使用之前你需要对这个引用是否为空进行测试。 
>
> 而现在，我们可以使用 `Optional`:

```java
// typeinfo/Person.java
public class Person {
  // 无论入参对象是否为null，都会有一个 Optional 赋值给对应的字段。
    public final Optional<String> first;
    public final Optional<String> last;
    public final Optional<String> address;
    // etc.
    public final Boolean empty;

    Person(String first, String last, String address) {
        this.first = Optional.ofNullable(first);
        this.last = Optional.ofNullable(last);
        this.address = Optional.ofNullable(address);
       // 三个字段都为空，则 empty 为 true
        empty = !this.first.isPresent() && !this.last.isPresent() && !this.address.isPresent();
    }

    Person(String first, String last) {
        this(first, last, null);
    }

    Person(String last) {
        this(null, last, null);
    }

    Person() {
        this(null, null, null);
    }

    @Override
    public String toString() {
        // 如果三个字段都不存在，返回  "<Empty>"
        if (empty) {
            return "<Empty>";
        }   // 如果有值就打印，没有值的话取默认值 空字符串
        return (first.orElse("") + " "
                + last.orElse("") + " "
                + address.orElse("")).trim();
    }

    public static void main(String[] args) {
        System.out.println(new Person());
        System.out.println(new Person("Smith"));
        System.out.println(new Person("Bob", "Smith"));
        System.out.println(new Person("Bob", "Smith",
                "11 Degree Lane, Frostbite Falls, MN"));
    }

}
/**
输出
<Empty>
Smith
Bob Smith
Bob Smith 11 Degree Lane, Frostbite Falls, MN
*/
```

> `Person` 的设计有时候又叫 **"数据传输对象"** (**DTO,data-transfer object**)。 注意，所有字段都是 `public` 和 `final` 的。所以没有 `getter` 和 `setter` 方法。也就是说，`**Person` 是不可变的**，你只能通过构造器给它进行赋值，之后就是只读状态而不能修改。（**字符串本身就是不可变对象，无法修改字符串的内容，也无法给字符串重新赋值**）
>
> 如果你想修改一个 `Person`，只能用一个新的 `Person` 对象来替换它。
>
> empty 字段在对象被创建的时候被赋值，用于快速判断这个 Person 是不是空对象。
>
> 如果想使用 `Person`，就必须使用 `Optional` 接口才能访问它对于的 `String`字段，这样就不会触发空指针异常了。
>
> 假设你现在需要招兵买马，有很多 Person 对象等待被赋值，你可以将 `Person Optional` 对象放在每个 `Position` 上：

```java
//typeinfo/Position.java
class EmptyTitleException extends RuntimeException {
}

public class Position {
    private String title;
    private Person person;

    public Position(String title, Person employee) {
        setTitle(title);
        setPerson(employee);
    }
    // 设置一个空的职位
    Position(String jobTitle) {
        this(jobTitle, null);
    }

    public String getTitle() {
        return title;
    }


    // 如果设置Title的时候传入的值为null则抛出对应异常
    private void setTitle(String newTitle) {
        title = Optional.ofNullable(newTitle).orElseThrow(EmptyTitleException::new);
    }

    public Person getPerson() {
        return person;
    }

    // 如果传入的员工为null则在方法中重新构造一个Person对象
    private void setPerson(Person newPerson) {
        person = Optional.ofNullable(newPerson).orElse(new Person());
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Position.class.getSimpleName() + "[", "]")
                .add("title='" + title + "'")
                .add("person=" + person)
                .toString();
    }

    public static void main(String[] args) {
        System.out.println(new Position("CEO"));
        System.out.println(new Position("Programmer",new Person("Ahri","Ricky")));
        try {
            // 抛出 EmptyTitleException
            new Position(null);
        } catch (Exception e) {
            System.out.println("Caught: " + e);
        }
    }
}
/**
输出
Position[title='CEO', person=<Empty>]
Position[title='Programmer', person=Ahri Ricky]
Caught: typeinfo.EmptyTitleException
*/
```

> 这里 `title` 和 `Person` 都是普通字段，没有用 `Optional`包裹，但是修改这些字段的唯一途径是调用 `setTitle()` 和 `setPerson()` 方法，这两个都借助 `Optional` **对字段**进行了严格的**限制**。
>
> 同时为了保证 `title` 字段永远不会为 `null`。所以在方法中对传入参数 newTitle 进行了检查，但是其实还有更好的做法，**函数式编程的一大优势就是可以让我们重用经过验证的功能**（即时功能很小），以减少自己手动编写可能产生的错误。
>
> 所以这里我们使用 `ofNullable`() 把`newTitle` 转换为了一个 `Optional`，如果传入值为null，则 `ofNullable` 返回的讲师 `Optional.empy`，紧接着调用 `orElseThrow`() 抛出异常。
>
> 我们没有把 title 保存成 `Optional`，但是通过 `Optional` 的功能，仍然对字段施加了约束。
>
> 同时抛出的异常在错误产生时（newTitle 为一个空指针）就被抛出，特定的异常类名+特定的抛出位置让我们可以快速定位到异常发生的地方。
>
> `Person` 的字段限制则是如果传入为 `null` 则自动生成一个对象。
>
> 请注意，虽然你清楚你使用了 `Optional`，避免了空指针异常的出现。可是 Staff 类却对此毫不知情：

```java
// typeinfo/Staff.java
public class Staff extends ArrayList<Position> {
    public void add(String title, Person person) {
        add(new Position(title, person));
    }

    public void add(String... titles) {
        for (String title : titles) {
            add(new Position(title));
        }
    }
    public Staff(String... titles) {
        add(titles);
    }

    public Boolean positionAvailable(String title) {
        for (Position position : this) {
            if (position.getTitle().equals(title) && position.getPerson().empty) {
                return true;
            }
        }
        return false;
    }

    public void fillPosition(String title, Person hire) {
        for (Position position : this) {
            if (position.getTitle().equals(title) && position.getPerson().empty) {
                position.setPerson(hire);
                return;
            }
        }
        throw new RuntimeException("Position " + title + "not avaliable");
    }

    public static void main(String[] args) {
        Staff staff = new Staff("President", "CTO",
                "Marketing Manager", "Product Manager",
                "Project Lead", "Software Engineer",
                "Software Engineer", "Software Engineer",
                "Software Engineer", "Test Engineer",
                "Technical Writer");


        staff.fillPosition("President",
                new Person("Me", "Last", "The Top, Lonely At"));
        staff.fillPosition("Project Lead",
                new Person("Janet", "Planner", "The Burbs"));

        if (staff.positionAvailable("Software Engineer")) {
            staff.fillPosition("Software Engineer",
                    new Person(
                            "Bob", "Coder", "Bright Light City"));
        }
        System.out.println(staff);
    }

}
/**
输出
[Position[title='President', person=Me Last The Top, Lonely At], Position[title='CTO', person=<Empty>], Position[title='Marketing Manager', person=<Empty>], Position[title='Product Manager', person=<Empty>], Position[title='Project Lead', person=Janet Planner The Burbs], Position[title='Software Engineer', person=Bob Coder Bright Light City], Position[title='Software Engineer', person=<Empty>], Position[title='Software Engineer', person=<Empty>], Position[title='Software Engineer', person=<Empty>], Position[title='Test Engineer', person=<Empty>], Position[title='Technical Writer', person=<Empty>]]
*/
Process finished with exit code 0

```

> 在有的使用场景中，你还需要检查引用是否为 Optional ，这跟检查引用是否为 null 没有多大区别，但是在其他地方（比如本例中）就不用执行额外的测试了，可以直接假设所有对象都是有效的。



#### 标记接口

> 有时候使用一个**标记接口**来**表示空值**会更方便。**标记接口里边什么都没有**，你只要把它的名字当做**标签**来用就可以。

**【也就是可以对实现了某接口的对象做一些特殊操作，这个接口就相当于一个特殊的标签】**

```java
// onjava/Null.java
package onjava;
public interface Null {}
```



> 如果使用接口取代具体的类类型，那么可以使用动态代理来自动地创建 Null 对象。
>
> 假设我们有一个 Robot接口，它定义了一个名字，一个模型和一个描述 Robot 行为能力的 `List<Operation>`：

```java
// Robot.java
public interface Robot {
    String name();

    String model();

    List<Operation> operations();

    static void test(Robot r) {
        if (r instanceof Null) {
            System.out.println("[Null Robot]");
        }
        System.out.println("RobotName: " + r.name());
        System.out.println("RobotModel: " + r.model());

        for (Operation o : r.operations()) {
            System.out.println(o.description.get());
            o.command.run();
        }
    }
}


```

> 可以通过 operations() 来访问 Robot 的服务。 Robot 里还包含一个 static 方法来执行测试。
>
> Operation 包含一个描述和一个命令（使用到了**命令模式**）。它们被定义成函数接口的引用，所以可以把 Lambda 表达式或者方法的引用传给 Option 构造器。

```java
// typeinfo/Operation.java

import java.util.function.*;

public class Operation {
    public final Supplier<String> description;
    public final Runnable command;

    public Operation(Supplier<String> descr, Runnable cmd) {
        description = descr;
        command = cmd;
    }
}
```



这里的 Null 对象作者没有提，但是你会发现也是需要的，代码如下：

```java
// 一个空的接口
public interface Null {}
```



> 下面创建一个扫雪机器人：

```java
// SnowRemovalRobot.java
public class SnowRemovalRobot implements Robot {

    private String name;

    public SnowRemovalRobot(String name) {
        this.name = name;
    }

    @Override
    public String name() {
        return name;
    }

    @Override
    public String model() {
        return "我是一个扫雪机器人，B-ling，B-long";
    }

    private List<Operation> ops =
            Arrays.asList(
                    new Operation(
                            () -> name + " can shovel snow",
                            () -> System.out.println(name + " shoveling snow")),
                    new Operation(
                            () -> name + "can ship ice",
                            () -> System.out.println(name + " chipping ice")),
                    new Operation(
                            () -> name + " can clear the roof",
                            () -> System.out.println(name + " clearing roof")));


    @Override
    public List<Operation> operations() {
        return ops;
    }

    public static void main(String[] args) {
        Robot.test(new SnowRemovalRobot("Slusher"));
    }
}
/**
输出
RobotName: Slusher
RobotModel: 我是一个扫雪机器人，B-ling，B-long
Slusher can shovel snow
Slusher shoveling snow
Slushercan ship ice
Slusher chipping ice
Slusher can clear the roof
Slusher clearing roof
*/

```

> 假设存在很多不同类型的 Robot，我们想让每种 Robot 都创建一个 Null 对象来执行一些特殊的操作—— 在本例中，即提供 Null 对象所代表的 Robot 的确切类型信息。 这些信息是通过**动态代理**捕获的：
>
> 

```java
// NullRobot.java
class NullRobotPRoxyHandler implements InvocationHandler {
    private String nullName;
    private Robot proxied = new NRobot();

    NullRobotPRoxyHandler(Class<? extends Robot> type) {
        nullName = type.getSimpleName() + " NullRobot";
    }

    private class NRobot implements Null, Robot {

        @Override
        public String name() {
            return nullName;
        }

        @Override
        public String model() {
            return nullName;
        }

        @Override
        public List<Operation> operations() {
            return Collections.emptyList();
        }
    }


    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(proxied, args);
    }
}

public class NullRobot {
    public static Robot newNullRobot(Class<? extends Robot> type) {
        return (Robot) Proxy.newProxyInstance(
                NullRobot.class.getClassLoader(),
                new Class[]{Null.class, Robot.class},
                new NullRobotPRoxyHandler(type)
        );
    }

    public static void main(String[] args) {
        Stream.of(
                new SnowRemovalRobot("SnowBee"),
                newNullRobot(SnowRemovalRobot.class)
        ).forEach(Robot::test);
    }
}
/**
输出
RobotName: SnowBee
RobotModel: 我是一个扫雪机器人，B-ling，B-long
SnowBee can shovel snow
SnowBee shoveling snow
SnowBeecan ship ice
SnowBee chipping ice
SnowBee can clear the roof
SnowBee clearing roof
[Null Robot]
RobotName: SnowRemovalRobot NullRobot
RobotModel: SnowRemovalRobot NullRobot
*/

```

> 只要需要一个空的 Robot 对象，调用 `newNullRobot` 并传递需要代理的 `Robot` 的类型就可以获取。 这个代理满足了 `Robot` 和 `Null` 接口的需要，**并提供了它所代理的类型的确切名字。**

#### Mock 对象和桩

> Mock 对象和 桩（Stub) 逻辑上都是 Optional 的变体。他们都是最终程序中所使用的"实际对象的代理"。
>
> 不过，Mock 对象和桩都是假扮成那些可以传递实际信息的对象，而不是像 Optional 把包含潜在 null 值的对象隐藏。

**【也就是 Optional 是对 null 的封装，Mock 和 Stub 我还没有建立起概念与实际用途的映射关系，在我脑子里这俩还只是最抽象的概念。】**

> Mock 对象轻量级，用于自测试。
>
> 桩是返回桩对象，重量级，在多个测试中被复用。 桩通过配置进行修改，Mock 被大量创建，因为它又小又简单。

### 接口和类型

> `interface` 关键字的重要目标就是解耦。
>
> 但是同类类型信息，耦合性还是会被传播出去。接口并不是对解耦无懈可击的保障。
>
> 先定义一个接口 A:

```java
// typeinfo/interfacea/A.java
package typeinfo.interfacea;

public interface A {
    void f();
}
```

> 然后实现这个接口：

```java
// InterfaceViolation.java
class B implements A {
    @Override
    public void f() {
        System.out.println("B.f()");
    }
    public void g() {
        System.out.println("B.g()");
    }
}

public class InterfaceViolation {
    public static void main(String[] args) {
        A a = new B();
        a.f();
        //a.g() //编译异常，因为g是子类实现的方法，接口中并不包含
        System.out.println(a.getClass().getName());
        if (a instanceof B) {
            B b = (B) a;
            b.g();
        }
    }
}
/**
输出
B.f()
typeinfo.B
B.g()
*/
```

> 这里将接口的引用通过 Instanceof 确定类型后转为更具体的子类的引用，调用子类中接口不包含的方法，是一种合情合理的操作。但是也许类库的设计者并不想让客户端开发者这么做。
>
> 一种解决方案是直接声明：如果开发者决定使用实际的类而不是接口，他们需要自己对自己负责。这还不够，更严格的限制方式包括：
>
> **使实现类只具有包访问权限**，这样在包外的客户端类中就无法看到具体的实现类：

```java
// typeinfo/packageaccess/HiddenC.java
class C implements A {
    @Override
    public void f() {
        System.out.println("public C.f()");
    }
    public void g() {
        System.out.println("public c.g()");
    }
    void u () {
        System.out.println("packge C.u()");
    }
    protected void v() {
        System.out.println("protected C.v()");
    }

    private void w() {
        System.out.println("private C.w()");
    }
}

public class HiddenC {
    public static A makeA() {
        return new C();
    }
}

```

> 这个包中唯一的 public 的部分就是 HiddenC，在被调用时产生 A接口类型的对象。这里的有趣之处在于：即使你从 makeA() 返回的是其子类 C类型的实例，但你在包外扔不能调用 A 之外的方法。因为你不能再包的外部命名C。
>
> 如果你试着将其向下转型为 C，则将被禁止，因为包的外部没有任何C类型可用：

```java
// typeinfo/HiddenImplementation.java
public class HiddenImplementation {
    public static void main(String[] args)
            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        A a = HiddenC.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 编译器抛出异常，因为无法找到变量类型C
        /* if(a instanceof C) {
            C c = (C)a;
            c.g();
        } */
        callHiddenMethod(a, "g");
        callHiddenMethod(a, "u");
        callHiddenMethod(a, "v");
        callHiddenMethod(a, "w");
    }

     static void callHiddenMethod(Object a,String methodName)
             throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
         Method g = a.getClass().getDeclaredMethod(methodName);
         g.setAccessible(true);
         g.invoke(a);
     }
}

/**
输出
public C.f()
typeinfo.packageaccess.C
public c.g()
packge C.u()
protected C.v()
private C.w()
*/
```

> 可用看到反射非常强大，只要你知道方法名，并在 `Method`对象上讲 `Accessible` 设置为 `true`。 就可以调用所有方法，甚至是 `private` 方法。
>
> 也许你觉得只发布编译后的 .class 文件可以解决这种问题，但是使用 javap 命令行就可以进行反编译。
>
> 

![image-20200305213944355](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200305213950.png)

> **因此，任何人都可以获取你最私有的方法的名字和签名，然后通过反射进行调用。**

> 如果把接口实现为一个私有内部类，会发生什么：

```java
// typeinfo/InnerImplementation.java
class InnerA {
    //私有静态内部类实现接口A
    private static class C implements A {

        @Override
        public void f() {
            System.out.println("public C.f()");
        }

        public void g() {
            System.out.println("public C.g()");
        }

        void u() {
            System.out.println("package C.u()");
        }

        protected void v() {
            System.out.println("protected C.v()");
        }

        private void w() {
            System.out.println("private C.w()");
        }
    }

    public static A makeA() {
        return new C();
    }
}

public class InnerImplementation {
    public static void main(String[] args)
            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        A a = InnerA.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 反射仍然可以调用私有静态内部类的方法
        HiddenImplementation.callHiddenMethod(a, "g");
        HiddenImplementation.callHiddenMethod(a, "u");
        HiddenImplementation.callHiddenMethod(a, "v");
        HiddenImplementation.callHiddenMethod(a, "w");
    }
}
/**
输出
public C.f()
typeinfo.InnerA$C
public C.g()
package C.u()
protected C.v()
private C.w()
*/
```

> 这里反射仍然可以调用私有静态内部类的方法，那么如果是匿名类呢：

```java
// typeinfo/AnonymousImplementation.java
class AnonymousA {
    public static A makeA() {
        // 返回一个A的匿名对象
        return new A() {
            public void f() {
                System.out.println("public C.f()");
            }

            public void g() {
                System.out.println("public C.g()");
            }

            void u() {
                System.out.println("package C.u()");
            }

            protected void v() {
                System.out.println("protected C.v()");
            }

            private void w() {
                System.out.println("private C.w()");
            }
        };
    }
}

public class AnonymousImplementation {
    public static void main(String[] args)
            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        A a = AnonymousA.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 反射仍然可以调用匿名类对象的所有方法
        HiddenImplementation.callHiddenMethod(a, "g");
        HiddenImplementation.callHiddenMethod(a, "u");
        HiddenImplementation.callHiddenMethod(a, "v");
        HiddenImplementation.callHiddenMethod(a, "w");

    }
}
/**
输出
public C.f()
AnonymousA$1
public C.g()
package C.u()
protected C.v()
private C.w()
*/
```

> 任何方式都不能阻止反射调用非公共访问权限的方法。对于字段来说也是这样，即使是私有字段：

```java
// typeinfo/ModifyingPrivateFields.java

class WithPrivateFinalField {
    // 都是私有字段
    private int i = 1;
    private final String s = "I'm totally safe";
    private String s2 = "Am I safe?";

    @Override
    public String toString() {
        return "i = " + i + ", " + s + ", " + s2;
    }
}

public class ModifyingPrivateFields {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        WithPrivateFinalField pf = new WithPrivateFinalField();
        System.out.println(pf);

        Field f = pf.getClass().getDeclaredField("i");

        f.setAccessible(true);

        System.out.println("f.getInt(pf): " + f.getInt(pf));
        f.setInt(pf, 47);
        System.out.println(pf);

        f = pf.getClass().getDeclaredField("s");
        f.setAccessible(true);
        System.out.println("f.get(pf): " + f.get(pf));
        f.set(pf, "No, you're not!");
        System.out.println(pf);
        f = pf.getClass().getDeclaredField("s2");
        f.setAccessible(true);
        System.out.println("f.get(pf): " + f.get(pf));
        f.set(pf, "No, you're not!");
        System.out.println(pf);
    }
}
/**
输出
i = 1, I'm totally safe, Am I safe?
f.getInt(pf): 1
i = 47, I'm totally safe, Am I safe?
f.get(pf): I'm totally safe
i = 47, I'm totally safe, Am I safe?
f.get(pf): Am I safe?
i = 47, I'm totally safe, No, you're not!
*/
```

> 可以看到 私有变量 int 被修改了。
>
> 而 2个 String 并没有发生变化。 final 字段 或者不可变类在被修改时是安全的。运行时系统会在不抛出异常的情况下接受任何修改的尝试，但实际上不会发生任何修改。

### 本章小结

运行时类型信息，给我们带来了很多好处，有很强大的灵活性，也有强大的反射。

> 面向对象编程语言是想让我们尽可能地使用多态机制，只在非用不可的时候才使用 RTTI。