---
layout: post
title: 《On Java8》第六章——初始化和清理
date: 2020-02-11 23:48:11
tags:
- 读书笔记
categories: 
- 《On Java8》

---

## 第六章 初始化和清理

#### 垃圾回收器

> Java中使用垃圾回收器回收无用对象占用的内存。	

![](https://xuyanxin-blog-bucket.oss-cn-beijing.aliyuncs.com/blog/20200226111730.png)

<!-- more -->	

但是现在考虑一种特殊情况：你创建的对象不是通过 new 来分配内存的，而垃圾回收器只知道如何释放用 new 创建的对象的内存，所以它不知道如何回收不是 new 分配的内存。 为了处理这种情况，Java 允许在类中定义一个名为 finalize() 的方法。

#### 垃圾回收器如何工作：

- 引用计数法

  ​	每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计时加1。当引用离开作用域或者被设置为 null 时，引用计数减1.因此，管理运用计数是一个开销不大，但是在程序的整个生命周期频繁发生的负担。垃圾回收期会遍历含有全部对象的列表，当发现某个对象的引用计数为0时，就释放其占用的空间（但是，引用计数模式经常会在计数为0时立即释放对象）。

  ​	这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的技术都不会为0，就会出现无法被回收的情况。

  ​	对垃圾回收器而言，定位这样的循环引用所需要的工作量极大。引用计数常用来说明垃圾回收的工作方式，但是未被应用于具体 Java 虚拟机的实现中。

- “标记-清扫”

在更快的策略中，垃圾回收器并非基于引用计数。它们的依据是：对于任意“活”的对象，一定能最终追溯到其存活在栈或静态存储区中的引用，这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，**遍历所有引用**，你将会发现所有“活“的对象。

**对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，直到访问完”根源于栈或静态存储区的引用“所形成的整个网络。你所访问过的对象一定是”活“的。**

**注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。**

在这种方式下，Java 虚拟机采用了一种 **自适应 的垃圾回收技术**。 至于如何处理找到的存活对象，取决于不同 Java 虚拟机的具体实现。其中有一种方法叫做 **停止-复制**(stop-and-copy) 顾名思义，**这需要先暂停程序的运行（**不属于后台回收模式），**然后将所有存活的对象从当前堆复制到另一个堆**，没有复制的就是需要被垃圾回收的。另外，**当对象被复制到新堆时，它们是一个挨着一个紧凑排列**，然后就可以按照前面描述的那样简单直接的分配新空间了。

当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以被直接修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成一个表格，将旧地址映射到新地址。）

这种所谓的”复制回收器“效率低下主要是因为两个原因：

- 其一，**得有两个堆**，然后在这两个分离的堆之间来回折腾，得维护比实际需要多一倍的空间。某些 Java 虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。
- 其二，在于复制本身。一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处。这很浪费。为了避免这种状态，一些 Java 虚拟机会进行检查：要是没有新的垃圾产生，就会转换到另一种模式（即”自适应”），这种模式被称为 **标记-清扫**,Sun公司早期的 Java 虚拟机一直使用这种技术。对一般用途而言，**标记-清扫**方式速度相当慢，**但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。**【问题来了什么情况下，程序才是处于产生少量垃圾甚至不产生垃圾的状态呢？】

标记-清扫 所依据的思路仍然是从 **栈和静态存储区**出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活的对象，就给一个对象设定一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。

**标记-清扫后剩下的堆空间是不连续的**，垃圾回收期要是希望得到连续的空间的话，就需要重新**整理**剩下的对象。

停止-复制 指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。

在 Oracle 公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程。但是早期版本的 Java 虚拟机并不是这么实现垃圾回收器的。

**当可用内存较低时，垃圾回收器会暂停程序。**

同样 标记-清扫 工作也必须在程序暂停的情况下才能进行。

如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的“块”为单位。 

如果对象较大，它会占用单独的块。

严格来说**，停止-复制要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆。这导致了大量的内存复制行为。**

有了块，垃圾回收器就可以把对象复制到废弃的块。**每个块都有年代数来记录自己是否存活。**通常，如果块在某处被引用，其年代数加1，垃圾回收期会对上次回收动作之后新分配的块进行整理。

**这对处理大量生命周期短的临时对象很有帮助。**

垃圾回收期会定期进行完整的清理动作---大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。

Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到 标记-清扫 方式。同样，Java 虚拟机会跟踪 标记-清扫 的结果，如果堆空间出现很多碎片，就会切换回停止-复制方式。这就是自适应的由来。

**你可以给它一个啰嗦的称呼：自适应的，分代的，复制-停止，标记-清扫式的垃圾回收器。**



